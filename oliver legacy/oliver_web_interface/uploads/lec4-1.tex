\setlength{\columnseprule}{1pt}
\def\columnseprulecolor{\color{blue}}


% \begin{frame}[fragile]
% \Title{ Single-Cycle Processor Implementation}
% \begin{itemize}

% \item How to build datapath, control for specific architecture
% \item We will implement small subset of ARM operations:
% \begin{itemize}
% \item Load ({\tt LDUR}) and store ({\tt STUR})
% \item Add ({\tt ADD}), subtract ({\tt SUB}), and ({\tt AND}), or ({\tt
% ORR}).
% \item Compare and branch on zero ({\tt CBZ}) and branch ({\tt B})
% \end{itemize}
% \item These suffice to illustrate fundamental ideas
% \end{itemize}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item
% Sections 4.1 and 4.2 are introductory material; section 4.3 discusses building the
% datapath, and section 4.4 completes the description and discusses
% control. Section C.2 gives details of implementing control for the MIPS computer (not ARM).  They don't appear to give a similar thing for ARM.

% \item Students
% should be careful to read the captions of all figures carefully, since
% many contain important information that is not discussed in the main
% text. 

% \item We don't implement branch for the single cycle architecture in the initial datapaths, but we add it as an instruction after completing an initial implementation.
% \end{itemize}
% \fi\ENotes
% \end{frame}


\begin{frame}[fragile]
\STitle{Review of ARM Architecture}
\begin{itemize}
\item 32 registers (numbered 0 to 31), each with 64 bits
\item Register 31 (X31 or XZR) always supplies the value 0
\item Memory is byte-addressable\\
  (word addresses multiples of 4, double-word addresses multiples of 8)
\item Instructions are 32 bits long
\item Data is in 64-bit words (double-words)
% \item Instruction memory is All ARM instructions are 32 bits long
\end{itemize}

\begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
  colback=blue!5!white,colframe=blue!75!black,colbacktitle=blue!80!black,
  title=Think About It,fonttitle=\bfseries,
  boxed title style={size=small,colframe=red!50!black} ]
Words have multiple bytes, which byte should be the address of the word?
\begin{itemize}
    \item (Double-)Words have the address of their most significant byte\footnote{in ARMv8 this is dynamic, x86 prefers LSB as word address}
\end{itemize}

  \end{tcolorbox}

\BNotes\ifnum\Notes=1
~% notes text
\fi\ENotes
\end{frame}

\begin{frame}[fragile]
\Title{Review of ARM Instructions}
\begin{itemize}

\item Add: {\tt ADD X1, X2, X3}
\begin{itemize}
\item Operands are destination register, two source registers
\item Addressing modes: register addressing
\end{itemize}
\item Addi: {\tt ADDI X1, X2, \#3}
\begin{itemize}
\item Operands are destination register, one source register and immediate
\item Addressing modes: register and immediate addressing
\end{itemize}
\item Conditional branch: {\tt CBZ X1, \#10}
\begin{itemize}
\item Operand is registers to compare to 0, immediate
\item Addressing: register and immediate addressing and PC-relative
\end{itemize}
\item Branch: {\tt B \#3000}
\begin{itemize}
\item Operand is immedaite 
% word offset from current PC
\item Addressing mode: PC-relative
	% (need to multiply by 4)
\end{itemize}
\item Load: {\tt LDUR X1, [X2,\#200]}
\begin{itemize}
\item Operands are register to be loaded, address in memory
\item Addressing modes: base (displacement) addressing
\end{itemize}
\end{itemize}
\BNotes\ifnum\Notes=1
\begin{itemize}
\item Store works analogously to load.

\item SUB, AND, ORR work analogously to add. The add instruction
here has only one addressing mode (register); other instructions such
as {\tt ADDI} use other modes.

\item Syntax of conditional branch: If contents of named register equal to 0,
PC gets 40 added to it,
because the ARM architecture is byte-addressable but instructions are
word-aligned, so offsets (and immediates, as in the jump instruction)
are word counts, not byte addresses. The only addressing mode here is
PC-relative. 

\item The addressing mode of the branch instruction is PC-relative
\end{itemize}
\fi\ENotes
\end{frame}

% \begin{frame}[fragile]
% \STitle{High-Level View of ARM Functional Units}
% \PHFigure{!}{2in}{2in}{ARMFigures/Fig0402-crop}{Figure 4.2}
% \begin{itemize}
% \item Multiplexors used to send two signals to one location
% \item Control unit tells other units what to do
% \end{itemize}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item The bullets are the interesting part of this slide
% \end{itemize}
% \fi\ENotes
% \end{frame}

\begin{frame}[fragile]
\STitle{High-Level View of ARM Functional Units}
%	\PHFigure{!}{3in}{3in}{ARMFigures/Fig0401-crop}{Figure 4.1}
	\Figure{!}{1.5in}{1.75in}{Figs/armHL}
\begin{itemize}
\item PC: Program Counter (address of current instruction)
\item Fetch-execute cycle:
\begin{itemize}
\item Fetch instruction (update PC)
\item Execute instruction
\begin{itemize}
\item Fetch register operands
\item Compute result
\item Store into registers OR use to index memory
\end{itemize}
\end{itemize}
\end{itemize}
\BNotes\ifnum\Notes=1
\begin{itemize}
\item The simplified explanation of fetch-execute on the slide does not take
	branching, conditional or otherwise, into account. This should be
	discussed at this point verbally. Note the separate instruction and
	data memories; this also is a simplification, to be justified on the
	next slide.
\item Point out that the register file is the one we designed earlier and
	that the ALU is the one we design.
	Memory is also as we discussed earlier.
\end{itemize}
\fi\ENotes
\end{frame}

% \begin{frame}[fragile]
% \STitle{High-Level View of ARM Functional Units}
% \PHFigure{!}{2in}{2in}{ARMFigures/Fig0402-crop}{Figure 4.2}
% \begin{itemize}
% \item Multiplexors used to send two signals to one location
% \item Control unit tells other units what to do
% \end{itemize}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item The bullets are the interesting part of this slide
% \end{itemize}
% \fi\ENotes
% \end{frame}

\input 04-Single-Cycle-Processor-Implementation/mem

\begin{frame}[fragile]
\STitle{Revisit: High-Level View of ARM Functional Units}
%	\PHFigure{!}{3in}{3in}{ARMFigures/Fig0401-crop}{Figure 4.1}
	\Figure{!}{1.5in}{1.75in}{Figs/armHL}
\begin{itemize}
\item PC: Program Counter (address of current instruction)
\item Fetch-execute cycle:
\begin{itemize}
\item Fetch instruction (update PC)
\item Execute instruction
\begin{itemize}
\item Fetch register operands
\item Compute result
\item Store into registers OR use to index memory
\end{itemize}
\end{itemize}
\end{itemize}
\BNotes\ifnum\Notes=1
\begin{itemize}
\item The simplified explanation of fetch-execute on the slide does not take
	branching, conditional or otherwise, into account. This should be
	discussed at this point verbally. Note the separate instruction and
	data memories; this also is a simplification, to be justified on the
	next slide.
\item Point out that the register file is the one we designed earlier and
	that the ALU is the one we design.
	Memory is also as we discussed earlier.
\end{itemize}
\fi\ENotes
\end{frame}


\begin{frame}[fragile]
\STitle{High-Level View of ARM Functional Units and Control}
\PHFigure{!}{2in}{2in}{ARMFigures/Fig0402-crop}{Figure 4.2}
\begin{itemize}
\item \hl{Multiplexors used to send two signals to one location}
\item \hl{Control unit tells other units what to do}
\end{itemize}
\BNotes\ifnum\Notes=1
\begin{itemize}
\item The bullets are the interesting part of this slide
\end{itemize}
\fi\ENotes
\end{frame}


\begin{frame}[fragile]
\STitle{First Implementation: One Cycle Per Instruction}
\begin{itemize}
\item Simpler to understand, but not practical
\item \hl{Requires separate instruction and data memories}
\item Clock must be slowed to speed of slowest instruction
\item Subsequently we look at multicycle implementations
\end{itemize}
\BNotes\ifnum\Notes=1
\begin{itemize}
\item If we did not have separate instruction and data memories, we could
	not complete the fetch-execute of an instruction in one clock cycle,
	since two accesses to memory may be necessary. In practice instruction
	and data memories are nearly always combined.
\item Of course, in a real computer, we have separate instruction and data
	cache, which is very much like having two separate memories.
\end{itemize}
\fi\ENotes
\end{frame}



\begin{frame}[fragile]
\Title{Implementing Fetch Portion of Fetch-Execute}
	%\PHFigure{!}{4in}{3in}{PHALL/F0505}{Figure 4.6}
	\Figure{!}{2.8in}{1.8in}{Figs/fetchExecute}
{\small \begin{itemize}
\item State elements here are PC (register) and instruction memory
\item Adder is combinational
\end{itemize}}
\begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
  colback=blue!5!white,colframe=blue!75!black,colbacktitle=blue!80!black,
  title=Think About It,fonttitle=\bfseries,
  boxed title style={size=small,colframe=red!50!black} ]
  Can we read from PC and write (update) PC in the same clock cycle? {\small{\color{red}No. PC is updated in the next clock cycle}}
  \end{tcolorbox}
  % \item PC is updated in the next clock cycle

\BNotes\ifnum\Notes=1
\begin{itemize}
% \item Add slashes on the diagram to indicate width; all lines shown are 32
% bits wide.
\item output from PC is 64 bits wide
\item output from Instruction Mem is 32 bits wide
\item Note that PC+4 is in parallel to reading instruction from memory
\end{itemize}
\fi\ENotes
\end{frame}

\begin{frame}[fragile]
\Title{Datapath components for R-format instructions}
\begin{itemize}
\item Example: {\tt ADD X1, X2, X3}
% \includegraphics[scale=0.2]{04-Single-Cycle-Processor-Implementation/figures/R-format.png}

%	\PHFigure{!}{3in}{2in}{PHALL/F0507}{Figure 4.10 (sort of)}
	\Figure{!}{1.5in}{1.5in}{Figs/r-format}

 
 \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
  colback=blue!5!white,colframe=blue!75!black,colbacktitle=blue!80!black,
  title=Think About It,fonttitle=\bfseries,
  boxed title style={size=small,colframe=red!50!black} ]
  Can we execute the instruction \texttt{ADD X1, X1, X2}?
  {\small{\color{red}Yes. Design permits read/write of same register}}
\end{tcolorbox}
% \item Design permits read/write of same register
\end{itemize}
\BNotes\ifnum\Notes=1
\begin{itemize}
\item
We designed edge-triggered multiport register files earlier. If an
instruction like {\tt ADD X1, X1, X2} is executed, the old value
of register {\tt X1} is used as an addend; the new value is written
into the register file, but will not be available for reading (will
not affect the output of the state element) until the next clock
tick. Thus there is no conflict.
\item
Put slashes on the diagram to indicate widths: register names are 5
bits (number of bits needed to address 32 separate registers), all
other lines are 64 bits. Note that we have not specified yet where the
bits come from in the instruction; we discuss precise instruction
formats after doing some high-level design.
\end{itemize}
\fi\ENotes
\end{frame}

\begin{frame}[fragile]
\Title{Datapath components for D-format instructions}
\begin{itemize}
\item Example: {\tt LDUR X1, [X2,\#200]}
% \includegraphics[scale=0.2]{04-Single-Cycle-Processor-Implementation/figures/D-format.png}

	%\PHFigure{!}{4in}{3in}{PHALL/F0509-64}{Figure 4.9 (sort of)}
	\Figure{!}{3in}{2in}{Figs/loadstore}
\item Sign extend is combinational 
\item Assume for simplicity that data memory is edge-triggered
\end{itemize}
\BNotes\ifnum\Notes=1
In reality, large memories are not clocked, and the CPU must be
designed to take into account hold times for inputs and response times
for outputs.
\fi\ENotes
\end{frame}

\begin{frame}[fragile]
  \STitle{Combining R-format and D-format Datapath Components}

  \PHFigure{!}{1.7in}{1.8in}{ARMFigures/Fig0410m-crop.pdf}{Figure 4.10}
  \begin{itemize}
  \item R-format and Memory instructions are similar
  \item MUX in front of second ALU input \hl{selects Reg File output OR Sign-extended constant}
  \item MUX ``in front of'' Reg File write data \hl{selects ALU output OR Memory Read output}
    \end{itemize}
  \BNotes\ifnum\Notes=1
  \begin{itemize}
  \item The book authors label input to sign extend as ``32''; it should be 9
    as on this slide
    \end{itemize}
\fi\ENotes
\end{frame}

\begin{frame}[fragile]
\Title{Datapath components for CB-format instructions}
\begin{itemize}
\item Example: {\tt CBZ X1, \#100}
% \includegraphics[scale=0.2]{04-Single-Cycle-Processor-Implementation/figures/CB-format.png}

\includegraphics[scale=0.5]{04-Single-Cycle-Processor-Implementation/figures/cb-datapath.png}
	% \PHFigure{!}{4.5in}{4in}{PHALL/F0510-64}{Figure 4.9}
	% \Figure{!}{2in}{2in}{Figs/branch}
\item Shift is necessary because offset given is in words
\item Still need mechanism to control PC loading
\item \hl{Special ALUop to \texttt{Pass-B} -- pass input 'b' to ouput ('a' ignored).}
\end{itemize}
\BNotes\ifnum\Notes=1
\fi\ENotes
\end{frame}

% for comprehensive
\newpage
\begin{frame}[fragile]
\STitle{Assembled Single-Cycle Datapath with Components for R--, D-- and CB--format Instructions}
	\PHFigure{!}{5.05in}{1.9in}{ARMFigures/Fig0411-crop}{Figure 4.11}

\begin{itemize}
\item MUX before PC

  \hl{Selects between PC+4 OR CBZ address}
  \item Note the ``32-bit'' input to Sign-extend
\end{itemize}
\BNotes\ifnum\Notes=1
\begin{itemize}
\item The third MUX chooses what value is loaded into the PC, the
computed branch target or the incremented current PC value.
\item This diagram already takes a step towards designing control by
including a separate ALU subcontrol. We still need a main control to
generate all signals shown here from the instruction. To do that, we
need a precise set of instruction formats. 

\item Note the ``32'' input to the Sign-extend.  The actual input is either
  9 bits (LDUR) or 19 bits (Memory).  And if we implement branch ({\tt B}) then
  it could also be 26 bits.

  The book says choosing between the 9 bits of 19 bits (for sign extension)
  could be handled with a 2:1 MUX, using some of the OPCODE bits as select
  lines.  But it mistakenly suggests that all you need is a single 2:1
  bit to choose which bit to use for sign extension.  You would need at
  least 10 2:1 MUXes, one for each of the extra 10 bits in the 19-bit
  memory constant field, since you have to choose between the sign extend
  bit of the LDUR instruction or the bit of the memory instruction.

  Alternatively, the
  Sign Extend unit is just wires, and these wires for the 9-bit input go
  to a different place than the wires for the 19-bit input.
  Ie, the Sign-Extend with a
  single output is just conceptual; you'd have two or three sets of wires
  leaving the instruction, each getting sign-extended to 64 bits, and then
  sent to the appropriate input.

  When branch is added, however, you would need MUXes, since the memory
  instructions use the same ALU input as the branch instruction.
\end{itemize}
\fi\ENotes
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% rest for part 2


% \begin{frame}[fragile]
% \STitle{Instruction Formats}

% 	%\PHFigure{!}{4.in}{2.75in}{ARMFigures/Fig0414-crop}{Figure 4.14}
% 	\Figure{!}{2.5in}{1.25in}{Figs/arminstructions}

%  R-format: {\tt ADD X1, X2, X3} $\Rightarrow$ {\tt ADD {\bf Rd},Rn,Rm}\smallskip

%  I-format: {\tt ADDI X1, X2, \#4} $\Rightarrow$ {\tt ADDI {\bf Rd},Rn,\#4} \smallskip

% Load/store: {\tt LDUR X1, [X2,\#200]} $\Rightarrow$ {\tt LDUR {\bf Rt},[Rn,\#200]}\\
% \hspace*{1in}{\tt STUR X1, [X2,\#400]} $\Rightarrow$ {\tt STUR { Rt},[Rn,\#400]}\\

% \medskip
% (bold face register is \textbf{written} to)

% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item First field is operation code (opcode) but length varies

% \item Rn (bits 9:5) are the ``first'' register operand (i.e., the top
%   one on the register file).
  
% \item Note ``destination register'' field is different for {\tt ADD}
% and {\tt LDUR}; this complicates the datapath some more

% \item Draw correspondences on slide: in first type, {\tt X1} is
% 	field {\tt Dd}; in second type, it is {\tt Rt}. The rest should be
% 	obvious.
% \item Load/Store are examples of D-format instructions; {\tt CBZ} is CB-format.
% \end{itemize}
% \fi\ENotes
% \end{frame}
% \begin{frame}[fragile]
  
% \STitle{Branch Instruction Formats}

% 	%\PHFigure{!}{4.in}{2.75in}{ARMFigures/Fig0414-crop}{Figure 4.14}
% 	\Figure{!}{1.9in}{0.75in}{Figs/armbranchinstructions}

% Branch: {\tt B \#3000} $\Rightarrow$ {\tt B \#3000}\smallskip

% Conditional Branch: {\tt CBZ X1,\#3000} $\Rightarrow$ {\tt CBZ Rt,\#3000}

% \medskip

% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item Load/Store are examples of D-format instructions; {\tt CBZ} is CB-format.
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
%   \Title{Opcodes}
%   \begin{center}
%   \begin{tabular}{llc}
%     Instruction~~ & Opcode & Format\\
%     \hline
%     B    & \texttt{0001\,01} {\tiny{($5_{10}$)}} & B-format\\
%     ADD  & \texttt{1000\,1011\,000} {\tiny{($1112_{10}$)}}~~ & R-format\\
%     ADDI & \texttt{1001\,0001\,00} {\tiny{($580_{10}$)}} & I-format\\
%     CBZ  & \texttt{1011\,0100} {\tiny{($180_{10}$)}}& CB-format\\
%     CBNZ & \texttt{1011\,0101} {\tiny{($181_{10}$)}}& CB-format\\
%     SUB  & \texttt{1100\,1011\,000} {\tiny{($1624_{10}$)}} & R-format\\
%     SUBI & \texttt{1101\,0001\,00} {\tiny{($836_{10}$)}} & I-format\\
%     STUR & \texttt{1111\,1000\,000} {\tiny{($1984_{10}$)}} & D-format\\
%     LDUR & \texttt{1111\,1000\,010} {\tiny{($1986_{10}$)}} & D-format\\
%   \end{tabular}
%   \begin{itemize}
%   \item Opcodes length based on format

%     R-format: 11 bits~~~~~~~~~~~~
%     I-format: 10 bits

%     D-format: 11 bits~~~~~~~~~~~~
%     B-format: 6 bits

%     CB-format: 8 bits

%     % Figure 2.20 gives larger table
%     \end{itemize}
%   \end{center}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item Students are not expected to memorize these.

% 	However, they may need them for the assignments.

% 	If needed for an exam, the Opcodes will be provided.
% \end{itemize}
% \fi\ENotes
  
% \end{frame}

% \begin{frame}[fragile]
%   \STitle{Datapath with Control}
% \PHFigure{!}{4.5in}{2.5in}{ARMFigures/Fig0417-crop}{Figure 4.17}


% \goodbreak

% \begin{minipage}{\textwidth}
% 	\vspace*{0.5in}{\tt LDUR X1, [X1,\#200]}

% 	\PHFigure{!}{5in}{5in}{ARMFigures/Fig0417-crop}{Figure 4.17}
% \end{minipage}

% \goodbreak

% \begin{minipage}{\textwidth}
% 	\vspace*{0.5in}{\tt CBZ X1, \#100}

% 	\PHFigure{!}{5in}{5in}{ARMFigures/Fig0417-crop}{Figure 4.17}
% \end{minipage}

% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item Things to note on this slide:
% \begin{itemize}
% 	\item The instruction bits are split off and sent to the
% 		relevant hardware
% 	\item The dual control unit
% 	\item The MUX in front of Read register 2
% 	\item The branching hardware and the mux that chooses between
% 		CBZ and PC+4
% 	\item The MUX to the right of Data memory
% \end{itemize}
% \item Let's
% make sure everyone is familiar with the operation of the
% datapath. Trace the units involved in the following operations, using
% markers on the overhead slide:
% \begin{itemize}
% \item {\tt ADD X1, X2, X3}
% \item {\tt LDUR X1, [X2,\#200]}
% \item {\tt CNZ X1, \#100}
% \end{itemize}
% 	The students have three copies of this diagram in the course notes.
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
% \Title{Meaning of Signals in Single-Cycle Datapath}
% 	\begin{center}
% 	\begin{tabular}{|l|l|l|}\hline
% 	Signal & Signal=0 & Signal=1 \\ \hline
% 	Reg2Loc & 20--16 & 4--0 \\
%  \hline
% 	Branch* & no branch & Branch \\
% \hline
%  MemRead & no effect & memory read \\
% \hline	
%  MemToReg & reg write from ALU & reg write from memory \\ 
% \hline	
% ALUOp & discussion to come later\footnote{ALUOp is a two bit output from the main Control unit and is used as input to the ALU Control to set the Operation select lines.}& \\
% \hline
%  MemWrite & no effect & memory written \\
% \hline	
%  ALUSrc & ALU B input from reg & immediate from instruction \\
% \hline	
%  RegWrite & no effect & register written \\ \hline
% 	\end{tabular}
% 	\end{center}
% * Branch is ANDed with Zero from ALU to get PCsrc
 
% % (Full version in Figure 4.16 of text.)
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item Go over the various control lines, using this slide and the previous
% one, and make sure the meaning of each
% one is clear, since this table has been abbreviated to make it fit on
% the slide.
% \item Note that 20--16 and 4--0 refer to bits of the instruction that are
%   used as the second register to read from the register file.
% \end{itemize}
% \fi\ENotes
% \end{frame}

% % \begin{frame}[fragile]
% % \Title{Meaning of Signals in Single-Cycle Datapath}
% % 	\begin{center}
% % 	\begin{tabular}{|l|l|l|}\hline
% % 	Signal & Signal=0 & Signal=1 \\ \hline
% % 	Reg2Loc & 20--16 & 4--0 \\
% % 	Branch* & no branch & Branch \\
% % 	MemRead & no effect & memory read \\
% % 	MemToReg & reg write from ALU & reg write from memory \\ 
% % 	MemWrite & no effect & memory written \\
% % 	ALUSrc & ALU B input from reg & immediate from instruction \\
% % 	RegWrite & no effect & register written \\ \hline
% % 	\end{tabular}
% % 	\end{center}
% % * Branch is ANDed with Zero from ALU to get PCsrc

% % (Full version in Figure 4.16 of text.)
% % \BNotes\ifnum\Notes=1
% % \begin{itemize}
% % \item Go over the various control lines, using this slide and the previous
% % one, and make sure the meaning of each
% % one is clear, since this table has been abbreviated to make it fit on
% % the slide.
% % \item Note that 20--16 and 4--0 refer to bits of the instruction that are
% %   used as the second register to read from the register file.
% % \end{itemize}
% % \fi\ENotes
% % \end{frame}

% \begin{frame}[fragile]\ifnum\slides=0
%   {\tt ADD X1, X2, X3}
%   \else
%   \STitle{Datapath with Control}
% \fi
% \PHFigure{!}{4.5in}{2.5in}{ARMFigures/Fig0417-crop}{Figure 4.17}
% \ifnum\slides=0

% \goodbreak

% \begin{minipage}{\textwidth}
% 	\vspace*{0.5in}{\tt LDUR X1, [X1,\#200]}

% 	\PHFigure{!}{5in}{5in}{ARMFigures/Fig0417-crop}{Figure 4.17}
% \end{minipage}

% \goodbreak

% \begin{minipage}{\textwidth}
% 	\vspace*{0.5in}{\tt CBZ X1, \#100}

% 	\PHFigure{!}{5in}{5in}{ARMFigures/Fig0417-crop}{Figure 4.17}
% \end{minipage}
% \fi
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item Things to note on this slide:
% \begin{itemize}
% 	\item The instruction bits are split off and sent to the
% 		relevant hardware
% 	\item The dual control unit
% 	\item The MUX in front of Read register 2
% 	\item The branching hardware and the mux that chooses between
% 		CBZ and PC+4
% 	\item The MUX to the right of Data memory
% \end{itemize}
% \item Let's
% make sure everyone is familiar with the operation of the
% datapath. Trace the units involved in the following operations, using
% markers on the overhead slide:
% \begin{itemize}
% \item {\tt ADD X1, X2, X3}
% \item {\tt LDUR X1, [X2,\#200]}
% \item {\tt CNZ X1, \#100}
% \end{itemize}
% 	The students have three copies of this diagram in the course notes.
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]\ifnum\slides=0
%   {\tt LDUR X1, [X1,\#200]}
%   \else
%   \STitle{Datapath with Control}
% \fi
% \PHFigure{!}{4.5in}{2.5in}{ARMFigures/Fig0417-crop}{Figure 4.17}
% \ifnum\slides=0

% \goodbreak

% \begin{minipage}{\textwidth}
% 	\vspace*{0.5in}{\tt LDUR X1, [X1,\#200]}

% 	\PHFigure{!}{5in}{5in}{ARMFigures/Fig0417-crop}{Figure 4.17}
% \end{minipage}

% \goodbreak

% \begin{minipage}{\textwidth}
% 	\vspace*{0.5in}{\tt CBZ X1, \#100}

% 	\PHFigure{!}{5in}{5in}{ARMFigures/Fig0417-crop}{Figure 4.17}
% \end{minipage}
% \fi
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item Things to note on this slide:
% \begin{itemize}
% 	\item The instruction bits are split off and sent to the
% 		relevant hardware
% 	\item The dual control unit
% 	\item The MUX in front of Read register 2
% 	\item The branching hardware and the mux that chooses between
% 		CBZ and PC+4
% 	\item The MUX to the right of Data memory
% \end{itemize}
% \item Let's
% make sure everyone is familiar with the operation of the
% datapath. Trace the units involved in the following operations, using
% markers on the overhead slide:
% \begin{itemize}
% \item {\tt ADD X1, X2, X3}
% \item {\tt LDUR X1, [X2,\#200]}
% \item {\tt CBZ X1, \#100}
% \end{itemize}
% 	The students have three copies of this diagram in the course notes.
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]\ifnum\slides=0
%   {\tt CBZ X1, \#100}
%   \else
%   \STitle{Datapath with Control}
% \fi
% \PHFigure{!}{4.5in}{2.5in}{ARMFigures/Fig0417-crop}{Figure 4.17}
% \ifnum\slides=0

% \goodbreak

% \begin{minipage}{\textwidth}
% 	\vspace*{0.5in}{\tt LDUR X1, [X1,\#200]}

% 	\PHFigure{!}{5in}{5in}{ARMFigures/Fig0417-crop}{Figure 4.17}
% \end{minipage}

% \goodbreak

% \begin{minipage}{\textwidth}
% 	\vspace*{0.5in}{\tt CBZ X1, \#100}

% 	\PHFigure{!}{5in}{5in}{ARMFigures/Fig0417-crop}{Figure 4.17}
% \end{minipage}
% \fi
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item Things to note on this slide:
% \begin{itemize}
% 	\item The instruction bits are split off and sent to the
% 		relevant hardware
% 	\item The dual control unit
% 	\item The MUX in front of Read register 2
% 	\item The branching hardware and the mux that chooses between
% 		CBZ and PC+4
% 	\item The MUX to the right of Data memory
% \end{itemize}
% \item Let's
% make sure everyone is familiar with the operation of the
% datapath. Trace the units involved in the following operations, using
% markers on the overhead slide:
% \begin{itemize}
% \item {\tt ADD X1, X2, X3}
% \item {\tt LDUR X1, [X2,\#200]}
% \item {\tt CNZ X1, \#100}
% \end{itemize}
% 	The students have three copies of this diagram in the course notes.
% \end{itemize}
% \fi\ENotes
% \end{frame}

% % \begin{frame}[fragile]
% % \Title{Meaning of Signals in Single-Cycle Datapath}
% % 	\begin{center}
% % 	\begin{tabular}{|l|l|l|}\hline
% % 	Signal & Signal=0 & Signal=1 \\ \hline
% % 	Reg2Loc & 20--16 & 4--0 \\
% % 	Branch* & no branch & Branch \\
% % 	MemRead & no effect & memory read \\
% % 	MemToReg & reg write from ALU & reg write from memory \\ 
% % 	MemWrite & no effect & memory written \\
% % 	ALUSrc & ALU B input from reg & immediate from instruction \\
% % 	RegWrite & no effect & register written \\ \hline
% % 	\end{tabular}
% % 	\end{center}
% % * Branch is ANDed with Zero from ALU to get PCsrc

% % (Full version in Figure 4.16 of text.)
% % \BNotes\ifnum\Notes=1
% % \begin{itemize}
% % \item Go over the various control lines, using this slide and the previous
% % one, and make sure the meaning of each
% % one is clear, since this table has been abbreviated to make it fit on
% % the slide.
% % \item Note that 20--16 and 4--0 refer to bits of the instruction that are
% %   used as the second register to read from the register file.
% % \end{itemize}
% % \fi\ENotes
% % \end{frame}
% %%%%%%%%%%%end of a lecture 

% \begin{frame}[fragile]
% \STitle{Overview of Single-Cycle Control}
% \includegraphics[scale=0.4]{04-Single-Cycle-Processor-Implementation/figures/scp-control-output-opcode.png}
% % \Figure{!}{1in}{1.7in}{/figures/sc-control-output-opcode}
% \begin{itemize}
% \item Could be done in one level
% \item Multiple levels of control are conceptually simpler
% \item Smaller control units may also be faster
% \end{itemize}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item
% Note that each of the ovals is a combinational circuit implementing
% some Boolean function. The task is to specify the function and figure
% out how to compute it.
% \item
% The main control takes as input the
% opcode and produces the ALUop bits (among others); the ALU control
% takes as input the ALUop bits and the function field and produces the
% ALU control input. 
% updated image so that input to ALU Control is not Funct (from MIPS) but instead Opcode from ARM
% Note the "11 (3)".  While the authors pass the full 11 opcode bits to the ALUControl, you really only need 3-bits here as we'll see shortly.
% \item
% The main text of the book presents the tables but does not go into
% detail on the implementation; that is done in section C.2, which the
% students should read.
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
% \Title{Designing Single-Cycle ALU Control}
% Mapping of ALU Control input to output. 

% \begin{itemize}
%     \item Inputs to ALU Control: Opcode and 2 bit ALUop from Main Control
%     \item Output from ALU Control: 4 bit ALU operation, same as ALU Operation for 1-bit ALU {\tiny{(designed earlier) }}
% \end{itemize}
% 	\begin{center}
% 	\begin{tabular}{|c|c|c|c|c|}\hline
% 	Instruction & ALUop & Opcode &  ALU
%                        & ALU \\
% 	  &  &  &  action & Control output\\\hline
% 	 {\tt LDUR} & 00 & xxxxxx xxxxx & add & 0010 \\
% 	 {\tt STUR} & 00 & xxxxxx xxxxx & add & 0010 \\
% 	 {\tt CBZ} & 01 & xxxxxx xxxxx & pass b & 0011 \\
% \hline
% 	 {\tt ADD} & 10 & 100010 11000 & add & 0010 \\
% 	 {\tt SUB} & 10 & 110010 11000 & subtract & 0110 \\
% 	 {\tt AND} & 10 & 100010 10000 & AND & 0000 \\
% 	 {\tt ORR} & 10 & 101010 10000 & OR & 0001 \\\hline
% 	\end{tabular}
% 	\end{center}

% Last four instructions use Opcode bits to determine ALU action
% {\footnotesize
% 	\begin{center}
% 		\SizeD
% 		\begin{tabular}{cl}
% 			ALUOp & Operation\\
% 			\hline
% 			00 & Add\\
% 			01 & pass b\\
% 			10 & R-format\\
% 			% {\color{red}11} & {\color{red}Subtract}
% 		\end{tabular}
% 	\end{center}}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item

% 	The ALU table is on page 272 of the text.

% 	The ALU in the book implements NOR; we don't need NOR for the
% 	subset of ARM instructions that we've implemented, so the
% 	left most bit of the ALU ctrl input is always 0.

% \item The opcode and function field settings are specified by the
% 	instruction set designer; the ALU control input settings were
% 	specified in the design we did earlier. We choose the ALUop
% 	intermediate code now.

% \item The ALUOp table was created to achieve the effects that we want.

% 	The ALUOp is a signal from the Main Control unit to the ALU Control unit,
% 		telling the ALU Control unit how to generate it's signal to
% 		the ALU.  Add, pass b, and subtract are clear; the R-format
% 		requires the ALU Control unit to look at the opcode and figure
% 		out what signal to send to the ALU.

% 	Subtract isn't used in the basic single cycle computer or in the textbook, but we'll assume that it's
% 		available for this class.  You need it for \texttt{SUBI} for example,
% 		although adding \texttt{SUBI} would require changing the control unit that we design
% 		here.
% \end{itemize}
% \fi\ENotes
% \end{frame}


% \begin{frame}{Observe the Opcodes}
%      \begin{center}
%   \begin{tabular}{llc}
%     Instruction~~ & Opcode & Format\\
%     \hline
%     % B    & \texttt{0001\,01} {\tiny{($5_{10}$)}} & B-format\\
%     LDUR & \texttt{1111\,1000\,010} {\tiny{($1986_{10}$)}} & D-format\\
%      STUR & \texttt{1111\,1000\,000} {\tiny{($1984_{10}$)}} & D-format\\
%       CBZ  & \texttt{1011\,0100} {\tiny{($180_{10}$)}}& CB-format\\
%     % CBNZ & \texttt{1011\,0101} {\tiny{($181_{10}$)}}& CB-format\\
%     \hline
%     ADD  & \texttt{1000\,1011\,000} {\tiny{($1112_{10}$)}}~~ & R-format\\
%     % ADDI & \texttt{1001\,0001\,00} {\tiny{($580_{10}$)}} & I-format\\
%     SUB  & \texttt{1100\,1011\,000} {\tiny{($1624_{10}$)}} & R-format\\
%     % SUBI & \texttt{1101\,0001\,00} {\tiny{($836_{10}$)}} & I-format\\
%    {\tt AND} & \texttt{1000\,1010\,000} & R-Format\\
% 	 {\tt ORR} & \texttt{1010\,1010\,000} & R-Format\\\hline
  
%   \end{tabular}
%   \end{center}
% \end{frame}

% \begin{frame}[fragile]
%   \Title{Designing ALU Control}
% 	\begin{center}
%  \resizebox{\textwidth}{!}{
% 	\begin{tabular}{|c|cc|ccccccccccc|c||cccc|}\hline
% 	Instruction & \multicolumn{2}{|c|}{\bf ALUop} & \multicolumn{11}{|c|}{\bf Opcode} &  ALU
%                           & \multicolumn{4}{|c|}{Operation} \\
% 	  & 1&0 & x&{\SizeD 30}& {\SizeD 29}&x&x&x& ~x&{\SizeD 24}&x&x&x &  action & 3&2&1&0 \\\hline
% 	 {\tt LDUR} & 0&0 & x&x&x&x&x&x& ~x&x&x&x&x & add & 0&0&1&0 \\
% 	 {\tt STUR} & 0&0 & x&x&x&x&x&x& ~x&x&x&x&x & add & 0&0&1&0 \\
% 	 {\tt CBZ} & 0&1 & x&x&x&x&x&x& ~x&x&x&x&x & pass b & 0&0&1&1 \\
% \hline
% 	 {\tt ADD} & 1&0 & c&0&0&c&c&c& ~c&1&c&c&c & add & 0&0&1&0 \\
% 	 {\tt SUB} & 1&0 & c&1&0&c&c&c& ~c&1&c&c&c & subtract & 0&1&1&0 \\
% 	 {\tt AND} & 1&0 & c&0&0&c&c&c& ~c&0&c&c&c & AND & 0&0&0&0 \\
% 	 {\tt ORR} & 1&0 & c&0&1&c&c&c& ~c&0&c&c&c & OR & 0&0&0&1 \\\hline
% 	\end{tabular}}
% 	\end{center}
% \begin{itemize}
% \item  Remove non-varying Opcode bit positions (c in table) for ALUop1=1
% \item Split ALU control output ALU Operation into Operation3,Operation2, Operation1, Operation0.

% 	(Operation3=0 for our subset of ARM)
% \end{itemize}

% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item This is NOT in the text!

% 	\item Mention where Don't Cares come from (ie, ALUop=11 isn't used;
% 		many opcode bits are redudent information).
% 	      \item Show how to do full sum-of-products for Operation0.
%               \item For complete language, table is bigger and minimized by
%                 machine.  For this example, we can do it by hand
% 	\begin{itemize}
% 		\item Operation0 = ALUop0 + ALUop1 Opcode29
% 		\item Operation1 = $\Bar{\mbox{ALUop1}}+$ALUop1 Opcode24
% 		\item Operation2 = ALUop1 Opcode30
% 	\end{itemize}
% 		Note that we can't use the Don't Cares for ALUop=00,01;
% 		ie, we need to ALUop1 ANDed with the Opcode bits in
% 		these formulas because the Opcodes for LDUR,STUR,CBZ might
% 		be 1.
% \end{itemize}
% \fi\ENotes
% \end{frame}


% %-----------------------------------------------------
% % \begin{frame}[fragile]\frametitle{ALU Control Boolean Equations (Part 1)}
% % We can write the Boolean equations for the ALU Operation output bits, which are denoted by: Op3, Op2, Op1, Op0.

% % \begin{center}
% % \begin{tabular}{c|cc|ccc|c}
% % Instruction   &  \multicolumn{5}{|c|}{Input} & \multicolumn{1}{|c}{Output}\\\hline
% %               & \multicolumn{2}{|c|}{ALUOp} &  \multicolumn{3}{|c|}{Opcode} & \makecell{ALU \\ Operation}\\
% %  & 1 & 0 & 30 & 29 & 24 & \\\hline
% % load or store & 0 & 0 &  X & X & X & \texttt{0010}\\
% % CBZ           & 0 & 1 &  X & X & X & \texttt{0011}\\
% % R-format (ADD)& 1 & 0 &  0 & 0 & 1 & \texttt{0010}\\
% % R-format (SUB)& 1 & 0 &  1 & 0 & 1 & \texttt{0110}\\
% % R-format (AND)& 1 & 0 &  0 & 0 & 0 & \texttt{0000}\\
% % R-format (ORR)& 1 & 0 &  0 & 1 & 0 & \texttt{0001}\\
% % \end{tabular}
% % \end{center}
% % The formulas are found ``by inspection", see what input bits need to be 1 for the output bit to be 1. Software is also available to do this.

% % \end{frame}

% %-----------------------------------------------------
% % \begin{frame}[fragile]\frametitle{ALU Control Boolean Equations (\texttt{Op3})}
% % $Op3$ is always 0.
% % $$Op3=0\;.$$
% % \begin{center}
% % \begin{tabular}{c|cc|ccc|c}
% % Instruction   &  \multicolumn{5}{|c|}{Input} & \multicolumn{1}{|c}{Output}\\\hline
% %               & \multicolumn{2}{|c|}{ALUOp} &  \multicolumn{3}{|c|}{Opcode} & Op[3]\\
% %  & 1 & 0 & 30 & 29 & 24 & \\\hline
% % load or store & 0 & 0 &  X & X & X & \texttt{0}\\
% % CBZ           & 0 & 1 &  X & X & X & \texttt{0}\\
% % R-format (ADD)& 1 & 0 &  0 & 0 & 1 & \texttt{0}\\
% % R-format (SUB)& 1 & 0 &  1 & 0 & 1 & \texttt{0}\\
% % R-format (AND)& 1 & 0 &  0 & 0 & 0 & \texttt{0}\\
% % R-format (ORR)& 1 & 0 &  0 & 1 & 0 & \texttt{0}\\
% % \end{tabular}
% % \end{center}


% % \end{frame}
% %-----------------------------------------------------
% \begin{frame}[fragile]\frametitle{ALU Control Boolean Equations for ALU Control Output - \texttt{Operation2}}
% % Look at where $Operation2=1$, there is just one row. We need $ALUOp1=Opcode30=1$. Row 3 shows that $Operation2=1$ does not require $Opcode24=1$.

% $$Operation2=ALUOp1 \cdot Opcode30$$
% \begin{center}
% \begin{tabular}{c|c|cc|ccc|c}
% Row&Instruction   &  \multicolumn{5}{|c|}{Input} & \multicolumn{1}{|c}{Output}\\\hline
%   &            & \multicolumn{2}{|c|}{ALUOp} &  \multicolumn{3}{|c|}{Opcode} & Operation2\\
% & & 1 & 0 & 30 & 29 & 24 & \\\hline
% 1 &load or store & 0 & 0 &  X & X & X & \texttt{0}\\
% 2&CBZ           & 0 & 1 &  X & X & X & \texttt{0}\\
% 3&R-format (ADD)& 1 & 0 &  0 & 0 & 1 & \texttt{0}\footnote{Row 3 shows that $Operation2=1$ does not require $Opcode24=1$.}\\
% 4&R-format (SUB)& 1 & 0 &  1 & 0 & 1 & \texttt{1}\\
% 5&R-format (AND)& 1 & 0 &  0 & 0 & 0 & \texttt{0}\\
% 6&R-format (ORR)& 1 & 0 &  0 & 1 & 0 & \texttt{0}\\
% \end{tabular}
% \end{center}

% \end{frame}
% %-----------------------------------------------------
% \begin{frame}[fragile]\frametitle{ALU Control Boolean Equations for ALU Control Output - \texttt{Operation1}}
% % Look at where $Op[1]=1$. Row 1 and row 2 shows we need $ALUOp[1]=0$. Row 3 and 4 shows we need $Opcode[24]=1$, $ALUOp[1]=1$ is not needed since in row 4 and 5, this bit does not ensure  Op[1]=1.
% $$Operation1= \overline{ALUOp1} + ALUOp1 \cdot Opcode24$$
% \begin{center}
% {\small
% \begin{tabular}{c|c|cc|ccc|c}
% Row&Instruction   &  \multicolumn{5}{|c|}{Input} & \multicolumn{1}{|c}{Output}\\\hline
%      &         & \multicolumn{2}{|c|}{ALUOp} &  \multicolumn{3}{|c|}{Opcode} & Operation1\\
% & & 1 & 0 & 30 & 29 & 24 & \\\hline
% 1&load or store & 0 & 0 &  X & X & X & \texttt{1}\\
% 2&CBZ           & 0 & 1 &  X & X & X & \texttt{1}\\
% 3&R-format (ADD)& 1 & 0 &  0 & 0 & 1 & \texttt{1}\\
% 4&R-format (SUB)& 1 & 0 &  1 & 0 & 1 & \texttt{1}\\
% 5&R-format (AND)& 1 & 0 &  0 & 0 & 0 & \texttt{0}\\
% 6&R-format (ORR)& 1 & 0 &  0 & 1 & 0 & \texttt{0}\\
% \end{tabular}
% }
% \end{center}
% \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
%   colback=blue!5!white,colframe=blue!75!black,colbacktitle=blue!80!black,
%   title=Think About It,fonttitle=\bfseries,
%   boxed title style={size=small,colframe=red!50!black} ]
%   Can we simplify $Operation1= \overline{ALUOp1} + Opcode24$? 
%   \end{tcolorbox}

% \end{frame}
% %-----------------------------------------------------

% %-----------------------------------------------------
% \begin{frame}[fragile]\frametitle{ALU Control Boolean Equations for ALU Control Output - \texttt{Operation1} - Solution}
% No we will not simplify since ALU Control, only refers to instruction opcode when ALUOp is 10, therefore, ALU Control does not look at opcode bits for other instructions such as LDUR, STUR, CBZ and CBNZ.And using don't cares may lead to incorrect conclusions:
% % No we cannot simplify to $Operation1 = \overline{ALUOp1} + Opcode24$. Since based on the truth table with the opcode bits for instructions LDUR, STUR, CBZ, CBNZ, we notice that 
% % $Opcode24 = 1$ for CBNZ instruction, therefore, $Operation1 = \overline{ALUOp1} + Opcode24 = 1$,when $ALUOp1=0$ and $Opcode24=1$ for CBNZ instruction. 
% \begin{center}
% \begin{tabular}{c|c|cc|ccc|c}
% Row&Instruction   &  \multicolumn{5}{|c|}{Input} & \multicolumn{1}{|c}{Output}\\\hline
%      &         & \multicolumn{2}{|c|}{ALUOp} &  \multicolumn{3}{|c|}{Opcode} & Operation1\\
% & & 1 & 0 & 30 & 29 & 24 & \\\hline
% 1&load or store & 0 & 0 &  {\color{red}1} & {\color{red}1} & {\color{red}0} & \texttt{1}\\
% 2&CBZ/CBNZ           & 0 & 1 &  {\color{red}0} & {\color{red}1} & {\color{red}0/1\footnote{for CBNZ Opcode24 is 1}} & \texttt{1}\\
% 3&R-format (ADD)& 1 & 0 &  0 & 0 & 1 & \texttt{1}\\
% 4&R-format (SUB)& 1 & 0 &  1 & 0 & 1 & \texttt{1}\\
% 5&R-format (AND)& 1 & 0 &  0 & 0 & 0 & \texttt{0}\\
% 6&R-format (ORR)& 1 & 0 &  0 & 1 & 0 & \texttt{0}\\
% \end{tabular}
% \end{center}


% \end{frame}
% %-----------------------------------------------------



% \begin{frame}[fragile]\frametitle{ALU Control Boolean Equations for ALU Control Output - \texttt{Operation0}}
% % Look at the rows were $Operation0=1$ and see which inputs needs to be 1. In row 2, we need $ALUOp[0]=1$, in row 6 $ALUOp[1]$ and $Opcode[29]$ needs to be 1.
% $$Operation0=ALUOp0 + ALUOp1 \cdot Opcode29$$
% \begin{center}
% \begin{tabular}{c|cc|ccc|c}
% Instruction   &  \multicolumn{5}{|c|}{Input} & \multicolumn{1}{|c}{Output}\\\hline
%               & \multicolumn{2}{|c|}{ALUOp} &  \multicolumn{3}{|c|}{Opcode} & Operation0\\
%  & 1 & 0 & 30 & 29 & 24 & \\\hline
% load or store & 0 & 0 &  X & X & X & \texttt{0}\\
% CBZ           & 0 & 1 &  X & X & X & \texttt{1}\\
% R-format (ADD)& 1 & 0 &  0 & 0 & 1 & \texttt{0}\\
% R-format (SUB)& 1 & 0 &  1 & 0 & 1 & \texttt{0}\\
% R-format (AND)& 1 & 0 &  0 & 0 & 0 & \texttt{0}\\
% R-format (ORR)& 1 & 0 &  0 & 1 & 0 & \texttt{1}\\
% \end{tabular}
% \end{center}

% \end{frame}
% %-----------------------------------------------------
% \begin{frame}[fragile]\frametitle{ALU Control Circuit}

%  \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
%   colback=red!5!white,colframe=red!75!black,colbacktitle=red!80!black,
%   title=Try this,fonttitle=\bfseries,
%   boxed title style={size=small,colframe=red!50!black} ]
% Given the following three Boolean equations for the output from the ALU Control:
% % Operation3&=0 \\
% \begin{align*}
% Operation2&=ALUOp1 \cdot Opcode30 \\
% Operation1&= \overline{ALUOp1} + ALUOp1 \cdot Opcode24\\
% Operation0&=ALUOp0 + ALUOp1 \cdot Opcode29 \\
% \end{align*}
% Can you implement the circuits?
%   \end{tcolorbox}

% \end{frame} 

% %-----------------------------------------------------

% %-----------------------------------------------------
% \begin{frame}{Solution - ALU Control Circuit}

% A sample solution\footnote{Image by Sherlock Yang}:
% \includegraphics[height=2.8in]{04-Single-Cycle-Processor-Implementation/figures/alu-control-circuit.png}


% \end{frame}


% \begin{frame}[fragile]
% \STitle{Overview of Single-Cycle Control}
% \includegraphics[scale=0.4]{04-Single-Cycle-Processor-Implementation/figures/scp-control-output-opcode.png}
% % \Figure{!}{1in}{1.7in}{/figures/sc-control-output-opcode}
% \begin{itemize}
% \item Objective to build main Control Unit for Single Cycle Processor
% \end{itemize}
% \end{frame}

% \begin{frame}{Trace the Main Control for Instructions}
%     \PHFigure{!}{1.5in}{1.5in}{ARMFigures/Fig0417-crop}{Figure 4.17}
% \begin{center}
% {\small
% \resizebox{\textwidth}{!}{
% 	\begin{tabular}{c|c|c|c|c|c|c|c|c|c}
%  \textbf{Input} & \multicolumn{9}{c}{\textbf{Output}}\\
%  \hline\hline
% 	Instruction & Reg2 & ALU & Mem & Reg & Mem &
% 	Mem & Brch & ALU & ALU \\ 
% 	Type/Name     & Loc & Src & ToReg & Write & Read &
% 	Write &      & op1       & op0   \\ 
% \hline\hline
% 	R-format   & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 \\ \hline
% 	{\tt LDUR} & X & 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 \\ \hline
% 	{\tt STUR} & 1 & 1 & X & 0 & 0 & 1 & 0 & 0 & 0 \\ \hline
% 	{\tt CBZ}  & 1 & 0 & X & 0 & 0 & 0 & 1 & 0 & 1 \\ 
% 	\end{tabular}}}
%         \end{center}
    
% \end{frame}


% \begin{frame}[fragile]
% \STitle{Implementing Main Control Output Functions}
% \begin{center}
% \resizebox{\textwidth}{!}{
% 	\begin{tabular}{c|c|c|c|c|c|c|c|c|c}
%  \textbf{Input} & \multicolumn{9}{c}{\textbf{Output}}\\
%  \hline\hline
% 	Instruction & Reg2 & ALU & Mem & Reg & Mem &
% 	Mem & Brch & ALU & ALU \\ 
% 	Type/Name     & Loc & Src & ToReg & Write & Read &
% 	Write &      & op1       & op0   \\ 
% \hline\hline
% 	R-format   & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 \\ \hline
% 	{\tt LDUR} & X & 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 \\ \hline
% 	{\tt STUR} & 1 & 1 & X & 0 & 0 & 1 & 0 & 0 & 0 \\ \hline
% 	{\tt CBZ}  & 1 & 0 & X & 0 & 0 & 0 & 1 & 0 & 1 \\ 
% 	\end{tabular}}
%         \smallskip
%       	\end{center}  
% MemRead is never don’t care.
% \begin{itemize}
% \item  If the address is not a multiple of 8, then your computer generates a bus error and your program crashes.
% \item Even if it is a multiple of 8, an inadvertant read could cause cache issues.
% \end{itemize}


% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item It should be clear why these signals are the way they are, by
% looking at the diagram of the datapath. Go over each of them using
% that diagram.

% \item Consider drawing table on the board, and have datapath on slide
% and show how to fill in table.  It will also be helpful to have the
% table on the board when you go to the next slide.

% \item The comment about MemRead never don't care: if the address isn't a multiple of 4, then your computer generates a bus error and your program crashes.  Even if it's a multiple of 4, an inadvertant read could cause cache issues.
  
% \item The ``Type'' column in the top table is the input; the remaining
%   columns are outputs; to fully specify the truth table, we need the
%   opcodes for the types, and thus the bottom table.
  
% \item In the bottom table, middle column, CBZ has don't cares because
%   it only has a 6-bit opcode. R-format has don't cares to give ADD,
%   SUB, AND, ORR a ``single opcode''; this row could instead be
%   expanded into four rows, one for each.
  
% \item In the bottom table, right column, we have removed columns that
%   don't vary.  This will allow us to make the circuit on the next slide,
% \end{itemize}
% \fi\ENotes
% \end{frame}


% % \begin{frame}{Recall, Observe the Opcodes}
% %      \begin{center}
% %      {\small
% %   \begin{tabular}{llc}
% %     Instruction~~ & Opcode & Format\\
% %     \hline
% %      ADD  & \texttt{1000\,1011\,000} {\tiny{($1112_{10}$)}}~~ & R-format\\
    
% %     SUB  & \texttt{1100\,1011\,000} {\tiny{($1624_{10}$)}} & R-format\\
   
% %    {\tt AND} & \texttt{1000\,1010\,000} & R-Format\\
% % 	 {\tt ORR} & \texttt{1010\,1010\,000} & R-Format\\
% %   \hline
% %     LDUR & \texttt{1111\,1000\,010} {\tiny{($1986_{10}$)}} & D-format\\
% %      STUR & \texttt{1111\,1000\,000} {\tiny{($1984_{10}$)}} & D-format\\
% %       CBZ  & \texttt{1011\,0100} {\tiny{($180_{10}$)}}& CB-format\\
% %     \hline
% %   \end{tabular}}
% %   \end{center}
% %   \smallskip
  
% %     \definecolor{gray}{rgb}{0.6,0.6,0.6}
% %     %     \newcommand\gry[1]{{\color{gray}#1}}
% %         \begin{center}
% %               \begin{tabular}{ccc}
% % 	Type & Binary Opcode & Simplified Opcode\\
% % \hline
% % % 	R-format &   1xx\,0101\,x000 & \gry{x}x\gry{x}\,0101\,\gry{x}\gry{x}0\gry{x}\\
% % % 	{\tt LDUR} & 111\,1100\,0010 & \gry{x}1\gry{x}\,1100\,\gry{x}\gry{x}1\gry{x}\\
% % % 	{\tt STUR} & 111\,1100\,0000 & \gry{x}1\gry{x}\,1100\,\gry{x}\gry{x}0\gry{x}\\
% % % 	{\tt CBZ}&   101\,1010\,0xxx & \gry{x}0\gry{x}\,1010\,\gry{x}\gry{x}x\gry{x}
% % \end{tabular}
% % 	\end{center}
% % \smallskip

% % Simplified opcode bits: 30,28,27,26,25,22

% % \bigskip
% % Software can generate simplified circuit.
% % \end{frame}



% \begin{frame}[fragile]
% \STitle{Recall, the Opcodes}
% \begin{center}
%  \begin{center}
%      {\small
%   \begin{tabular}{llc}
%     Instruction~~ & Opcode & Format\\
%     \hline
%      ADD  & \texttt{1000\,1011\,000} {\tiny{($1112_{10}$)}}~~ & R-format\\
    
%     SUB  & \texttt{1100\,1011\,000} {\tiny{($1624_{10}$)}} & R-format\\
   
%   AND& \texttt{1000\,1010\,000} & R-Format\\
% 	 ORR & \texttt{1010\,1010\,000} & R-Format\\
%   \hline
%     LDUR & \texttt{1111\,1000\,010} {\tiny{($1986_{10}$)}} & D-format\\
%      STUR & \texttt{1111\,1000\,000} {\tiny{($1984_{10}$)}} & D-format\\
%       CBZ  & \texttt{1011\,0100} {\tiny{($180_{10}$)}}& CB-format\\
%     \hline
%   \end{tabular}}
%   \end{center}

%   \bigskip
%         \definecolor{gray}{rgb}{0.6,0.6,0.6}
%         \newcommand\gry[1]{{\color{gray}#1}}
%         \bigskip
% \begin{tabular}{ccc}
% 	Type & Binary Opcode & Simplified Opcode\\
% \hline
% 	R-format &   1xx0\,101x\,000 & \gry{x}x\gry{x}\,0101\,\gry{x}\gry{x}0\gry{x}\\
% 	{\tt LDUR} & 1111\,1000\,010 & \gry{x}1\gry{x}\,1100\,\gry{x}\gry{x}1\gry{x}\\
% 	{\tt STUR} & 1111\,1000\,000 & \gry{x}1\gry{x}\,1100\,\gry{x}\gry{x}0\gry{x}\\
% 	{\tt CBZ}&   1011\,0100\,xxx & \gry{x}0\gry{x}\,1010\,\gry{x}\gry{x}x\gry{x}
% \end{tabular}
% 	\end{center}
% \smallskip

% Simplified opcode bits: 30,28,27,26,25,22

% \bigskip
% Software generates simplified circuit

% \end{frame}

% % \begin{frame}{test}

% %      \resizebox{\textwidth}{!}{
     
% % 	\begin{tabular}{|c|ccccccccccc|}\\
% %  \hline
% % 	Instruction & \multicolumn{11}{|c|}{\bf Binary Opcode} \\
% % 	  &{\SizeD 30}& {\SizeD 29}&{\SizeD 28}&{\SizeD 27}&{\SizeD 26}&{\SizeD 25}&{\SizeD 24}&{\SizeD 23}&{\SizeD 22}&{\SizeD 21}  \\
% %    \hline
% % \end{tabular}
% % }
   
% % \end{frame}


% % \begin{frame}\frametitle{Main Control Simplified Inputs}
% % The inputs can be further simplified:
% % \begin{center}
% % \begin{tabular}{c|c|c}
% % Instruction &  Input       & Simplified Input\\\hline
% %            & 11 bit Opcode & 6 bit Opcode \\ \hline
% % R-format   & \texttt{1XX 0101 X000} & \texttt{\_X\_ 0101 \_\_0\_} \\\hline
% % load word  & \texttt{111 1100 0010} & \texttt{\_1\_ 1100 \_\_1\_} \\\hline
% % store word & \texttt{111 1100 0000} & \texttt{\_1\_ 1100 \_\_0\_} \\\hline
% % CBZ        & \texttt{101 1010 0XXX} & \texttt{\_0\_ 1010 \_\_X\_} \\\hline
% % \end{tabular}
% % \end{center}
% % MemRead is never don’t care.
% % \begin{itemize}
% % \item  If the address is not a multiple of 4, then your computer generates a bus error and your program crashes.
% % \item Even if it is a multiple of 4, an inadvertant read could cause cache issues.
% % \end{itemize}

% % \end{frame}

% %-----------------------------------------------------
% \begin{frame}\frametitle{Main Control Simplified Truth Table}
% The simplified inputs are the opcode bits at index  30, 28, 27, 26, 25, 22.
% \hfill\break
% The outputs are the control bits:
% \begin{itemize}
% \item Reg2Loc,ALUSrc,MemtoReg,RegWrite,MemRead,MemWrite,Branch
% \item ALUOp1, ALUOp0
% \end{itemize}
% \begin{center}
% \begin{tabular}{c|c|c|c}
% Instruction &  Input & \multicolumn{1}{|c}{Output} \\\hline
%            & 6 bit Opcode & Control Lines & ALUOp\\\hline
% R-format   & \texttt{X01010} & \texttt{0001000} & \texttt{10} \\\hline
% load word  & \texttt{111001} & \texttt{X111100} & \texttt{00} \\\hline
% store word & \texttt{111000} & \texttt{11X0010} & \texttt{00} \\\hline
% CBZ        & \texttt{01010X} & \texttt{10X0001} & \texttt{01} \\\hline
% \end{tabular}
% \end{center}
% \end{frame}

% %-----------------------------------------------------
% \begin{frame}\frametitle{Main Control Circuit}

% The 6 opcode bits are ANDed together, one AND gate for each instruction format. ``Don't Care" terms are \emph{not} ANDed.

% \begin{figure}[H]
% \centering
% 	{\includegraphics[scale=0.4]{04-Single-Cycle-Processor-Implementation/figures/main-control-in-and-bits}}
% \end{figure}
% \end{frame}

% %-----------------------------------------------------
% % \begin{frame}\frametitle{Main Control Circuit}

% % The AND gate outputs, where the control bit is 1, are ORed together to give the output control bit.


% % \begin{figure}[H]
% % \centering
% % 	{\includegraphics[scale=0.3]{figures/main-control-circuit-out}}
% % \end{figure}
% % \end{frame}


% \iftrue
% \begin{frame}[fragile]
% \STitle{Two Level Main Control Circuit}
% The AND gate outputs, where the control bit is 1, are ORed together to give the output control bit.
% \Figure{!}{6.5in}{2.5in}{ARMFigures/mainControl}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
%   \item Not in text
% \item Normally use circuit simplification, but straightforward to make
%   two level circuit for this control unit
% \end{itemize}
% \fi\ENotes
% \end{frame}
% \fi

% \begin{frame}[fragile]
% \STitle{Performance of Single Cycle Machines}
% \begin{itemize}
% \item Suppose memory units take 200 ps (picoseconds), ALUs 200 ps,
% register files 100 ps, no delay on other units
% \item Branch take 400 ps, CBZ take 500 ps, R-format instructions 600 ps,
% STUR 700 ps, LDUR 800 ps.
% \item Clock period must be increased to 800 ps or more
% \item Even worse when floating-point instructions are implemented
% \item Idea: use multicycle implementation
% and R format
% \end{itemize}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item Ask the students why the different types of instructions take the
%   times listed, or work it out on the board.
% \item See Figure 4.25 of the text.  The figure doesn't list branch, but
%   it's the same entry as CBZ except it doesn't use the register file.
%   \end{itemize}
% \fi\ENotes
% \end{frame}

% \input 04-Single-Cycle-Processor-Implementation/single-cycle-timing-f22

% \begin{frame}[fragile]
% \STitle{Modifying the datapath}
% \begin{itemize}
% 	\item Normally design complete datapath for all instructions together.
% 	\item Various ways to modify datapath.  The following is one
% 		approach for adding a new assembly instruction:
% 	\begin{enumerate}
% 	\item Determine what datapath is needed for new command
% 	\item Check if any components in current datapath can be used
% 	\item Wire in components of new datapath into existing datapath

% 		Probably requires MUXes
% 	\item Add new control signals to Control units
% 	\item Adjust old control signals to account for new command
% 	\end{enumerate}
% \end{itemize}
% \BNotes\ifnum\Notes=1
% The book shows how to modify the data path to execute the JUMP instruction.
% Students should read this in the textbook; on the next slide, we will add
% {\tt jrel} to the data path.
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
%   \STitle{Adding the \texttt{Branch} command}
% \includegraphics[scale=0.4]{04-Single-Cycle-Processor-Implementation/figures/add-uncond-branch-redbox}
% {\small
% \begin{itemize}
%     \item Add the ``unconditional branch signal'', \texttt{Uncondbranch}.
%     % OR with the original branch signal from the output of the AND gate.
% \item Modify the Sign-extend unit since the branch instruction has a different format.
% % We also need to modify the Sign-extend unit since the branch instruction has a different format. This is achieved by allowing the sign-extend controller to use the opcode from the instruction to sign-extend accordingly.
% \end{itemize}}
% % \PHFigure{!}{6.5in}{2.75in}{ARM04-Single-Cycle-Processor-Implementation/figures/Fig0417-crop}{Figure 4.17}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item The textbook does this example; see page 282.

%   Basically, you add a new control signal (Unconditionalbranch),
%   and OR it with the PCsrc line (labeled in Figure 4.16 but not in Figure 4.17; basically, it's the control on the MUX whose output goes to the PC).
%   That can be drawn on the slide.

%   However, what can't be drawn is that the Sign Extend unit needs to be
%   modified to handle the 26-bit offset of branch.

%   Also, the modified datapath appears on the next slide, for adding jrel
  
% \item You should also go over how the main control table will change
%   (a new line for branch, with Reg2Loc=X, ALUSrc=1, MemToReg=X, RegWrite=MemRead=MemWrite=Branch=0, ALUop1=0, ALUop2=0.
  
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}{Control Outputs for Unconditional Branch instruction}
% \begin{itemize}
%     \item Turn off register file: RegWrite=0. 
%     \item Avoid any cache issue due to memory read (never a don't care): MemRead=0, MemWrite=0.
%     \item Branch=0 to be safe, can be don't care.
%     \item We are not writing the the register file so Reg2Loc=X, 
%     \item MemToReg=X. ALUSrc=X. ALUOp=XX.
% \end{itemize}
    
% \end{frame}



% % \begin{frame}[fragile]
% % \begin{itemize}
% % 	\item Add {\tt BREL Rn} as an I-format command that performs

% % 	                PC $\leftarrow$ PC + 4*Rn

% % \PHFigure{!}{5in}{2.5in}{ARM04-Single-Cycle-Processor-Implementation/figures/Fig0423-crop}{Figure 4.23}

% % \end{itemize}
% % \BNotes\ifnum\Notes=1
% % \begin{itemize}
% % 	\item Do an example such as a I-format {\tt BREL Rn} which performs

% % 		PC $\leftarrow$ PC +  4*Rn

% % 		Assume that the specified register is Rn.

% % 	\item Draw a datapath for with hardware to perform just this operation.

% % 		Use an adders and do the *4 with a shift in wires
% % 	\item Observe that the adder and the shift unit are already
% % 		appropriately wired in the datapath - you just need to
% % 		provide a new input to the shift unit.

% % 	\item You will need a new MUX to select the input to the shift
% % 		unit.  You will need a new control line from the Control
% % 		unit to select this MUX.
% % 	\item Finally, give the control signal table for the new command.
% % \end{itemize}
% % \fi\ENotes
% % \end{frame}

% \begin{frame}[fragile]\frametitle{Add Branch Relative (BREL) Instruction}

% \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
%   colback=red!5!white,colframe=red!75!black,colbacktitle=red!80!black,
%   title=Try this,fonttitle=\bfseries,
%   boxed title style={size=small,colframe=red!50!black} ]
% Add another command, ``Branch relative" (BREL) to the updated datapath.
% \hfill\break

% This instruction is I-format, it branches based on a register:
% \begin{verbatim}
% BREL Rn
% \end{verbatim}
% Sets PC to \texttt{PC+4*Rn}. \texttt{Rn} is in bits 9-5.
% \begin{figure}[H]
% \centering
% 	{\includegraphics[scale=0.3]{04-Single-Cycle-Processor-Implementation/figures/I-format}}
% \end{figure}
% \end{tcolorbox}
% % ** Try this yourself. The process is explained in the following slides.
% \end{frame}

% %-----------------------------------------------------
% \begin{frame}\frametitle{Add Branch Relative (BREL) Instruction}
% Add a control bit BREL. For the ``Shift left 2" unit's input, add a mux to choose between Read data 1 and Sign-extend. BREL is the select signal for this mux. If BREL=1, register Rn is given to ``Shift left 2". 
% \begin{figure}[H]
% \centering
% 	{\includegraphics[scale=0.4]{04-Single-Cycle-Processor-Implementation/figures/brel-idea-redbox}}
% \end{figure}
% \end{frame}
% %-----------------------------------------------------
% \begin{frame}\frametitle{Add Branch Relative (BREL) Instruction}
% The BREL signal also goes into the OR gated added previously.
% \begin{figure}[H]
% \centering
% 	{\includegraphics[scale=0.4]{04-Single-Cycle-Processor-Implementation/figures/brel-idea-redbox}}
% \end{figure}
% \end{frame}
% %-----------------------------------------------------
% \begin{frame}\frametitle{Control Signals For BREL Instruction}
% \begin{itemize}
% \item First, BREL=1, Branch=Uncondbranch=0, because BREL is used to signal we are branching instead.
% \item RegWrite=0, MemRead=MemWrite=0.
% \item Don't cares:
% \begin{itemize}
% \item Reg2Loc=X, because we are not using "Read Register 2".
% \item MemtoReg=X, because are not writing back to the register file.
% \item ALUOp=XX, ALUSrc=X, because we are not using the ALU.
% \end{itemize}
% \end{itemize}
% Remember to indicate that BREL=0 for all other instructions.
% %\begin{figure}[H]
% %\centering
% %	{\includegraphics[scale=0.4]{figures/brel-idea-redbox}}
% %\end{figure}
% \end{frame}

% \begin{frame}\frametitle{}
% \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
%   colback=blue!5!white,colframe=blue!75!black,colbacktitle=blue!80!black,
%   title=Think About It,fonttitle=\bfseries,
%   boxed title style={size=small,colframe=red!50!black} ]
% MemRead problems if it is a don't care:
% \begin{itemize}
% \item If the address is not a multiple of 8, the computer gives a bus error.
% \item If the address is not in a range that our program can access, the computer gives a segmentation fault.
% \item Reading memory is very slow.
% \end{itemize}
% \end{tcolorbox}
% \end{frame}


\begin{frame}[fragile]
\STitle{Conclusion}
 \underline{\textbf{Lecture Summary}}
 \begin{itemize}
 \item Design datapath for small subset of ARM operations:
\begin{itemize}
\item Load ({\tt LDUR}) and store ({\tt STUR})
\item Add ({\tt ADD}), subtract ({\tt SUB}), and ({\tt AND}), or ({\tt
ORR}).
\item Compare and branch on zero ({\tt CBZ}) and branch ({\tt B})
\end{itemize}
\item Illustrates the fundamental ideas in datapath design 
 \end{itemize}
 \underline{\textbf{Assigned Textbook Readings}}
\begin{itemize}
     \item \textbf{Read} 
     \begin{itemize}
     \item Chapter 4, Section 4.1 -- 4.4

     \end{itemize}
     \item Carefully read \textbf{all} the captions of \textbf{all} the figures  since they many contain important information that is not discussed in the main
text. 

\item We don't implement branch for the single cycle architecture in the initial datapaths, but we add it as an instruction after completing an initial implementation.
     \end{itemize}
    \underline{\textbf{Next Steps}}
    \begin{itemize}
     \item \textbf{Start thinking} about the control unit in a processor. 
% \begin{itemize}
%     % \item Start thinking about the exercises in A3
%     % \item A3 will be released in two parts, first set of exercises focus on Sequential Circuits and FSM, second set of exercises on Data Representation
% \end{itemize}
\item \textbf{Attempt} questions in next week's tutorial. 
    \item \textbf{Ask} questions in office hours or the next tutorial.
 \end{itemize}

\end{frame}



    \begin{frame}{Additional Slides}
    Remaining slides are additional notes for your information.
\end{frame}



% \begin{frame}[fragile]
% \Title{Design of 4Mx1 DRAM}
% \PHFigure{!}{3in}{1.5in}{PHALL/B26}{Similar to Figure A.9.6}
% \begin{itemize}
% \item 20-bit address provided 11 bits at a time
% \item Whole row is read at once
% \item Column address selects single bit
% \item Refresh handled a row at a time (external controller)
% \item If capacitors hold charge for 4ms, refresh takes 80ns, fraction of time
% devoted to refresh is about 4\%
% \end{itemize}
% \end{frame}
% \BNotes\ifnum\Notes=1
% \begin{frame}[fragile]
% Instructor's Notes:
% \begin{itemize}
% \item Note that the figure is in error; a different set of bits goes into
% 	the MUX than goes into the decoder.
% \item There are additional signals called RAS (Row Access Strobe) and
% CAS (Column Access Strobe) to signal whether a row or column address
% is provided 
% \item The math on the refresh goes like this: $2048 \times 80$ ns
%   $=163840\times 10^{-9}$ secs, and dividing this by $4\times 10^{-3}$
%   secs gives $0.04096$
% \item In practice, refresh overhead can often be hidden by other
%   necessary operations in the total memory cycle
% \item Note that a ``word line'' now accesses 2048 bits -- not our
%   usual definition of ``word''
% \end{itemize}
% \end{frame}
% \fi\ENotes