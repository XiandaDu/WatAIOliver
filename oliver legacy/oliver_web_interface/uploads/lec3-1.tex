\setlength{\columnseprule}{1pt}
\def\columnseprulecolor{\color{blue}}

\begin{frame}[fragile]
\STitle{Unsigned Binary Multiplication}
\begin{itemize}
	\item Example:
	\begin{center}
	\begin{tabular}{rcccccccccc}
	13 & & &  &&& 1 & 1 & 0 & 1 & Multiplicand\\
	11 & & &  &&& 1 & 0 & 1 & 1 & Multiplier\\\cline{1-1}\cline{7-10}
	  & & &  &&& 1 & 1 & 0& 1\\
	  & & &  &&1& 1 & 0 & 1& \\
	  & & &  &0& 0 & 0 & 0& &\\
	  & & &  1&1& 0 & 1&  & &\\
	\cline{1-1}\cline{3-10}
	143 & & 1& 0 &0 & 0 & 1 & 1 & 1& 1 & Product\\
	\end{tabular}
	\end{center}
%discuss alo in context of counter based on the flowchart, using counter to be stopping criteria instead of 0 multiplier, avoinding the question, how do we know its not just the zero's within the number 	
 % \item Algorithm for Product = Multiplicand * Multiplier:

	% 	Look at LSB of Multiplier

	% 	If 1, add Multiplicand to Product

	% 	Shift Multiplicand left, Shift Multiplier right

	% 	Repeat until Multiplier becomes zero
	\item Note: for $n$ bit numbers, result may be $2n$ bits
\end{itemize}

\BNotes\ifnum\Notes=1
\begin{itemize}
\item This binary multiplication algorithm is on a 3600 year old papyrus
	that claims to have copied it off a 200 year old papyrus.  See

	http://www-groups.dcs.st-and.ac.uk/~history/HistTopics/Egyptian\_mathematics.html

http://www-groups.dcs.st-and.ac.uk/~history/HistTopics/Egyptian\_papyri.html

for details.
\end{itemize}
\fi\ENotes
\end{frame}

% Be careful with the following - there are three figures that
%  we would like to have appear on the same 2-up page.  I had to
%  shrink the size of the hardware figure to get this to work.
%  A better way would be to make sure it all appeared on facing
%  2-up page, but that's harder to do.

\ifnum\slides=0
\newpage
%\Startoddpage
\fi
\begin{frame}[fragile]
\Title{Simple Multiplication Hardware and Flowchart}
\begin{multicols}{2}
		% \PHFigure{!}{1in}{1.5in}{ARMFigures/Fig0303-crop}{Figure 3.3}
\includegraphics[width=0.5\textwidth]{03-data-representation-and-manipulation/figures/mult-circuit-v1-zhk.png}

% \includegraphics[width=0.5\textwidth, left]{03-data-representation-and-manipulation/figures/mult-circuit-v1-zhk.png}

{\footnotesize
\begin{itemize}
\item Initialization and termination not shown
\item At start, Product is zero, 64-bit Multiplicand in right half of
its register
\item Note control inputs and outputs
\end{itemize}
}
\columnbreak

 % \includegraphics[width=0.5\textwidth, right]{03-data-representation-and-manipulation/figures/mult-v1-flowchart-zhk.png}   
  \includegraphics[width=0.5\textwidth]{03-data-representation-and-manipulation/figures/mult-v1-flowchart-zhk.png}   
\end{multicols}
% {\tiny
% \begin{itemize}
% \item Initialization and termination not shown
% \item At start, Product is zero, 64-bit Multiplicand in right half of
% its register
% \item Note control inputs and outputs
% \end{itemize}
% }
\BNotes\ifnum\Notes=1
~% notes text
\fi\ENotes
\end{frame}

% \begin{frame}{Flowchart for Simple Multiplication Hardware}
%     \includegraphics[scale = 0.3]{03-data representation and manipulation/figures/mult-v1-flowchart-zhk.png}
% \end{frame}
% \begin{frame}[fragile]

% \RFigureCR{!}{3.5in}{3.5in}{Figure 3.4, Flowchart for generating control signals,
%           first version}
%           {ARMFigures/Fig0304-crop}{90}

% \BNotes\ifnum\Notes=1
% ~% notes text
% \fi\ENotes
% \end{frame}

\begin{frame}[fragile]

\Title{4-Bit Multiplication Example, Simple HW Version}

Multiplier = 1011, Multiplicand = 1101

\begin{tabular}{|c|l|c|c|c|} \hline
Iteration & Step & Multiplier & Multiplicand & Product \\ \hline
0 & Initial Values   & \textbf{1011} &\textbf{ 0000\,1101}  & \textbf{0000\,0000} \\ \hline
1 & \textbf{Add mpcd to prod} &      &             & \textbf{0000\,1101} \\
  & \textbf{{\color{red}Shift left mpcd}}  &      & 000\textbf{{\color{red}1\,101}}0  &          \\
  & \textbf{{\color{blue}Shift right mplr}} & 0\textbf{{\color{blue}101}} &             &          \\ \hline
2 & \textbf{Add mpcd to prod} &      &             & \textbf{0010\,0111} \\
  & \textbf{{\color{red}Shift left mpcd}}  &      & 00\textbf{{\color{red}11\,01}}00  &          \\
  & \textbf{{\color{blue}Shift right mplr}} & 00\textbf{{\color{blue}10}} &             &          \\ \hline
3 & \textbf{No operation }    &      &             &          \\
  & \textbf{{\color{red}Shift left mpcd}}  &      & 0\textbf{{\color{red}110\,1}}000  &          \\
  &\textbf{{\color{blue}Shift right mplr}} & 000\textbf{{\color{blue}1}} &             &          \\ \hline
4 & \textbf{Add mpcd to prod} &      &             & \textbf{1000\,1111} \\
  & \textbf{{\color{red}Shift left mpcd}}   &      & \textbf{{\color{red}1101}}\,0000  &          \\
  & \textbf{{\color{blue}Shift right mplr}} & 0000 &             &          \\ \hline
\end{tabular}
Multiplier = 11, Multiplicand = 13 and Product = 143 = $1000\ 1111$

\BNotes\ifnum\Notes=1
\begin{itemize}
\item Register contents are only shown when they change.
\item Note that the ``no operation'' does not show up on the
flowchart. Whether this takes a clock cycle or not depends on the
implementation of control and whether the designer wants every
multiplication operation to take exactly the same time or not. It is
shown here for simplicity.
\item For 32-bit words, this takes nearly 100 clock cycles as shown;
of course, shifts can be done in parallel. Still, multiplication is
more expensive than addition or subtraction.
\item Lots of empty space in registers, leading to next optimization:
to save space in multiplicand, keep it fixed and shift product right.
\item Note that the design of control is not shown here; it can be
implemented using a finite-state machine (good homework question?)
with the help of some additional counters.
\end{itemize}


\fi\ENotes
\end{frame}

% \begin{frame}{Example: Unsigned Binary Multiplication}
%     \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
%   colback=red!5!white,colframe=red!75!black,colbacktitle=red!80!black,
%   title=Try this,fonttitle=\bfseries,
%   boxed title style={size=small,colframe=red!50!black} ]
%   Compute $6 \times 12$ using the simple multiplication hardware discussed in class.
%    \end{tcolorbox}
% Hints for solution:
%   \begin{enumerate}      
%       \item What is $6_{10}$ as a 4-bit unsigned binary?
% \item What is $12_{10}$ as a 4-bit unsigned binary?
% \item Say, multiplicand  register is $6$ in unsigned binary and multiplier register is unsigned binary of $12$. 
% \item Follow the flowchart with number of repetitions set to 4 (since 4-bit numbers)
%   \end{enumerate}
 
% \end{frame}

% %example added by zhk
% \ifnum\Ans=1
% \begin{frame}{Solution: 4-Bit Unsigned Binary Multiplication}

% Multiplier = $6_{10}$ = $0110_2$, Multiplicand = $12_{10} = 1100_2$

% \begin{tabular}{|c|l|c|c|c|} \hline
% Iteration & Step & Multiplier & Multiplicand & Product \\ \hline
% 0 & Initial Values   & {\color{red}011\textbf{0}} & 0000\,{\color{blue}1100}  & 0000\,0000 \\ \hline
% 1 & No operation     &      &             & \\%0000\,0000 \\
%   & Shift left mpcd  &      & 000{\color{blue}1\,100}0  &          \\
%   & Shift right mplr & 0{\color{red}01\textbf{1}} &             &          \\ \hline
% 2 & Add mpcd to prod &      &             & 0001\,1000 \\
%   & Shift left mpcd  &      & 00{\color{blue}11\,00}00  &          \\
%   & Shift right mplr & 00{\color{red}0\textbf{1}} &             &          \\ \hline
% 3 & Add mpcd to prod     &      &             &     0100\,1000     \\
%   & Shift left mpcd  &      & 0{\color{blue}110\,0}000  &          \\
%   & Shift right mplr & 000{\color{red}\textbf{0}} &             &          \\ \hline
% 4 & No operation &      &             &  \\
%   & Shift left mpcd  &      & {\color{blue}1100}\,0000  &          \\
%   & Shift right mplr & 0000 &             &          \\ \hline
% \end{tabular}

% Multiplier = 6, Multiplicand = 12 and Product = 72 = $0100\,1000$
% \end{frame}
% \fi


% Be careful with the following - there are three figures that
%  we would like to have appear on the same 2-up page.  I had to
%  shrink the size of the hardware figure and the flow chart figure
%  to get this to work.
%  A better way would be to make sure it all appeared on facing
%  2-up page, but that's harder to do.
% 2014-02-10: This material took up 9 pages.  We no longer print these 2-up,
%  so I adjusted things so that they now take up only 5 pages instead.

\ifnum\slides=0
\newpage
%\Startoddpage
\fi


\ifnum\slides=0\fi
\newpage
% %\Startoddpage
% \fi
% \begin{frame}[fragile]
% \Title{Multiplication Hardware, Second Version}
% 		\PHFigure{!}{4in}{2in}{ARMFigures/Fig0305-crop}{Improved multiplication flow chart}
% \begin{itemize}
% \item Multiplier starts in right half of product register
% \item As multiplier bits are shifted out, unchanging bits of product
% are shifted into the space created
% \end{itemize}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item This is an example from the 2nd edition of the textbook; 
% 	the third edition removed this example.
% \item Consider skipping this example unless you are way ahead of where
% 	you should be.  Skipping means skipping all three slides for
% 	this multiplier.
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]

% \RFigureCR{!}{4in}{3.5in}{Flowchart for generating control signals,
%           second version}
%           {PHALL/F0432}{90}

% \BNotes\ifnum\Notes=1
% ~% notes text
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
% \Title{4-Bit Multiplication Example, Second HW Version}

% Multiplier = 1011, Multiplicand = 1101

% \begin{tabular}{|c|l|c|r|} \hline
% Iteration & Step & Multiplicand & Product \\ \hline
% 0 & Initial Values    & 1101 &  0000\,\fbox{1011} \\ \hline
% 1 & Add mpcd to prod  &      &  1101\,\fbox{1011} \\
%   & Shift right prod  & 1101 &  0110\,1\fbox{101} \\
%   &                   &      &                    \\
%  \hline
% 2 & Add mpcd to prod  &      & \fbox{1}0011\,1\fbox{101} \\
%   & Shift right prod  & 1101 &  1001\,11\fbox{10} \\ 
%  \hline
% 3 & No operation      &      &           \\
%   & Shift right prod  & 1101 &  0100\,111\fbox{1} \\
%   &                   &      &                    \\
%  \hline
% 4 & Add mpcd to prod  &      & \fbox{1}0001\,111\fbox{1} \\
%   & Shift right prod  & 1101 &  1000\,1111\, \\ \hline
% \end{tabular}

% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item Boxes to right of product register indicate bits of multiplier
% remaining; test is done on LSB of product register.
% \item Book deals with signed multiplication, division in similar
% fashion. 

% \end{itemize}
% \fi\ENotes
% \end{frame}


\begin{frame}[fragile]
\Title{How to Represent Real Numbers}
\begin{itemize}
\item Real numbers: $\pi, \sqrt{2}, \dots$. 

In contrast to natural numbers ($0, 1, 2, \dots$) and integers ($\dots, -2, -1, 0, 1, 2, \dots$)

\item Use scientific notation to represent real numbers
 \item Recall, scientific notation
 \begin{itemize}
   
        \item  Normalized scientific notation:  single non-zero digit to the left of the decimal point 
        
        $-3.45 \times 10^3 \equiv -3450$
    \item Numbers represented this way do not have a fixed decimal point position, they are called \textbf{floating point (FP)}.
\end{itemize}
\item For computers, natural to use base 2
\item Example 1: $1.01_2 \times 2^4 \equiv 10100_2 = 1 \times 2^4 + 1 \times 2^2 = 20_{10}$
\item Example 2: $(1.01)_2 \times 2^0 = 1 (2^0) + 0 (2^{-1})+ 1 \times 2^{-2} = 1 + \frac{1}{4} = \left(\frac{5}{4}\right)_{10}$
\item FP numbers on a computer are approximations of real numbers

% \item Binary fractions work just like decimal
% \item Example 1: $1.01_2 \times 2^4 \equiv 10100_2 = 1 \times 2^4 + 1 \times 2^2 = 20_{10}$
% \item Example 2: {\footnotesize
% \begin{align*}
%     1.01_2 &=& 1 \times 2^0 + 0 \times 2^{-1} + 1 \times 2^{-2} \\
%     &=& 1 + 1 \times \frac{1}{4}\\
%     &=& \frac{5}{4}\\
%     &=& 1.25_{10}\\
% \end{align*}
% }
\end{itemize}
\BNotes\ifnum\Notes=1
\begin{itemize}
\item
What is $1.01_2 \times 2^4$? Binary fractions work just like decimal
ones (in fact, we use the term ``decimal point''), so $1.01_2 = 1 + 0
\times 2^{-1} + 1 \times 2^{-2}$ or $5/4$. Thus this number is 20.
\item The answer to the last question comes on the next slide.
	Basically, the all 0 exponent comment is for the biased
	exponent.
\item Terminology: Significand = 1+0.Fraction
\item Computer representation is an approximation.  As an example, ask them
	if they know Fermat's Last Theorem (There exist integers $A,B,C$
	such that $A^n+B^n=C^n$ is true for natural numbers only for $n=2$).
	Then ask if anyone has a calculator, and have them show that
	\[
		1782^{12} + 1841^{12} = 1922^{12}
	\]
	by computing
	\[
		1782^{12} + 1841^{12} - 1922^{12} = 0
	\]
	While the equality is incorrect, it holds up to 9 digits of precision,
	which is all that most calculators have.

	Thus, floating point numbers on a computer are approximations to 
	real numbers.
\end{itemize}
\fi\ENotes
\end{frame}


% \begin{frame}{Example: Binary to Decimal FPs}
% % \begin{itemize}
%     % \item 
%     Binary fractions work just like decimal
% % \item Example 1: $1.01_2 \times 2^4 \equiv 10100_2 = 1 \times 2^4 + 1 \times 2^2 = 20_{10}$
% % \item Example 2: {\footnotesize
% % \begin{align*}
% %     1.01_2 &=& 1 \times 2^0 + 0 \times 2^{-1} + 1 \times 2^{-2} \\
% %     % &=& 1 + 1 \times \frac{1}{4}\\
% %     &=& \frac{5}{4}\\
% %     &=& 1.25_{10}\\
% % \end{align*}
% % }
% % \end{itemize}
% \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
%   colback=blue!5!white,colframe=blue!75!black,colbacktitle=blue!80!black,
%   title=Think About It,fonttitle=\bfseries,
%   boxed title style={size=small,colframe=red!50!black} ]
% Binary fraction conversion is the same as for integers:
% $$(1.01)_2 = 1 (2^0) + 0 (2^{-1})+ 1 \times 2^{-2} = 1 + \frac{1}{4} = \left(\frac{5}{4}\right)_{10}.$$
% % Therefore, the binary floating point number can be converted to decimal:
% % $$(1.01)_2 \times 2^4 = \left( \frac{5}{4}\right)_{10}\left( 2^4 \right) = 1.25 \times 16 =  20.$$
%   \end{tcolorbox}

    
% \end{frame}

% for comprehensive
\newpage

\begin{frame}{Terminology}
\begin{itemize}
     \item  Consider the floating point number ${\color{red}-}\textbf{1}.{\color{teal}010} \times 2^{\color{blue}3}$ in scientific notation
     \item {\color{red}Sign}, {\color{teal}fraction}, {\color{blue} power}
     
     \item ARM uses the IEEE 754 floating-point standard format
     \begin{multicols}{2}
         
\begin{center}
	\Figure{!}{.25in}{.25in}{Figs/FPsingle}{Single Precision FP}
\end{center}

\columnbreak
\begin{itemize}
\item \textbf{exponent} (biased) = ${\color{blue} \texttt{power}} + 127$
     
\end{itemize}
 
     \end{multicols}
%remove the term mantissa
\item \textbf{Significand} = \textbf{1} + 0.{\color{teal}fraction}
     \item A FP representation must compromise between the fraction and exponent:
\begin{itemize}
\item Single precision (SP)\footnote{Double precision: uses two 32-bit words, 11 bits for exponent,
52 bits for significand} approximately allows numbers from $2 \times 10^{-38}$ to $2 \times 10^{+38}$
\item more bits for the fraction increases \textbf{precision},
\item more bits for the exponent increases \textbf{range}.
\end{itemize}

\item Thus value in IEEE 754 FP is $(-1)^{\mbox{\color{red}S}} \times (1 +
\mbox{{\color{teal}fraction}}) \times 2^{({\color{blue}\mbox{exponent} - \mbox{Bias}})}$,{\footnotesize where $\mbox{Bias}=127$ for SP}
% \item Special case: $0000\,0000$ exponent reserved for 0
\end{itemize}

\end{frame}

\begin{frame}{Think About It}
    \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
  colback=blue!5!white,colframe=blue!75!black,colbacktitle=blue!80!black,
  title=Think About It,fonttitle=\bfseries,
  boxed title style={size=small,colframe=red!50!black} ]
  Why \texttt{E} before \texttt{F}?\\
  
  \ifnum\Ans=1{\color{red} Makes comparisons and sorting easy}\fi
  \end{tcolorbox}

   \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
  colback=blue!5!white,colframe=blue!75!black,colbacktitle=blue!80!black,
  title=Think About It,fonttitle=\bfseries,
  boxed title style={size=small,colframe=red!50!black} ]
  What does the IEEE 754 FP format resemble?\\
  
  \ifnum\Ans=1{\color{red} IEEE 754 format resembles sign and magnitude. \hl{However, biased exponent is represented as \textbf{unsigned}}}\fi
  \end{tcolorbox}

  %  \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
  % colback=blue!5!white,colframe=blue!75!black,colbacktitle=blue!80!black,
  % title=Think About It,fonttitle=\bfseries,
  % boxed title style={size=small,colframe=red!50!black} ]
  % In computations, what binary number representation should we use to
  % interpret \texttt{E} and \texttt{F}, unsigned, sign and magnitude or 2's complement?
  % \end{tcolorbox}
   \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
  colback=blue!5!white,colframe=blue!75!black,colbacktitle=blue!80!black,
  title=Think About It,fonttitle=\bfseries,
  boxed title style={size=small,colframe=red!50!black} ]
  How to represent 0?
  \end{tcolorbox}
\end{frame}


%-----------------------------------------------------
% \begin{frame}\frametitle{Floating Point Representation}
% \begin{itemize}
% \item We want to compare FPs using integer comparisons.

% \item The sign bit is the most significant bit.
% \begin{itemize}
% \item We can quickly test $FP<0$, $FP>0$, $FP==0$.
% \end{itemize}
% \item Place the exponent before the the fraction. This makes numbers with bigger exponents look larger than numbers with smaller exponents.
% % \end{itemize}
% \item If two's complement is used for exponent, then negative exponents look like big numbers. So instead, \textbf{bias notation} is used.
% % $$FP=(-1)^S \cdot (1.F) \cdot 2^{E-Bias}.$$
% \begin{itemize}
% % \item The most negative exponent is all 0's.
% % \item The most positive exponent is all 1's.
% \item $Bias$ for single precision is 127. 
% %$(0111\text{ }1111)_2=2^7-1=127$.
% % \item $Bias$ for double precision is $(011\text{ } 1111\text{ } 1111)_2=2^{10}-1=1023$.
% \end{itemize}
% \end{itemize}
% \end{frame}


% \begin{frame}[fragile]
% \STitle{Biased Notation}
% \begin{itemize}

% \item Exponent is stored in ``biased'' notation
% \item Exponent is interpreted as an unsigned binary integer
% % \begin{itemize}
% %     \item most negative exponent is all 0's
% % \item most positive is all 1's
% % \end{itemize}

% \item The value is represented as

% $(-1)^{\mbox{S}} \times (1 +
% \mbox{fraction}) \times 2^{(\mbox{exponent} - \mbox{bias})}$, 

% where $\mbox{bias} = 127$ for single precision

% \item So, in $-1.010 \times 2^{-1}$ the exponent of $-1$ is represented with a bit pattern of $-1+127 = 126$. 
% % {\tiny That is, in the representation above exponent refers to the binary representation in the FP number. And \texttt{exponent} $-127 = -1  = -1 +127 $}
% \item Special cases:
% \begin{multicols}{2}
%   {\footnotesize  
% % \begin{table}[H]
% % \begin{center}
% \begin{tabular}{ |c|c || c |}
%     \hline 
%     E & F  & FP value \\ \hline\hline
%     0 & 0  & 0 \\ \hline
%     all 1's & 0 & $\pm \infty$ \\ \hline
%     all 1's & nonzero & Not a Number \\ \hline
% \end{tabular}
% %\caption{}\label{}
% % \end{center}
% % \end{table}
% }

% \columnbreak

% % \begin{center}
% 	\Figure{!}{.25in}{.25in}{Figs/FPsingle}
% % \end{center}
% \end{multicols}
% \item Exponent = $0000\,0000$ reserved for 0
% \item Invalid operations such as $0/0$ or $\infty-\infty$ will produce result ``Not a Number (NaN)".
% \end{itemize}

% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item In computation of values represented, the Exponent field is interpreted 
% 	as an unsigned binary integer, and the Significand as a binary fraction.
% \item Quad precision: 16 bytes, 1 sign, 15 exponent, 112 fraction (113 total)
% \item The exponent $0000\,0000$ (which should represent $2^{-127}$)
% 	is used instead to represent 0.  That's as far as the text goes.
% 	  In IEEE, the
% 	exponent $0000\,0000$ give us a "denormalized" floating point
% 	number with exponent $2^{-126}$; if the significand is all zeros,
% 	then obviously the number is 0.  But whereas for other values
% 	of the exponent,
% 	S-exp-man is the form about, for exponent $0000\,0000$ the
% 	number is $(-1)^{\mbox{S}} \times (0 + \mbox{Significand}) \times 2^{(-Bias+1)}$
% \item Thus, to represent 0 the exponent and the signficand should both be
% 	zero.  We will also have positive 0 and negative 0.
% \item In real IEEE, the exponent $1111\,1111$ is used for infinities, NaN,
% \item "speeds up sorting": floating point numbers sort the same way as 2's complement.
% \item Quad: 1 bit sign, 15 bit exponent, 112 (113) bit significand
% \end{itemize}
% \fi\ENotes
% \end{frame}

\begin{frame}[fragile]
\STitle{Special Cases}
% {itemize}

Special cases:
\begin{multicols}{2}
  {\footnotesize  
% \begin{table}[H]
% \begin{center}
\begin{tabular}{ |c|c || c |}
    \hline 
    E & F  & FP value \\ \hline\hline
    0 & 0  & 0 \\ \hline
    all 1's & 0 & $\pm \infty$ \\ \hline
    all 1's & nonzero & Not a Number \\ \hline
\end{tabular}
%\caption{}\label{}
% \end{center}
% \end{table}
}

\columnbreak

% \begin{center}
	\Figure{!}{.25in}{.25in}{Figs/FPsingle}
% \end{center}
\end{multicols}
% 
\BNotes\ifnum\Notes=1
\begin{itemize}
\item In computation of values represented, the Exponent field is interpreted 
	as an unsigned binary integer, and the Significand as a binary fraction.
\item Quad precision: 16 bytes, 1 sign, 15 exponent, 112 fraction (113 total)
\item The exponent $0000\,0000$ (which should represent $2^{-127}$)
	is used instead to represent 0.  That's as far as the text goes.
	  In IEEE, the
	exponent $0000\,0000$ give us a "denormalized" floating point
	number with exponent $2^{-126}$; if the significand is all zeros,
	then obviously the number is 0.  But whereas for other values
	of the exponent,
	S-exp-man is the form about, for exponent $0000\,0000$ the
	number is $(-1)^{\mbox{S}} \times (0 + \mbox{Significand}) \times 2^{(-Bias+1)}$
\item Thus, to represent 0 the exponent and the signficand should both be
	zero.  We will also have positive 0 and negative 0.
\item In real IEEE, the exponent $1111\,1111$ is used for infinities, NaN,
\item "speeds up sorting": floating point numbers sort the same way as 2's complement.
\item Quad: 1 bit sign, 15 bit exponent, 112 (113) bit significand
\end{itemize}
\fi\ENotes
\end{frame}



%-----------------------------------------------------
\begin{frame}{Example: Biased Notation}
    \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
  colback=red!5!white,colframe=red!75!black,colbacktitle=red!80!black,
  title=Try this,fonttitle=\bfseries,
  boxed title style={size=small,colframe=red!50!black} ]

Given the power, complete the following table for the biased exponent and its binary representation in IEEE 754 format. 

Recall, \textbf{exponent} (biased) = ${\color{blue} \texttt{power}} + 127$

% Recall, bias for single precision is 127. 

\begin{table}[H]
\begin{center}
\begin{tabular}{ |c|c|c|}
    \hline 
    Power   & Biased Exponent  & Binary representation  \\
    & & of biased exponent\\
    \hline\hline
    $4$ & $4 + 127 = 131$ \\ \hline
    $-100$ &   \\ \hline
    $-77$  &     \\ \hline
    $-106$ &    \\ \hline
    $27$   &   \\ \hline
    $0$ & \\\hline
    $-128$ & \\\hline
\end{tabular}
%\caption{}\label{}
\end{center}
\end{table}
\end{tcolorbox}
\end{frame}

%-----------------------------------------------------

\ifnum\Ans=1
\begin{frame}{Solution: Biased Notation}
   % This means that the FP numbers we are representing are $1.\text{fraction} \times 2^X$
\begin{table}[H]
\begin{center}
\begin{tabular}{ |c|c|c|}
    \hline 
    Power   & Biased Exponent  & Binary representation  \\
    & & of biased exponent\\
    \hline\hline
    $-100$ & $\mathbf{-100}+127 = 27$ & 1000\,0011   \\ \hline
    $-77$  & $\mathbf{-77}+127 = 50$ &  0011\,0010  \\ \hline
    $-106$ & $\mathbf{-106}+127 =21$  &  0001\,0101\\ \hline
    $27$   & $\mathbf{27}+127 =154$  &  1001\,1010\\ \hline
    % $-50$  & $\mathbf{-50}+127 =77$ &   \\ \hline
      $0$ & $\mathbf{0}+127 =127$  & 0111\,1111 \\ \hline
    $128$ &$\mathbf{128}+127 =255$  &  1111\,1111\\ \hline
\end{tabular}

\end{center}
\end{table}
% Biased Notation is the number stored in the exponent field of the IEEE Single Precision for Floating Point Numbers
\end{frame}
\fi

%-----------------------------------------------------
% \begin{frame}\frametitle{Floating Point Overflow}

% \begin{itemize}
% \item Overflow: Exponent is too large to be represented in the exponent field.
% \item Underflow: Negative exponent is too large to be represented in the exponent field 
% \end{itemize}
% ARM will throw an exception.
% \hfill\break

% Double precision reduces overflow and underflow compared to single precision. 
% \end{frame}

% \begin{frame}[fragile]
% \Title{Fractional Numbers}
% \begin{itemize}
% 	\item How to represent numbers less than 1?
% 	\item Digits to right of decimal point represent negative powers of two

% 	\begin{center}
% 	\begin{tabular}{ccccc}
% 	0. & 1 & 0 & 1 & 1\\
% 	1  & 1/2 & 1/4 & 1/8 & 1/16\\
% 	\end{tabular}
% 	\end{center}
% 	0*1 + 1*1/2 + 0*1/4 + 1*1/8 + 1*1/16 = 11/16

% 	\item Simple examples

% 	1/2 = 0.1

% 	3/4 = 0.11
% 	\item May have to approximate

% 		Example: 1/3 as decimal is...

% 		0.1 in binary is...

% 		sqrt(2) in binary is...
% \end{itemize}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% 	\item 1/3 in binary is 0.0101... with the 01 repeating
% 	\item 0.1 in binary is 0.000110011... with the 0011 repeating
% 	\item The two main points:
% 	\begin{itemize}
% 		\item We have to approximate sqrt(2), etc., regardless of base
% 		\item Numbers that are nice in decimal, like 0.1, are not
% 			so nice in binary
% 	\end{itemize}
% \end{itemize}
% \fi\ENotes
% \end{frame}


%-----------------------------------------------------
% \begin{frame}\frametitle{Basic Conversion Examples}
% Since $(1)_2=(1)_{10}$, we may sometimes omit showing the step that changes the base for the number 1.
% \begin{align*}
% (0.0011)_{2} = 1 (2^{-3}) + 1(2^{-4}) = \frac{1}{8}  + \frac{1}{16}=\left(\frac{3}{16}\right)_{10} 
% \end{align*}
% \end{frame}
%-----------------------------------------------------
% \begin{frame}\frametitle{Basic Conversion Examples}
% Binary floating point single precision to decimal:
% \begin{align*}
% S &= 1, \\
% E &= 10000001 = 2^7 + 1 = 129, \\
% F &= 0100000000000000000000 = 2^{-2} =0.25\\
% FP & = (-1)^1 \times (1+F) \times 2^{E-127} \\
% &= (-1)(1+0.25) \times 2^{129-127}\\
%  &= -(1.25) \times 2^2\\
%   &= -1.25 \times 4 \\
%  &= (-5)_{10} \\
% \end{align*}

% \end{frame}
% %-----------------------------------------------------
\begin{frame}\frametitle{An Algorithm for Converting From a Decimal to a Binary}
Multiple the decimal by 2 to get a result $d$, take the value before the decimal in $d$ as our binary digit.
\hfill\break

Repeat with the remaining decimal digits.
\hfill\break

Stop when the digit to the right of the decimal point is 0. That is, $d=1.0$.
\end{frame}

%-----------------------------------------------------
\begin{frame}[fragile]\frametitle{Decimal to a Binary: Example 1}
Consider $(0.625)_{10}$:
\begin{align*}
0.625 \times 2 = \mathbf{1}.25 &\text{ answer so far: 0.1}\\
0.25 \times 2 = \mathbf{0}.5   &\text{ answer so far: 0.10}\\
0.5 \times 2 = \mathbf{1}.0    &\text{ answer so far: 0.101}
\end{align*}

Therefore, $(0.625)_{10} = (0.101)_2=(1.01)_2 \times 2^{-1}$.


In IEEE 754 FP: $1.01 \times 2^{exp-127=-1} = 1.01 \times 2^{126}$

% $$(1.0101)_2 \times 2 ^1 = (1.0101)_2 \times 2 ^{128-127}.$$
This number is stored as a 32 bit word.
\begin{verbatim}
S: 0                            // positive 
E: 0111 1110                    // exponent stored is 126
F: 0100 0000 0000 0000 0000 000 // fraction
--------------------------------------
S:E:F
0 0111 1110 0100 0000 0000 0000 0000 000
\end{verbatim}

\end{frame}
%-----------------------------------------------------
\begin{frame}\frametitle{Decimal to a Binary: Example 2}

Consider $(0.1)_{10}$:
\begin{align*}
0.1 \times 2 = \mathbf{0}.2 &\text{ answer so far: 0.0}\\
0.2 \times 2 = \mathbf{0}.4 &\text{ answer so far: 0.00}\\
0.4 \times 2 = \mathbf{0}.8 &\text{ answer so far: 0.000}\\
0.8 \times 2 = \mathbf{1}.6 &\text{ answer so far: 0.0001}\\
0.6 \times 2 = \mathbf{1}.2 &\text{ answer so far: 0.00011}\\
0.2 \times 2 = \mathbf{0}.4 &\text{ answer so far: 0.000110 //above pattern repeats}\\
0.4 \times 2 = \mathbf{0}.8 &\text{ answer so far: 0.0001100} \\
0.8 \times 2 = \mathbf{1}.6 &\text{ answer so far: 0.00011001}\\
0.6 \times 2 = \mathbf{1}.2 &\text{ answer so far: 0.000110011}
\end{align*}
Therefore, $(0.1)_{10} = (0.0\overline{0011})=1.1\overline{0011} \times 2^{-4}$. Since this number is an infinite decimal, the computer has to approximate it. For a large number of precision (fraction) bits, we get very very close to 0.1.
\end{frame}

%-----------------------------------------------------
% \begin{frame}\frametitle{Decimal to a Binary: Example 3}
% Consider $(1/3)_{10}=(0.\overline{3})_{10}$:
% \begin{align*}
% 0.\overline{3} \times 2 = \mathbf{0}.\overline{6} &\text{ answer so far: 0.0}\\
% 0.\overline{6} \times 2 = \mathbf{1}.\overline{3} &\text{ answer so far: 0.01}\\
% 0.\overline{3} \times 2 = \mathbf{0}.\overline{6} &\text{ answer so far: 0.010}\\
% 0.\overline{6} \times 2 = \mathbf{1}.\overline{3} &\text{ answer so far: 0.0101}
% \end{align*}
% Therefore, $(0.\overline{3})_{10} = (0.\overline{01})_2 =(1.\overline{01})_2 \times 2^{-2}$. 
% \hfill\break

% For a number like $\sqrt{2}$ which has infinite decimals, regardless of the base, it has to be approximated. 

% \end{frame}

%-----------------------------------------------------
% \begin{frame}[fragile]\frametitle{Decimal to a Binary: Example 3}

% Consider $(2.625)_{10}=(2+0.625)_{10}$:
% \begin{itemize}
% \item The integer part is $(2)_{10}=(10)_2$.
% \item The fraction part is $(0.625)_{10}=(0.101)_2$, this was calculated previously.
% \end{itemize}
% Therefore,{\footnotesize
% \begin{align*}
% (2+0.625)_{10} &= (10+0.101)_2 \\
% & = (10.101)_2 \\
% & = (1.0101)_2 \times 2 ^1 \\
% & = (1.0101)_2 \times 2 ^{128-127}
% \end{align*}
% This number is stored as a 32 bit word.
% \begin{verbatim}
% S: 0                            // positive 
% E: 1000 0000                    // exponent stored is 128
% F: 0101 0000 0000 0000 0000 000 // fraction
% --------------------------------------
% S:E:F
% 0 1000 0000 0101 0000 0000 0000 0000 000
% \end{verbatim}
% }
% {\tiny{0100 0000 0010 1000 0000 0000 0000 0000 // group by 4 bits}}
% \end{frame}

%-----------------------------------------------------
\begin{frame}\frametitle{Decimal to a Binary: Example 3}

Consider $(625.65625)_{10}=(625+0.65625)_{10}$:
\begin{itemize}
\item The integer part is 
\begin{align*}
625_{10}&= 2^9 + 2^6 + 2^5 + 2^4+2^0 =(10\text{ }0111\text{ }0001)_2
\end{align*}
\item The fraction part is $(0.65625)_{10}$:
\begin{align*}
0.65625 \times 2 = \mathbf{1}.3125 &\text{ answer so far: 0.1}\\
0.3125 \times 2 = \mathbf{0}.625   &\text{ answer so far: 0.10}\\
0.625 \times 2 = \mathbf{1}.25     &\text{ answer so far: 0.101}\\
0.25 \times 2  = \mathbf{0}.5      &\text{ answer so far: 0.1010} \\
0.5 \times 2  = \mathbf{1}.0       &\text{ answer so far: 0.10101} \
\end{align*}
Therefore, $(0.65625)_{10}=(0.10101)_{2}$
\end{itemize}
Finally, $(10\text{ }0111\text{ }0001.10101)_2=(1.00111000110101)_2\times 2^9$.
\end{frame}

\begin{frame}[fragile]\frametitle{Example 3 continued}
Previously, we found
$$(625+0.65625)_{10}= 1.00111000110101\times 2^9.$$
Now we will store this as a 32 bit word.
\begin{align*}
S&=0\\
E&=9 + 127 = 136 = 2^7+2^3 = (1000 1000)_2\\
F&=00111000110101
\end{align*}
Therefore, our word is:
\begin{verbatim}
0 10001000 00111000110101000000000
-----------------------------------------
0100 0100 0001 1100 0110 1010 0000 0000 //group by 4
\end{verbatim}
\end{frame}
%-----------------------------------------------------
\begin{frame}[fragile]\frametitle{Reading the Bit Pattern}
Consider a 32 bit FP that is stored as the following bit pattern:
\begin{verbatim}
0011 1111 1101 0100 0000 0000 0000 0000
S=0
E=0111 1111
F=1010 1000 0000 0000 0000 000
\end{verbatim}
$E = 127 - 127 =0$ and $F=0.10101$. So our binary number is:
$$\textbf{1}.10101 \times 2^0 = 1.10101 = (1.65625)_{10}$$

\end{frame}

% \begin{frame}{Review: IEEE 754 Single Precision Representation of Floating Point Numbers}
%     \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
%   colback=blue!5!white,colframe=blue!75!black,colbacktitle=blue!80!black,
%   title=Think About It,fonttitle=\bfseries,
%   boxed title style={size=small,colframe=red!50!black} ]
% \begin{center}
% \begin{tabular}{ |c|c|c|c|}
%     \hline 
%     IEEE 754 FP & Conversion & Exponent in & Note \\
%     Exponent\footnote{8 bits: interpret as unsigned binary (never negative numbers)} & & Scientific Notation  &  \\ \hline\hline
%     $0000\, 0000$ & $0 - 127$ & $-127$ & reserved\\ \hline
%      $0000\, 0001$   &  $1 - 127$ & $-126$ &$S\footnote{ where S is a significant (1.Fraction)} \times 2^{-126}$ \\ \hline
%      $0101\, 0101$ & $85 - 127$ & $-42$ & $S \times 2^{-42}$\\ \hline
%      % $0000\, 0001$   &  $1 - 127$ & $-126$ &$S \times 2^{-126}$ \\ \hline
%     $1111\, 1111$  & $255 - 127$ & 128 &  reserved \\ \hline
%     $0111\, 1111$ &  $127 - 127$ & 0 & $S \times 2^0$ \\ \hline
%     $1100\, 1010$ &  $202 - 127$ & 75 & $S \times 2^{75}$ \\ \hline
%    $1111\, 1110$ &  $254 - 127$ & 127 & $S \times 2^{127}$ \\ \hline
% \end{tabular}
% \end{center}
% \end{tcolorbox}
% {\small
% Note: The exponent in scientific notation can be between $-126$ and $+127$.
% }
% \end{frame}


\begin{frame}[fragile]
\STitle{Floating-Point Addition}
\begin{itemize}
\item Decimal example: $9.54 \times 10^2 + 6.83 \times 10^1$

(assume we can only store two digits to the right of the decimal point)
\begin{enumerate}
\item Match exponents: $9.54 \times 10^2 + .683 \times 10^2$
\item Add significands, with sign: $10.223 \times 10^2$
\item Normalize: $1.0223 \times 10^3$
\item Check for exponent overflow/underflow
\item Round: $1.02 \times 10^3$
\item May have to normalize again
\end{enumerate}
\item Same idea works for binary
\end{itemize}
\BNotes\ifnum\Notes=1
Note the possible need for renormalizing at the end;
rounding can result in an unnormalized number (for instance, using a
decimal example, if a sum like $9.9995 \times 10^3$ is rounded to four
digits in the significand). Renormalization should only be needed
once.
\fi\ENotes
\end{frame}

\begin{frame}{Example 1: Binary Floating Point Addition}
       \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
  colback=red!5!white,colframe=red!75!black,colbacktitle=red!80!black,
  title=Try this,fonttitle=\bfseries,
  boxed title style={size=small,colframe=red!50!black} ]
Compute $0.5_{10} + (-0.4375)_{10}$ using binary floating point numbers. 
  \end{tcolorbox}
Convert to binary floating points: 
\begin{align*}
(0.5)_{10}&=(1.000)_2 \times 2^{-1}\\
(-0.4375)_{10}&=(-1.110)_2 \times 2^{-2}
\end{align*}
Assume we only have 4 bits in hardware. Therefore we only keep four bits of the significand, this means 3 bits to the right of the binary point.  
\end{frame}

\ifnum\Ans=1
\begin{frame}[fragile]
\STitle{Solution: Binary Floating Point Addition}
$(1.000)_2 \times 2^{-1} + [(-1.110)_2 \times 2^{-2}]$
    \begin{multicols}{2}
\begin{minipage}{2in}
        \begin{enumerate}
\item $(-1.110)_2 \times 2^{-2}=-0.111 \times 2^{-1}.$
\item $1.000 -0.111=0.001$.
\item $0.001 \times 2^{-1} = 1.0 \times 2^{-4}$.
\item No underflow, since $127 \geq -4 \geq -126$ {\tiny Single precision biased exponents are between 1 and 254.}
% \begin{itemize}
% \item Single precision biased exponents are between 1 and 254.
% \end{itemize}
\item No rounding needed $(1.000)_2 \times 2^{-4}$ does not need rounding since $(1.000)$ is exaclty 4 bits.
\item Sum is normalized.
\end{enumerate}
\end{minipage}
\columnbreak
	\RFigureCR{!}{3in}{3in}{Figure 3.14, Flowchart for Floating-Point Addition}{PHALL/F0444}{90}
 \end{multicols}
\BNotes\ifnum\Notes=1
\begin{itemize}
\item Go over this flowchart carefully, using an example worked on the
board in binary (you can use the one from the book, but it is better
to develop a second one). 
\end{itemize}
\fi\ENotes
\end{frame}
\fi

\begin{frame}{Example 2: Binary Floating Point Addition}
\begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
colback=red!5!white,colframe=red!75!black,colbacktitle=red!80!black,
title=Try this,fonttitle=\bfseries,
boxed title style={size=small,colframe=red!50!black} ]
Compute $7.125+ 1.6015625$ using binary floating point numbers. 
\end{tcolorbox}
Convert to binary floating points: 
  \begin{multicols}{2}
\begin{align*}
(7.125)_{10}&= 7_{10} + 0.125_{10}\\
&= 111_2 + 0.001_2\\
&= 111.001_2 \\
&= 1.11001 \times 2^2\\
\end{align*}

\columnbreak

\begin{align*}
(1.6015625)_{10}&= 1_{10} + 0.6015625_{10}\\
&= 1_2 + 0.1001101_2\\
&= 1.1001101_2 \\
&= 1.1001101 \times 2^0\\
\end{align*}
\end{multicols}
Assume IEEE 754 Floating Point representation, therefore, 23 bits for fraction.  
\end{frame}

\ifnum\Ans=1
\begin{frame}[fragile]
\STitle{Solution: Binary Floating Point Addition}
$1.11001 \times 2^2 + 1.1001101 \times 2^0$
    \begin{multicols}{2}
\begin{minipage}{2in}
        \begin{enumerate}
\item $1.1001101 \times 2^0 = 0.011001101 \times 2^2$
\item $1.11001 + 0.011001101 = 10.001011101$
\item Normalize: $10.001011101$. $ 10.001011101 = 1.0001011101 \times 2^1 \times 2^2 = 1.0001011101 \times 2^3$.
\item No overflow. Since $127 \geq 3 \geq -126$, there is no under or overflow. {\tiny Single precision biased exponents are between 1 and 254.}
\item No rounding needed.
\item Sum is still normalized. 
\end{enumerate}
\end{minipage}

\columnbreak
	\RFigureCR{!}{3in}{3in}{Figure 3.14, Flowchart for Floating-Point Addition}{PHALL/F0444}{90}
    \end{multicols}
\BNotes\ifnum\Notes=1
\begin{itemize}
\item Go over this flowchart carefully, using an example worked on the
board in binary (you can use the one from the book, but it is better
to develop a second one). 
\end{itemize}
\fi\ENotes
\end{frame}
\fi

\ifnum\Ans=1
\begin{frame}[fragile]
\STitle{Solution: Check Results of Binary Floating Point Addition}
Convert binary result to decimal:
\begin{align*}    
1.11001 \times 2^2 + 1.1001101 \times 2^0 
&= 1.0001011101 \times 2^3  \\
&= 1 + \frac{1}{16}+\frac{1}{64} +\frac{1}{128}+\frac{1}{256} +\frac{1}{1024}\\
    &= (1+\frac{93}{1024}) \times 8\\
    &= 8.7265625\\
\end{align*}
Check against decimal results:
\begin{align*}
    7.125 + 1.6015625 \\
    &= 8.7265625_{10}\\
   &= 8_{10} + 0.7265625_{10}\\
    &= 1000_2 + 0.1011101_2\\
    &= 1000.1011101\\
    &= 1.0001011101 \times 2^3
\end{align*}

\BNotes\ifnum\Notes=1
\begin{itemize}
\item Go over this flowchart carefully, using an example worked on the
board in binary (you can use the one from the book, but it is better
to develop a second one). 
\end{itemize}
\fi\ENotes
\end{frame}
\fi

\begin{frame}[fragile]

	\RFigureCR{!}{4in}{3in}{Figure 3.15, Hardware for Floating-Point
         Addition}{PHALL/F0445}{90}

\BNotes\ifnum\Notes=1
Using the flowchart as reference, trace which components perform what
function, and give a glimpse inside some of the black boxes -- notably
the small and large ALUs (different number of input bits, different
functionality), and the rounding hardware. We will not go further into
floating-point hardware than this slide.
\fi\ENotes
\end{frame}

% \begin{frame}{Example: Use of Hardware for FP Addition}
% \begin{multicols}{2}
% \begin{minipage}{3in}
%     \includegraphics[width=2in]{03-data representation and manipulation/figures/hw-fp-addition-zhk.png}
% \end{minipage}
% \columnbreak
% \begin{minipage}{2in}
% Let $a = 1.1001101 \times 2^0$ and  $b = 1.11001 \times 2^2$. Then $a+b$
%         \begin{enumerate}
% \item Small ALU = $ 0 - 2 = -2,$ Then $R < 0$
% \item Then, $S0 = 1, S1=0$ and $S2=1$
% \item This implies, $1.11001 + 0.011001101 = 10.001011101$
% \item Normalize Sum. $10.001011101 = 1.0001011101 \times 2^1 \times 2^2 = 1.0001011101 \times 2^3$.
% \item No rounding needed. No Overflow.
% \end{enumerate}
% \end{minipage}
% \end{multicols}
    
% \end{frame}


% \begin{frame}{Example: Use of hardware for FP Addition}
% \begin{center}
%     \includegraphics[scale=0.35]{03-data-representation-and-manipulation/figures/mockeduphw-zhk.png}
% \end{center}
    
% \end{frame}

\begin{frame}[fragile]
\STitle{Floating-Point Multiplication}
\begin{itemize}
\item Decimal example: $(9.54 \times 10^2) \times (6.83 \times 10^1)$

(assume we can only store two digits to right of decimal point)
\begin{enumerate}
\item Add exponents: $2+1=3$

	(Note: exponents stored in biased notation)
\item Multiply significands: $9.54 \times 6.83 = 65.1582$
\item Unnormalized result: $65.1582 \times 10^3$
\item Normalize: $6.51582 \times 10^4$
\item Check for overflow/underflow
\item Round: $6.52 \times 10^4$

      (May need to renormalize)
\item Set sign
\end{enumerate}
\item Same idea works for binary
\end{itemize}
\BNotes\ifnum\Notes=1
~% notes text
\fi\ENotes
\end{frame}

%-----------------------------------------------------
\begin{frame}\frametitle{FP Multiplication Example}
We will multiply the following two numbers 
\begin{align*}
(0.5)_{10}&=(1.000)_2 \times 2^{-1}\\
(-0.4375)_{10}&=(-1.110)_2 \times 2^{-2}
\end{align*}
Assume we keep four bits of the significand, this means 3 bits to the right of the binary point.
\end{frame}

%-----------------------------------------------------
% \begin{frame}\frametitle{FP Multiplication Example}
% $(1.000)_2 \times 2^{-1} \times (-1.110)_2 \times 2^{-2}.$
% \begin{enumerate}
% \item Add the exponents: $-1+(-2)=-3$. 

% If we want to use the bias notation, the sum is 
% $$(-1+127) + (-2+127)-127=-3+127=124.$$

% \item Multiply the significands.
% \begin{center}
% \begin{tabular}{ccccccc}
% &&          &1. & 0 & 0 & 0  \\
% &&$\times$  &1. & 1 & 1 & 0  \\ \hline
%    &   &   &0  & 0 & 0 & 0  \\
%    &   & 1 &0  & 0 & 0 &   \\
%    & 1 & 0 & 0 & 0 &   & \\
%  1 & 0 & 0 & 0 &   &   &\\ \hline
%  1. & 1 & 1 & 0 & 0 & 0 & 0
% \end{tabular}
% \end{center}

% The answer to four bits is $(1.110)_2 \times 2^{-3}$.
% \end{enumerate}

% \end{frame}
% %-----------------------------------------------------
% \begin{frame}\frametitle{FP Multiplication Example}

% \begin{enumerate}
% \setcounter{enumi}{2}
% \item Make sure the product is normalized. $(1.110)_2 \times 2^{-3}$ is already normalized.

% \item Check the exponent for overflow or underflow. Here $127\geq -3 \geq -126$ so there is no overflow or underflow.

% \item Round to four bits. The product $(1.110)_2 \times 2^{-3}$ does not require rounding.
% \item Set the sign. This product has a negative sign, $-(1.110)_2 \times 2^{-3}$.
% \end{enumerate}

% \end{frame}

%both of the above slides have been condensed into slide below





\begin{frame}[fragile]

\begin{columns}
    \column{0.6\textwidth}
    {\footnotesize
    \begin{enumerate}
\item Add the exponents: $-1+(-2)=-3$. 

If we want to use the bias notation, the sum is 
(-1 + 127) + (-2 + 127) - 127 = -3 + 127 = 124.

\item Multiply the significands.
{\tiny
\begin{center}
\begin{tabular}{ccccccc}
&&          &1. & 0 & 0 & 0  \\
&&$\times$  &1. & 1 & 1 & 0  \\ \hline
   &   &   &0  & 0 & 0 & 0  \\
   &   & 1 &0  & 0 & 0 &   \\
   & 1 & 0 & 0 & 0 &   & \\
 1 & 0 & 0 & 0 &   &   &\\ \hline
 1. & 1 & 1 & 0 & 0 & 0 & 0
\end{tabular}
\end{center}}

The answer to four bits is $(1.110)_2 \times 2^{-3}$.
\item Make sure the product is normalized. $(1.110)_2 \times 2^{-3}$ is already normalized.

\item Check the exponent for overflow or underflow. Here $127\geq -3 \geq -126$ so there is no overflow or underflow.

\item Round to four bits. The product $(1.110)_2 \times 2^{-3}$ does not require rounding.
\item Set the sign. This product has a negative sign, $-(1.110)_2 \times 2^{-3}$.
\end{enumerate}
    }
    \column{0.4\textwidth}
    \RFigureCR{!}{4in}{2.5in}{\footnotesize Figure 3.16, Flowchart for Floating-Point
         	Multiplication}{PHALL/F0446}{90}
\end{columns}

	

\BNotes\ifnum\Notes=1
\begin{itemize}
\item Do a binary example.  But -- see next slide and possibly use first
	multiplication example (but with exponents)
\item Your example will use regular exponents, but show what happens
	if you use biased exponents
\item Show that result is $2n$ bits when multiplying two $n$-bit numbers
\end{itemize}
\fi\ENotes
\end{frame}

\begin{frame}[fragile]
\STitle{Accuracy}
\begin{itemize}
        \item Only certain numbers can be represented accurately
	\item Typically the result of an operation cannot be represented precisely
	\item The result must be rounded.  Multiple ways to round

		\framebox{For this class, we will round 1/2 up in magnitude}
	\item Do we need to compute precisely and then round?
        \item Goal: save hardware by not keeping full precision internally during computation

	\item	How few bits can be used to get correct $n$-bit result after
		rounding?

	Result should be the same as if we had kept full precision and 
		rounded afterwards
\end{itemize}
\BNotes\ifnum\Notes=1
\begin{itemize}
	\item To clarify the last bullet: we start with two $n$-bit numbers.
		Assume we compute with an unbounded number of bits and
		then round to $n$-bits.  The question is: rather than use
		an unbounded number of bits, how few can we use?
\end{itemize}
\fi\ENotes
\end{frame}

\begin{frame}[fragile]
\Title{Accuracy in Floating-Point Addition}
\begin{itemize}
  \item In adding two significands with $n$ bits of precision, 

	can use an $n$-bit adder (giving $n+1$-bit result)
  \item Is least significant bit of result enough to round correctly?
  \item Our addition examples will use $n=4$

\begin{center}
\begin{tabular}{ccccccccc }
  &   & 1 & . & 0 & 1 & 0 & $\times$ & $2^0$ \\
+ &   & 1 & . & 1 & 1 & 1 & $\times$ & $2^0$ \\ \hline
  & 1 & 1 & . & 0 & 0 & 1 & $\times$ & $2^0$ \\
\end{tabular}
\end{center}

Hardware adder gives two bits to left of decimal point
\item This is normalized to $1.1001 \times 2^1$ and then
  rounded to $1.101 \times 2^1$
\item Problem may arise when one significand has to be shifted to match
  exponents 
\end{itemize}

\BNotes\ifnum\Notes=1
\begin{itemize}
	\item The question we're trying to answer is: how many bits do we need
		to keep to produce the correct, rounded result?
		(Remember, we will be rounding 1/2 up).
	\item For example, ask them to recall what an $n$-bit adder gives as
		an answer.  Consider going back to Ripple-Carry Adder slide
		to show $n$-bits plus carry-out.
	\item In the example, we have 4 bits.  A $4$-bit adder
		gives an $4$-bit result with a carry out.  So in this
		example, if we round the result of the adder output, we're fine.
\end{itemize}
\fi\ENotes
\end{frame}

\begin{frame}[fragile]
\begin{itemize}

\item 	Example: $1.010\times2^2+1.001\times2^1$

After normalization, our input bits span range of $n+1$ bits.  

How do we add this with an $n$-bit adder?  

Can we ignore low order bit?

\begin{center}
\begin{tabular}{cccccccccc}
 &  & 1 & . & 0 & 1 & 0 & & $\times$ & $2^2$ \\
+&  & 0 & . & 1 & 0 & 0 & \framebox{1} &$\times$ & $2^2$ \\ \hline
 &0 & 1 & . & 1 & 1 & 0 & & $\times$ & $2^2$ \\
\end{tabular}
\end{center}

Note leftmost 0 is carry out of adder

\item Here, boxed bit of second significand was not fed into adder

But is boxed bit needed to round correctly?
\item With it, normalized result is $1.1101 \times 2^2$, rounds to $1.111 \times 2^2$
\item Without it, normalized result is $1.110 \times 2^2$
\item Thus for $n$-bit accuracy, we need to keep $n+2$ bits during the computation
\end{itemize}

\BNotes\ifnum\Notes=1
\begin{itemize}
\item This example is trickier: our problem really requires two $n+1$ numbers.
	But we only have an $n$-bit adder.  The approach on the slide is just
	to drop the extra bit (the smallest one).  But when rounding 1/2 up,
	this gives a different answer than if we had unbounded precision.

\item It is not clear from these examples why $n+2$ bits are always
	sufficient, but they are (well...).  

	In particular, 1 bit is for carry out and one bit is to capture the
	"one half" used for rounding.
\item Actually, there are some additional bits hanging around "under the hood".
	Basically, there is a bit that starts as 0 and is set to one if any
	of the bits that are thrown away are 1.  With this information, you
	can check if the "one half" you want to round is actually greater
	than one half.  If so, round up.  If not, it gets a bit complicated.
	IEEE "rounds to even" to avoid a creeping bias by always rounding
	one half up.  Still, it's an arbitrary choice.  The extra bit avoids 
	having to make this arbitrary choice much of the time.
\item See also a later slide that refers to the round and guard bits.
\end{itemize}
\fi\ENotes
\end{frame}

\begin{frame}[fragile]
\Title{Accuracy in Floating-Point Multiplication}
\begin{itemize}
\item When multiplying two floating-point numbers, the significands
  are multiplied together
\item If the significands have $n$ bits of precision each, the result
  can have $2n$ bits of precision
\item How many bits do we need to keep during the computation?
\item Our multiplication examples will have $n=3$
\end{itemize}

\BNotes\ifnum\Notes=1
~% notes text{}
\fi\ENotes
\end{frame}

\begin{frame}[fragile]
\begin{itemize}
\item Example:
\begin{center}
\begin{tabular}{cccccccccc}
         &  & 1 & . & 1 & 1 &   &   & $\times$ & $2^2$ \\
$\times$ &  & 1 & . & 1 & 1 &   &   & $\times$ & $2^1$ \\ \hline
         &1 & 1 & . & 0 & 0 & 0 & 1 & $\times$ & $2^3$ \\
\end{tabular}
\end{center}


\item In above example, only top 3 bits are needed for final result 
of $1.10 \times 2^4$

\item Example: Do we need fourth (boxed) bit?
\begin{center}
\begin{tabular}{cccccccccc}
         &  & 1 & . & 1 & 0 &   &   & $\times$ & $2^2$ \\
$\times$ &  & 1 & . & 1 & 0 &   &   & $\times$ & $2^1$ \\ \hline
         &1 & 0 & . & 0 & \framebox{1} & 0 & 0 & $\times$ & $2^3$ \\
\end{tabular}
\end{center}


\item With three bits, $10.0 \times 2^3$ is normalized to $1.00 \times 2^4$,
which is incorrectly rounded

\item With four bits, $10.01 \times 2^3$ is normalized to $1.001 \times
2^4$, and correctly rounded up to $1.01 \times 2^4$
\end{itemize}

\BNotes\ifnum\Notes=1
\begin{itemize}
	\item The circled bit is the "extra" we need to keep beyond three bits
		for this example to work.
\end{itemize}
\fi\ENotes
\end{frame}

%this example is not clear  point, review later
% \begin{frame}[fragile]

% \begin{itemize}
% \item Example: Do we need boxed bits?
% \begin{center}
% \begin{tabular}{cccccccccc}
%          &  & 1 & . & 0 & 1 &   &   & $\times$ & $2^2$ \\
% $\times$ &  & 1 & . & 1 & 0 &   &   & $\times$ & $2^1$ \\ \hline
%          & & 1 & . & 1 & \framebox{1} & \framebox{1} & 0 & $\times$ & $2^3$ \\
% \end{tabular}
% \end{center}

% \item With three bits, $1.11 \times 2^3$ is normalized to $1.10 \times 2^3$,
% which is incorrectly rounded

% \item With four bits, $1.11 \times 2^3$ is normalized to $1.110 \times
% 2^3$, and rounded to $1.11 \times 2^3$, which is incorrectly rounded

% \item With five bits, $1.111 \times 2^3$ is normalized to $1.111 \times
% 2^3$, rounded to $10.0 \times 2^3$, and normalized again to $1.00
% \times 2^4$, which is correctly rounded
% \end{itemize}

% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item The need for two extra bits also can occur during subtraction, if
% there is cancellation in the top bit requiring a shift left, as in our
% last example for multiplication.
% \item Again, it is not clear why two bits are sufficient, but they are.
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
% \STitle{Floating-Point Architectural Issues}
% \begin{itemize}
% \item To maintain $n$ bits of accuracy after an operation, preserve $n+2$
%   bits during the computation (the two extra bits are sometimes 
%   called {\em guard} and {\em round})
% \item Separate floating-point registers? 
% \item Separate floating-point coprocessors?
% \item Rounding or truncating?
% \item What to do about overflow (same issue as for integer arithmetic)?
% \item Less precision:
	
% 	\begin{center}
% 		\begin{tabular}{cccc}
% 			 16-bit format & $u$ & min & max \\\hline
% 			 fp16 & $4.88\times 10^{-4}$ & 6.10$\times 10^{-5}$ & 6.55$\times 10^{4}$\\
% 			 bfloat16 & 3.91$\times 10^{-3}$ & 1.18$\times 10^{-38}$ & 3.39$\times10^{38}$
% 		\end{tabular}
% 	\end{center}
% \end{itemize}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item Rounding 1 up can lead to upward drift in a long sum; IEEE 754
%   specifies ``round to even'', and keeps a ``sticky bit'' (OR of
%   discarded bits) to facilitate this
% \item Rounding is actually under the control of the programmer in the
%   standard, though this is often not implemented
% \item Having separate floating-point registers saves room in the
% instruction format.
% \item Historically, many architectures had optional
% floating-point coprocessors (machines without them simulated FP
% instructions in software). This is not an issue in mainframe and PC
% architectures of today, but may still be an issue in embedded systems.
% \item Overflow is handled by an exception: control jumps to a routine
% predefined by the programmer to handle the problem. 
% \item The book's historical development section (3.11 online)
%       is quite entertaining. 
% \item "Less precision": It was noticed that communication was more
% 	expensive than computation for singular valued decomposition.  

% 	For deep learning applications, 16-bit floats were sufficient.
% 	This motivated the development of 16-bit floating point numbers,
% 	with plans for 8-bit numbers.

% 	Note precision vs range in the two 16-bit formats.
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}\frametitle{Accuracy Summary}

% The hardware for adding two $n$-bit significands is an $n+1$-bit adder. The sum needs $n+2$ bits in order to round correctly
% \hfill\break

% The hardware for multiplying two $n$-bit significands keeps an $n+2$ product in order to round the product correctly.
% \hfill\break

% However, the hardware can track if any of the rightmost bits beyond the $n+2$-nd is a one, if true, then the hardware can round up.

% \end{frame}
%-----------------------------------------------------
%\begin{frame}\frametitle{Accuracy}
%When adding two $n$ bit numbers significands, the fp with the smaller exponent is shifted.  After the shift, we can ignore some less significand digits as long as the final sum has $n+2$ digits.
%\hfill\break

%When multiplying two $n$ bit significands , the final product significand can have up to $2n$ bits. We only need to keep $n+2$ to ensure correct rounding.  More can be kept so that we can distinguish for example ...1000... with ...1001... to know when to round up.
%\hfill\break

%\end{frame}
%-----------------------------------------------------
% \begin{frame}\frametitle{Some Key Ideas}

% \begin{itemize}
% \item Cancellation

% Subtracting two similar numbers will cause lots of the bits to cancel. Therefore use as many bits of precision as possible, choose double over single precision.

% For example, $f(x+h)-f(x)$, \emph{loses} precision as $h\to 0$. The estimation of the derivative becames worse rather than better as $h \to 0$.

% \item Round-off Errors

% Do not use float numbers in loops. The computer sometimes rounds floating numbers up, sometimes down.
% \begin{itemize}
% \item Adding different floating numbers keeps the rounding random.

% If we add the same number repeatedly, the round off error accumulates. For example, Recall $(0.1)_{10}$ cannot be represented exactly in binary. The same is true for 0.0001. Thus, adding 0.0001 repeatedly 10,000 times gives a little bit more than 1. This is due to rounding in intermediate results. But the sum is suppose to accumulate to 1.
% \end{itemize}
% \end{itemize}
% \end{frame}

\begin{frame}[fragile]
\STitle{Floating-Point Architectural Issues}
\begin{itemize}
\item To maintain $n$ bits of accuracy after an operation, preserve $n+2$
  bits during the computation (the two extra bits are sometimes 
  called {\em guard} and {\em round})
\item Separate floating-point registers? 
\item Separate floating-point coprocessors?
\item Rounding or truncating?
\item What to do about overflow (same issue as for integer arithmetic)?
\item Less precision:
	
	\begin{center}
		\begin{tabular}{cccc}
			 16-bit format & $u$ & min & max \\\hline
			 fp16 & $4.88\times 10^{-4}$ & 6.10$\times 10^{-5}$ & 6.55$\times 10^{4}$\\
			 bfloat16 & 3.91$\times 10^{-3}$ & 1.18$\times 10^{-38}$ & 3.39$\times10^{38}$
		\end{tabular}
	\end{center}
\end{itemize}
\BNotes\ifnum\Notes=1
\begin{itemize}
\item Rounding 1 up can lead to upward drift in a long sum; IEEE 754
  specifies ``round to even'', and keeps a ``sticky bit'' (OR of
  discarded bits) to facilitate this
\item Rounding is actually under the control of the programmer in the
  standard, though this is often not implemented
\item Having separate floating-point registers saves room in the
instruction format.
\item Historically, many architectures had optional
floating-point coprocessors (machines without them simulated FP
instructions in software). This is not an issue in mainframe and PC
architectures of today, but may still be an issue in embedded systems.
\item Overflow is handled by an exception: control jumps to a routine
predefined by the programmer to handle the problem. 
\item The book's historical development section (3.11 online)
      is quite entertaining. 
\item "Less precision": It was noticed that communication was more
	expensive than computation for singular valued decomposition.  

	For deep learning applications, 16-bit floats were sufficient.
	This motivated the development of 16-bit floating point numbers,
	with plans for 8-bit numbers.

	Note precision vs range in the two 16-bit formats.
\end{itemize}
\fi\ENotes
\end{frame}

%-----------------------------------------------------
% \begin{frame}\frametitle{Architecture Issues}

% Having separate \textbf{floating-point registers} saves room in the instruction format.
% \hfill\break

% Historically, many architectures had optional \textbf{floating-point coprocessors} (machines without them simulated FP instructions in software). This is not an issue in mainframe and PC architectures of today, but may still be an issue in embedded systems.
% \hfill\break

% The online version of the textbook discusses some historical developments.
% \hfill\break

% Less precision seems sufficient for big data and deep learning. This is why 16-bit format is another choice.

% \end{frame}
% %-----------------------------------------------------



\begin{frame}[fragile]
\STitle{Conclusion}
 \underline{\textbf{Lecture Summary}}
 \begin{itemize}
   \item Binary Multiplication
    % \item Simplified hardware to implement unsigned binary multiplication
    \item IEEE Floating Point number representation
    \item Floating point arithmetic 
 \end{itemize}
 \underline{\textbf{Assigned Textbook Readings}}
     \begin{itemize}
\item Section 3.3 (pages 191-194)
\item Section 3.5 (pages 205-220, 226-230)
\end{itemize}

    \underline{\textbf{Next Steps}}
    \begin{itemize}
     \item \textbf{Review} conversion steps from decimal to binary and back for integers. 
% \begin{itemize}
%     % \item Start thinking about the exercises in A3
%     % \item A3 will be released in two parts, first set of exercises focus on Sequential Circuits and FSM, second set of exercises on Data Representation
% \end{itemize}
\item \textbf{Attempt} questions in next week's tutorial. 
    \item \textbf{Ask} questions in office hours or the next tutorial.
 \end{itemize}

\end{frame}

\begin{frame}{Additional Slides}
    Remaining slides are additional notes for your information.
\end{frame}


%%%%another multiplication example
\begin{frame}{Example: Unsigned Binary Multiplication}
    \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
  colback=red!5!white,colframe=red!75!black,colbacktitle=red!80!black,
  title=Try this,fonttitle=\bfseries,
  boxed title style={size=small,colframe=red!50!black} ]
  Compute $6 \times 12$ using the simple multiplication hardware discussed in class.
   \end{tcolorbox}
Hints for solution:
  \begin{enumerate}      
      \item What is $6_{10}$ as a 4-bit unsigned binary?
\item What is $12_{10}$ as a 4-bit unsigned binary?
\item Say, multiplicand  register is $6$ in unsigned binary and multiplier register is unsigned binary of $12$. 
\item Follow the flowchart with number of repetitions set to 4 (since 4-bit numbers)
  \end{enumerate}
 
\end{frame}

%example added by zhk
\ifnum\Ans=1
\begin{frame}{Solution: 4-Bit Unsigned Binary Multiplication}

Multiplier = $6_{10}$ = $0110_2$, Multiplicand = $12_{10} = 1100_2$

\begin{tabular}{|c|l|c|c|c|} \hline
Iteration & Step & Multiplier & Multiplicand & Product \\ \hline
0 & Initial Values   & {\color{red}011\textbf{0}} & 0000\,{\color{blue}1100}  & 0000\,0000 \\ \hline
1 & No operation     &      &             & \\%0000\,0000 \\
  & Shift left mpcd  &      & 000{\color{blue}1\,100}0  &          \\
  & Shift right mplr & 0{\color{red}01\textbf{1}} &             &          \\ \hline
2 & Add mpcd to prod &      &             & 0001\,1000 \\
  & Shift left mpcd  &      & 00{\color{blue}11\,00}00  &          \\
  & Shift right mplr & 00{\color{red}0\textbf{1}} &             &          \\ \hline
3 & Add mpcd to prod     &      &             &     0100\,1000     \\
  & Shift left mpcd  &      & 0{\color{blue}110\,0}000  &          \\
  & Shift right mplr & 000{\color{red}\textbf{0}} &             &          \\ \hline
4 & No operation &      &             &  \\
  & Shift left mpcd  &      & {\color{blue}1100}\,0000  &          \\
  & Shift right mplr & 0000 &             &          \\ \hline
\end{tabular}

Multiplier = 6, Multiplicand = 12 and Product = 72 = $0100\,1000$
\end{frame}
\fi


\begin{frame}[fragile]
\Title{Multiplication Hardware, Second Version}
		\PHFigure{!}{4in}{2in}{ARMFigures/Fig0305-crop}{Improved multiplication flow chart}
\begin{itemize}
\item Multiplier starts in right half of product register
\item As multiplier bits are shifted out, unchanging bits of product
are shifted into the space created
\end{itemize}
\BNotes\ifnum\Notes=1
\begin{itemize}
\item This is an example from the 2nd edition of the textbook; 
	the third edition removed this example.
\item Consider skipping this example unless you are way ahead of where
	you should be.  Skipping means skipping all three slides for
	this multiplier.
\end{itemize}
\fi\ENotes
\end{frame}

\begin{frame}[fragile]
\STitle{Example: Multiplication in Second Version}
\begin{multicols}{2}
  \RFigureCR{!}{4in}{2.5in}{Flowchart for generating control signals,
          second version}
          {PHALL/F0432}{90}

  \columnbreak
 {\tiny
  Multiplier = 1011, Multiplicand (MPCD) = 1101

\begin{tabular}{|c|l|c|r|} \hline
Iter. & Step & MPCD & Product \\ \hline
0 & Initial Values    & 1101 &  0000\,\fbox{1011} \\ \hline
1 & Add mpcd to prod  &      &  1101\,\fbox{1011} \\
  & Shift right prod  & 1101 &  0110\,1\fbox{101} \\
  &                   &      &                    \\
 \hline
2 & Add mpcd to prod  &      & \fbox{1}0011\,1\fbox{101} \\
  & Shift right prod  & 1101 &  1001\,11\fbox{10} \\ 
 \hline
3 & No operation      &      &           \\
  & Shift right prod  & 1101 &  0100\,111\fbox{1} \\
  &                   &      &                    \\
 \hline
4 & Add mpcd to prod  &      & \fbox{1}0001\,111\fbox{1} \\
  & Shift right
  prod  & 1101 &  1000\,1111\, \\ \hline
\end{tabular}
}
\end{multicols}

% \RFigureCR{!}{4in}{3.5in}{Flowchart for generating control signals,
%           second version}
%           {PHALL/F0432}{90}

\BNotes\ifnum\Notes=1
~% notes text
\fi\ENotes
\end{frame}

% \begin{frame}[fragile]
% \Title{4-Bit Multiplication Example, Second HW Version}

% Multiplier = 1011, Multiplicand = 1101

% \begin{tabular}{|c|l|c|r|} \hline
% Iteration & Step & Multiplicand & Product \\ \hline
% 0 & Initial Values    & 1101 &  0000\,\fbox{1011} \\ \hline
% 1 & Add mpcd to prod  &      &  1101\,\fbox{1011} \\
%   & Shift right prod  & 1101 &  0110\,1\fbox{101} \\
%   &                   &      &                    \\
%  \hline
% 2 & Add mpcd to prod  &      & \fbox{1}0011\,1\fbox{101} \\
%   & Shift right prod  & 1101 &  1001\,11\fbox{10} \\ 
%  \hline
% 3 & No operation      &      &           \\
%   & Shift right prod  & 1101 &  0100\,111\fbox{1} \\
%   &                   &      &                    \\
%  \hline
% 4 & Add mpcd to prod  &      & \fbox{1}0001\,111\fbox{1} \\
%   & Shift right prod  & 1101 &  1000\,1111\, \\ \hline
% \end{tabular}

% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item Boxes to right of product register indicate bits of multiplier
% remaining; test is done on LSB of product register.
% \item Book deals with signed multiplication, division in similar
% fashion. 

% \end{itemize}
% \fi\ENotes
% \end{frame}

\begin{frame}\frametitle{Decimal to a Binary: An example}
Consider $(1/3)_{10}=(0.\overline{3})_{10}$:
\begin{align*}
0.\overline{3} \times 2 = \mathbf{0}.\overline{6} &\text{ answer so far: 0.0}\\
0.\overline{6} \times 2 = \mathbf{1}.\overline{3} &\text{ answer so far: 0.01}\\
0.\overline{3} \times 2 = \mathbf{0}.\overline{6} &\text{ answer so far: 0.010}\\
0.\overline{6} \times 2 = \mathbf{1}.\overline{3} &\text{ answer so far: 0.0101}
\end{align*}
Therefore, $(0.\overline{3})_{10} = (0.\overline{01})_2 =(1.\overline{01})_2 \times 2^{-2}$. 
\hfill\break

For a number like $\sqrt{2}$ which has infinite decimals, regardless of the base, it has to be approximated. 

\end{frame}

\begin{frame}[fragile]\frametitle{Decimal to a Binary: Another Example}

Consider $(2.625)_{10}=(2+0.625)_{10}$:
\begin{itemize}
\item The integer part is $(2)_{10}=(10)_2$.
\item The fraction part is $(0.625)_{10}=(0.101)_2$, this was calculated previously.
\end{itemize}
Therefore,{\footnotesize
\begin{align*}
(2+0.625)_{10} &= (10+0.101)_2 \\
& = (10.101)_2 \\
& = (1.0101)_2 \times 2 ^1 \\
& = (1.0101)_2 \times 2 ^{128-127}
\end{align*}
This number is stored as a 32 bit word.
\begin{verbatim}
S: 0                            // positive 
E: 1000 0000                    // exponent stored is 128
F: 0101 0000 0000 0000 0000 000 // fraction
--------------------------------------
S:E:F
0 1000 0000 0101 0000 0000 0000 0000 000
\end{verbatim}
}
{\tiny{0100 0000 0010 1000 0000 0000 0000 0000 // group by 4 bits}}
\end{frame}

\begin{frame}{Review: IEEE 754 Single Precision Representation of Floating Point Numbers}
    \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
  colback=blue!5!white,colframe=blue!75!black,colbacktitle=blue!80!black,
  title=Think About It,fonttitle=\bfseries,
  boxed title style={size=small,colframe=red!50!black} ]
\begin{center}
\begin{tabular}{ |c|c|c|c|}
    \hline 
    IEEE 754 FP & Conversion & Exponent in & Note \\
    Exponent\footnote{8 bits: interpret as unsigned binary (never negative numbers)} & & Scientific Notation  &  \\ \hline\hline
    $0000\, 0000$ & $0 - 127$ & $-127$ & reserved\\ \hline
     $0000\, 0001$   &  $1 - 127$ & $-126$ &$S\footnote{ where S is a significand (1.Fraction)} \times 2^{-126}$ \\ \hline
     $0101\, 0101$ & $85 - 127$ & $-42$ & $S \times 2^{-42}$\\ \hline
     % $0000\, 0001$   &  $1 - 127$ & $-126$ &$S \times 2^{-126}$ \\ \hline
    $1111\, 1111$  & $255 - 127$ & 128 &  reserved \\ \hline
    $0111\, 1111$ &  $127 - 127$ & 0 & $S \times 2^0$ \\ \hline
    $1100\, 1010$ &  $202 - 127$ & 75 & $S \times 2^{75}$ \\ \hline
   $1111\, 1110$ &  $254 - 127$ & 127 & $S \times 2^{127}$ \\ \hline
\end{tabular}
\end{center}
\end{tcolorbox}
{\small
Note: The exponent in scientific notation can be between $-126$ and $+127$.
}
\end{frame}

%consider the following video on the DC tool
% https://youtu.be/WxCP8oHq_Ss?si=HfiDILN0sAFpzbnV

% for comprehensive
\newpage
\begin{frame}{Example: Use of hardware for FP Addition}
\begin{center}
    \includegraphics[scale=0.35]{03-data-representation-and-manipulation/figures/mockeduphw-zhk.png}
\end{center}
    
\end{frame}

\begin{frame}\frametitle{Floating Point Overflow}

\begin{itemize}
\item Overflow: Exponent is too large to be represented in the exponent field.
\item Underflow: Negative exponent is too large to be represented in the exponent field 
\end{itemize}
ARM will throw an exception.
\hfill\break

Double precision reduces overflow and underflow compared to single precision. 
\end{frame}
% \end{frame}
\begin{frame}\frametitle{Think About It}

\begin{itemize}
\item Cancellation

Subtracting two similar numbers will cause lots of the bits to cancel. Therefore use as many bits of precision as possible, choose double over single precision.

For example, $f(x+h)-f(x)$, \emph{loses} precision as $h\to 0$. The estimation of the derivative becomes worse rather than better as $h \to 0$.

\item Round-off Errors

Do not use float numbers in loops. The computer sometimes rounds floating numbers up, sometimes down.
\begin{itemize}
\item Adding different floating numbers keeps the rounding random.

If we add the same number repeatedly, the round off error accumulates. For example, Recall $(0.1)_{10}$ cannot be represented exactly in binary. The same is true for 0.0001. Thus, adding 0.0001 repeatedly 10,000 times gives a little bit more than 1. This is due to rounding in intermediate results. But the sum is suppose to accumulate to 1.
\end{itemize}
\end{itemize}
\end{frame}
\begin{frame}\frametitle{Further Study of Representation of Floating Point Numbers}
Floating point numbers are an example of what you can study in the area of numerical computation, introduced in CS 370.
\end{frame}