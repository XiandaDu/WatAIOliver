\setlength{\columnseprule}{1pt}
\def\columnseprulecolor{\color{blue}}


% \begin{Lecture}{ Pipelining and Control Hazards}

%%%%%%%%%%%%%%%% next lecture 
% \begin{frame}{Control Hazards Section 4.8}
%     \STitle{Control Hazards}
% \end{frame}

% \begin{frame}[fragile]
% \Title{Control Hazards}
% \begin{itemize}
% \item Readings: Chapter 4, section 4.8  
% % --4.8
% %\item Idea: increase parallelism by overlapping execution of multiple
% %instructions 
% %\item Analogy: laundry (wash/dry/fold/put-away)
% %\item Analogy: industrial assembly line
% \end{itemize}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item
% The readings cover the basic idea of pipelining, design of the
% datapath, design of the control, dealing with data hazards via
% forwarding, stalling instructions, and branch hazards. Students can
% skim the sections on superscalar, and dynamic pipelining;
% those with a keen interest can look at the PowerPC/Pentium section.
% \item    
% The intermediate registers between stages store the information coming
% out of one and going into the other at the next clock cycle. Some of
% these already exist. For instance, the instruction fetch hardware will
% put the instruction into the IR. But the decode step has to put
% information from the instruction, like the field values, into
% registers, because the IR is going to be overwritten in the next clock
% cycle with the next instruction.
% \item Where the analogies break down: instructions are not independent
% (can interfere with each other). We have to deal with such
% interference, though first we do the design as if it doesn't happen,
% then add the extra hardware required.

% \end{itemize}
% \fi\ENotes
% \end{frame}


\begin{frame}[fragile]
\STitle{Branch Hazards}
	\PHFigure{!}{4.4in}{2.8in}{ARMFigures/Fig0460-crop-update}{Figure 4.60}
\BNotes\ifnum\Notes=1
\begin{itemize}
	\item Trace the {\tt CBZ} through datapath to see when PC is updated.
	\item Discuss how to flush the three instructions (ie, zero all the
		control bits).  This requires zero'ing out the control bits
		coming out of ID/EX, going into ID/EX, and NOPing instruction
		going into IF/ID.
	\item Would be better if branch performed earlier in pipeline.
\end{itemize}
\fi\ENotes
\end{frame}

%%%%%%%%%%%%%%%% rearranged S24

% %-----------------------------------------------------
% \begin{frame}\frametitle{Control Hazards}

% The instruction that was fetched is not the one that is needed.

% \begin{itemize}
% \item The conditional branch instruction must begin fetching the instruction following the branch on the following clock cycle.

% \item However, the pipeline cannot know what the next instruction should be.
% \end{itemize}
% \end{frame}

%-----------------------------------------------------
\begin{frame}\frametitle{Resolving Control Hazards}
Solutions to control hazards:
\begin{itemize}
\item Software solutions:
    \begin{itemize}
    \item Compiler rearranges code 
        \item NOPs - compiler inserts NOPs
        \item Limitation: reduces utilization of pipeline
    \end{itemize}
    \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
  colback=green!5!white,colframe=green!75!black,colbacktitle=green!80!black,
  title=Remember It,fonttitle=\bfseries,
  boxed title style={size=small,colframe=green!50!black} ]
How many NOPs have to be inserted in our pipelined datapath?
\ifnum\Ans=1{{\color{red}3 NOPs for pipelined datapath with branch decision in MEM stage}}\fi
\end{tcolorbox}
\item Harware Solutions:
\begin{itemize}
\item Flush - clear instructions incorrectly fetched
    \item Stall - delay execution of instructions
\item Predict - assume branch {\tt taken} or {\tt not taken}  and flush incorrect instructions 
\item Delay decision - rearrange code to use branch delay slot
\end{itemize}
\end{itemize}
\end{frame}
%-----------------------------------------------------
\begin{frame}\frametitle{Resolving Control Hazards: Flushing}
\begin{itemize}
    \item \hl{Fetch instructions as \textbf{if} branch is \textbf{not taken}}
    \item After decision to branch made, \hl{flush} incorrectly fetched instructions
    
    \includegraphics[scale=0.25]{05-pipelining/figures/flush3instructions.png}
\end{itemize}

\end{frame}

\begin{frame}\frametitle{Flushing and its limitations}
\begin{itemize}
    \item How to flush?
\begin{enumerate}
    \item zero control signals
    \begin{itemize}
        \item going into EX/MEM
        \item going into ID/EX
    \end{itemize}
    
        \item \hl{zero all bits in IF/ID pipeline register}
    
\end{enumerate}
\begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
  colback=blue!5!white,colframe=blue!75!black,colbacktitle=blue!80!black,
  title=Think About It,fonttitle=\bfseries,
  boxed title style={size=small,colframe=red!50!black} ]
How is a flush different from stall?\\
\ifnum\Ans=1{\color{red}Stall disables writes to IF/ID, so instruction \textbf{can be executed later}. 

Flush clears IF/ID pipeline register so instruction can \textbf{never be executed again}.}\fi
  \end{tcolorbox}
  \item Limitations of flushing:
  \begin{itemize}
      \item reduces utilization of pipelined datapath
      \item worst case, \textbf{adds} three additional clock cycles for every branch
  \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]
\Title{Resolving Control Hazards: Improving Branching}
\begin{itemize}
\item Decide to branch as early as possible
\begin{itemize}
    \item Can't decide whether to branch or not until instruction has been
  read from memory
\end{itemize}
% \item \hl{\textbf{Stall}} instruction execution until decision to branch is made. 
\item Assume following hardware is \textit{now} in ID stage: 

\begin{multicols}{2}
\begin{itemize}
    \item test register contains 0
    \item sign extend immedaite
    \item shift left by 2 units
    \end{itemize}
\columnbreak    
\begin{itemize}
\item adder to compute branch target address
    \item update the PC
    \end{itemize}
\end{multicols}
\PHFigure{!}{2.5in}{1.2in}{ARMFigures/Fig0460m-crop.pdf}{Figure 4.60 modified{\footnote{Figure 4.60 has been modified to illustrate effect of branching in ID stage.}}}

%  \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
%   colback=blue!5!white,colframe=blue!75!black,colbacktitle=blue!80!black,
%   title=Think About It,fonttitle=\bfseries,
%   boxed title style={size=small,colframe=red!50!black} ]

% If branch taken, should instruction at byte address 44 be executed? \ifnum\Ans=1{\color{red}No.}\fi
% \end{tcolorbox}
% 	% \PHFigure{!}{2.2in}{0.8in}{05-pipelining/figures/resolving-ctrl-hazard-ldur}{Figure 4.30}
% % \begin{itemize}
% \item After moving Branch up to ID stage, instruction after branch 
% 	will still always execute.

	
%  \item How to handle this (possibly) errant instruction? \textbf{Flushing}
%  \item How? Zeroing all 32 bits of instruction in IF/ID register will flush ID 
%  stage

% % \item MIPS forces compiler to handle errant instruction

%   % Code rearrangement, NOP

%   % Bad choice because single cycle code won't work
  
% % \item Better choice: use Branch Flushing

% 	% Zeroing control bits of instruction in IF/ID register will flush ID 
% 	% Zeroing all 32 bits of instruction in IF/ID register will flush ID 
%  % stage
% % \end{itemize}
%     \item Limitation: \textbf{adds} only one additional clock cycle to all branches

\end{itemize}
\BNotes\ifnum\Notes=1
\begin{itemize}
\item The idea (which isn't quite correct) that we cn figure out whether or
  not we take the branch (or rather, what the correct next address should be)
  during the Instruction-Decode/Register-Fetch stage, and we delay loading
  the PC until we've made that decision.

  That's what the figure shows, but we can't really do this, since the
  conditional branch requires reading a register from the register file,
  and we'd have to wait an additional clock cycle for that to be read.
\item
Unconditional stalling means that every branch instruction adds two
clock cycles (or more if the pipeline is longer and the ambiguity
cannot be resolved in one clock cycle), which is usually unacceptable.
\end{itemize}
\fi\ENotes
\end{frame}

\begin{frame}[fragile]
\Title{Resolving Control Hazards: Branching in ID}
\begin{multicols}{2}
\begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
  colback=blue!5!white,colframe=blue!75!black,colbacktitle=blue!80!black,
  title=Think About It,fonttitle=\bfseries,
  boxed title style={size=small,colframe=red!50!black} ]

If branch taken, should instruction after branch be executed? \ifnum\Ans=1{\color{red}No.}\fi
\end{tcolorbox}

\columnbreak    
% \PHFigure{!}{2.5in}{0.7in}{ARMFigures/Fig0460m-crop.pdf}{Figure 4.60 modified{\footnote{Figure 4.60 has been modified to illustrate effect of branching in ID stage.}}}
\includegraphics[scale=0.3]{05-pipelining/figures/flushID.png}
 
\end{multicols}


	% \PHFigure{!}{2.2in}{0.8in}{05-pipelining/figures/resolving-ctrl-hazard-ldur}{Figure 4.30}
% \begin{itemize}
\begin{itemize}
\item After moving Branch up to ID stage, instruction after branch 
	will still always execute.
 \item How to handle this (possibly) errant instruction? 
 % \item How? Zeroing all 32 bits of instruction in IF/ID register will flush ID stage
\begin{itemize}
    \item MIPS forces compiler to handle errant instruction
    \begin{itemize}
        \item Code rearrangement
        \item NOP
    \end{itemize}
    \item ARM uses \textbf{flushing}

\end{itemize}

    \item Limitation: \textbf{adds} only one additional clock cycle to every branch

\end{itemize}
\BNotes\ifnum\Notes=1
\begin{itemize}
\item The idea (which isn't quite correct) that we cn figure out whether or
  not we take the branch (or rather, what the correct next address should be)
  during the Instruction-Decode/Register-Fetch stage, and we delay loading
  the PC until we've made that decision.

  That's what the figure shows, but we can't really do this, since the
  conditional branch requires reading a register from the register file,
  and we'd have to wait an additional clock cycle for that to be read.
\item
Unconditional stalling means that every branch instruction adds two
clock cycles (or more if the pipeline is longer and the ambiguity
cannot be resolved in one clock cycle), which is usually unacceptable.
\end{itemize}
\fi\ENotes
\end{frame}

% for comprehensive
\newpage
\begin{frame}[fragile]
\Title{Hardware for Branch Flushing}
	\PHFigure{!}{4.2in}{2.8in}{ARMFigures/Fig0463mod-crop}{Figure 4.63, corrected}

\BNotes\ifnum\Notes=1
\begin{itemize}
	\item The signal from Hazard Detection Unit to IF/ID is NOT a 
		load control.  Instead, it forces the load of a NOP.
	\item Thus, the branch is handled by loading a NOP instead of
		the actual instruction into the IF/ID and simultaneously
		loading the PC with the branch address.
\end{itemize}
\fi\ENotes
\end{frame}


\begin{frame}[fragile]
  \Title{Branch in ID: Issues}
Branch in ID stage with flushing correctly handles instruction after \texttt{CBZ}, but
  \begin{itemize}
	  \item needs extension to forwarding unit
   \item \textit{now} forward to ``=0'' unit, labeled ``='' in pipeline diagrams

  \item need stalls in some cases,  for \textbf{branch data hazards}
\begin{verbatim}
SUBI X1,X1,#1
CBZ X1,#100
\end{verbatim}
  \end{itemize}

%     \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
%   colback=blue!5!white,colframe=blue!75!black,colbacktitle=blue!80!black,
%   title=Think About It,fonttitle=\bfseries,
%   boxed title style={size=small,colframe=red!50!black} ]
%   Do we expect to take the branch or not?
  
%   {\color{red}Hard to answer for \texttt{if}-like statements, easier to answer for loops.}
% \end{tcolorbox}
\BNotes\ifnum\Notes=1
\begin{itemize}
	\item Also note that the = hardware is used to control the
		branch, and that the inputs to the = hardware really
		need data forwarding MUXes to avoid data hazards.
	\item This hardware has hazards that require stalls.
		The book briefly talks about this.

		A worse example is
\begin{verbatim}
LDUR X1, [X1,#200]
CBZ X1,#100
\end{verbatim}
The former requires a stall of one clock cycle before you can forward
from the pipeline registers, while the latter requires a stall for
two clock cycles.

The next two slides illustrate the problems.
\item The ``do we expect to take the branch or not'' seems hard to
  answer for \texttt{if} statements in C code, but if you have a loop
  it's clear that you're going to stall most of the time.  This leads
  us later to branch prediction.
\end{itemize}
\fi\ENotes
\end{frame}

\begin{frame}[fragile]
\Title{Branch in ID: Stalls, Forwards}
	\Figure{!}{1in}{0.8in}{Figs/IDstallARM}
	\bigskip
	\bigskip
	\Figure{!}{2in}{1.3in}{Figs/IDforwardARM}
\BNotes\ifnum\Notes=1
\begin{itemize}
\item The first case requires a stall, since data isn't ready in time
\item The second case requires new forwarding hardware
\end{itemize}
\fi\ENotes
\end{frame}

\begin{frame}[fragile]
\Title{Branch in ID: LDUR Stalls}
	\Figure{!}{1in}{0.8in}{Figs/IDstall2ARM}
	\bigskip
	\bigskip
	\Figure{!}{2in}{1.3in}{Figs/IDstall2aARM}
\BNotes\ifnum\Notes=1
\begin{itemize}
\item The first case requires a stall for 2 clock cycles
\item The second case requires a stall for 1 clock cycle
\end{itemize}
\fi\ENotes
\end{frame}

% for comprehensive
\newpage
\begin{frame}[fragile]\frametitle{Example: Forwarding and Stalling}

\begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
  colback=red!5!white,colframe=red!75!black,colbacktitle=red!80!black,
  title=Try this,fonttitle=\bfseries,
  boxed title style={size=small,colframe=red!50!black} ]

  \begin{multicols}{2}
      \begin{verbatim}
100 ADDI X1,XZR,#12
104 LDUR X2,[X1,#12]
108 ADD X1,X1,X1
112 CBNZ X1,#12
116 ADD X1,X2,X3
\end{verbatim}
\columnbreak
 \Figure{!}{2.2in}{1.5in}{Figs/pipeex6}
  \end{multicols}
{\footnotesize
Assume the pipeline can do the following:
\begin{multicols}{2}
\begin{itemize}
\item branch in ID
\item branch flushing for errant instructions
\item forwarding to EX stage, 
\end{itemize}
\columnbreak
\begin{itemize}
\item forwarding to ``=" unit, 
\item load-use stalls
\item branch data stalls
\end{itemize}
    
\end{multicols}
}
\end{tcolorbox}


\end{frame}
%-----------------------------------------------------
\ifnum\Ans=1{
\begin{frame}[fragile]\frametitle{Solution: Forwarding and Stalling}

\begin{figure}[H]
\centering
	{\includegraphics[width=0.75\textwidth]{05-pipelining/figures/forwarding-branching-ex-instruction-lines.png}}
%\caption{}\label{}
\end{figure}
\begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
  colback=blue!5!white,colframe=blue!75!black,colbacktitle=blue!80!black,
  title=Think About It,fonttitle=\bfseries,
  boxed title style={size=small,colframe=red!50!black} ]
Are there any load-use hazards? \\
{\color{red}No, load-use stalls in this sample code.}
\end{tcolorbox}
\end{frame}
}\fi


% \begin{itemize}
% \item After moving Branch up to ID stage, instruction after branch 
% 	will still always execute.

% 	How to handle this (possibly) errant instruction?

% \item MIPS forces compiler to handle errant instruction

%   Code rearrangement, NOP

%   Bad choice because single cycle code won't work
  
% \item Better choice: use Branch Flushing

% 	% Zeroing control bits of instruction in IF/ID register will flush ID 
% 	Zeroing all 32 bits of instruction in IF/ID register will flush ID 
%  stage
% \end{itemize}

%%%% probably not correct information
% % \begin{frame}[fragile]
% \Title{Resolving Control Hazards: Stalling}
% \begin{itemize}
% \item Decide to branch as early as possible
% \begin{itemize}
%     \item Can't decide whether to branch or not until instruction has been
%   read from memory
% \end{itemize}
% \item \hl{\textbf{Stall}} instruction execution until decision to branch is made. Assume following hardware is \textit{now} in ID stage: 

% \begin{multicols}{2}
% \begin{itemize}
%     \item test register contains 0
%     \item sign extend immedaite
%     \item shift left by 2 units
%     \end{itemize}
% \columnbreak    
% \begin{itemize}
% \item adder to compute branch target address
%     \item update the PC
%     \end{itemize}
% \end{multicols}
% 	\PHFigure{!}{2.2in}{0.8in}{05-pipelining/figures/resolving-ctrl-hazard-ldur}{Figure 4.30}

%     \item Limitation: \textbf{adds} one additional clock cycle to all branches

% \end{itemize}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item The idea (which isn't quite correct) that we cn figure out whether or
%   not we take the branch (or rather, what the correct next address should be)
%   during the Instruction-Decode/Register-Fetch stage, and we delay loading
%   the PC until we've made that decision.

%   That's what the figure shows, but we can't really do this, since the
%   conditional branch requires reading a register from the register file,
%   and we'd have to wait an additional clock cycle for that to be read.
% \item
% Unconditional stalling means that every branch instruction adds two
% clock cycles (or more if the pipeline is longer and the ambiguity
% cannot be resolved in one clock cycle), which is usually unacceptable.
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}\frametitle{Resolving Control Hazards: Stalling}
% \begin{itemize}
%     \item 
% Suppose the hardware can test the register, determine the branch target address and update the PC in the second stage ID. 
% \begin{figure}[H]
% \centering
% 	{\includegraphics[scale=0.2]{figures/cbz-control-hazard}}
% \end{figure}
% The instruction to be executed if the branch is not taken stalls for one clock cycle.
% \end{itemize}

% \end{frame}
%-----------------------------------------------------
% \begin{frame}\frametitle{Resolving Control Hazards: Branch Prediction}
% If we cannot resolve the branch in the second stage, the pipeline has an even larger slow down.

% \hfill\break
% Another solution is the pipeline \textbf{predicts} the conditional branch is \textbf{not} taken.
% \begin{itemize}
% \item If the pipeline is correct, it proceeds at full speed.
% \item If the pipeline is incorrect, it stalls.
% \end{itemize}
% The pipeline can also predict some conditional branches are taken, while others are not. For example, branching back to an earlier address is usually taken.
% \hfill\break

% Dynamic prediction uses recent past behaviour to predict branching.
% \end{frame}

%-----------------------------------------------------
% \begin{frame}[fragile]\frametitle{Control Hazard: Delayed Decision}
% Delayed decision rearranges the code to move an instruction not affect by the branch to hide the branch delay. The rearrangement is done by the assembler, hidden from the programmer.
% \begin{verbatim}
% ADD X4, X5, X6
% CBZ X1, 40
% ORR X7, X8, X9 //stall
% \end{verbatim}
% \begin{verbatim}
% CBZ X1, 40
% ADD X4, X5, X6 // move ADD to after CBZ
% ORR X7, X8, X9
% \end{verbatim} 
% \end{frame}



% \begin{frame}[fragile]
%   \STitle{Control Hazards}
% 	\PHFigure{!}{4in}{3in}{ARMFigures/Fig0460}{Figure 4.60}

% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item The point being that if we take the branch at line 40, then we load instructions 44,48,52 before we actually take the branch.  The goal is for the pipelined code to execute as if it were run on the single cycle datapath.
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
% \Title{Overview on Resolving Control Hazards}
% \begin{itemize}
% \item Can't decide whether to branch or not until instruction has been
%   read from memory.
% \item First solution: \hl{\textbf{stall}}

% Assume we have the hardware to test the register, determine the branch target address and update the PC in the second stage ID

% 	\PHFigure{!}{3in}{1in}{05-pipelining/figures/resolving-ctrl-hazard-ldur}{Figure 4.30}


%     \begin{itemize}
%     \item Branch Stalling: adds one additional clock cycle to all branches
%       \end{itemize}
% \end{itemize}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item The idea (which isn't quite correct) that we cn figure out whether or
%   not we take the branch (or rather, what the correct next address should be)
%   during the Instruction-Decode/Register-Fetch stage, and we delay loading
%   the PC until we've made that decision.

%   That's what the figure shows, but we can't really do this, since the
%   conditional branch requires reading a register from the register file,
%   and we'd have to wait an additional clock cycle for that to be read.
% \item
% Unconditional stalling means that every branch instruction adds two
% clock cycles (or more if the pipeline is longer and the ambiguity
% cannot be resolved in one clock cycle), which is usually unacceptable.
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \iffalse
% \begin{frame}[fragile]
% \Title{Better Solutions}
% \begin{itemize}
% \item Assume branch failure, stall only on success

% 	\Figure{!}{3.75in}{4in}{PHALL/F0605}
% \item Even better solution: dynamic prediction (based on past history)
% \item Another approach: delayed decision (always execute next
% instruction after branch)
% \end{itemize}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item
% A variety of branch predition methods have been proposed; the more
% complicated ones start to add hardware overhead.

% \item
% Delayed prediction is what is actually used by the real MIPS
% architecture; the compiler moves instructions around to try to fill
% that slot just after the branch, and typically can fill about half of
% them. 

% \item In the example, since the {\tt add} and {\tt beq} are independent,
% we could swap the {\tt beq} first and the {\tt add} instructions.
% This is hidden from the assembly programmer.

% \end{itemize}
% \fi\ENotes
% \end{frame}
% \fi

\begin{frame}[fragile]
  \Title{Hardware Assumes Branch {\bf Not} Taken}
  \begin{itemize}
  \item As designed, hardware assumes branch is {\bf not} taken

    \hl{always} fetches instruction after branch
  \item Maybe okay for \texttt{if} statements, but what about loops?
{\footnotesize
\begin{verbatim}
  100: ADDI X1,XZR,#6
  104: LDUR X2,[X3,#0] ; branch to here
  108: ADD X10,X10,X2  ; our sum is stored in X10
  112: ADDI X3,X3,#8
  116: SUBI X1,X1,#1
  120: CBNZ X1,#-4
  124: ADD X5,X6,X7    ; instruction after branch
\end{verbatim}
}
\item Line 124 gets fetched (``guessed'') when executing line 120 in ID stage
\item \textbf{Flush if branch taken}
  \end{itemize}
 \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
  colback=blue!5!white,colframe=blue!75!black,colbacktitle=blue!80!black,
  title=Think About It,fonttitle=\bfseries,
  boxed title style={size=small,colframe=red!50!black} ]
How many times is ``guess'' correct? \ifnum\Ans=1{\color{red}1}\fi

How many times in "guess" incorrect? \ifnum\Ans=1{\color{red}5}\fi

How many flushes? \ifnum\Ans=1{\color{red}5}\fi
  \end{tcolorbox}


  \BNotes\ifnum\Notes=1
  \begin{itemize}
    \item The answer to the question is that the first 5 times through the loop, we ``guess'' wrong (i.e., lines 124 gets flushed five times); the last time we guess ``right'' (i.e., line 124 gets executed).
  \end{itemize}
  \fi\ENotes
\end{frame}

\begin{frame}[fragile]
  \Title{Hardware Assume Branch \textbf{Taken}}
  \begin{itemize}
  \item Currently: hardware shown flushes instruction after branch

  \item Instead: \hl{always} fetch branch target address

    % Flush if branch \textbf{NOT taken}
    
  \item Hardware needs to store a lookup table (branch destination address table)
    \begin{itemize}
    \item Address of {\tt CBZ} instruction
    \item Destination of {\tt CBZ} instruction if branch taken
    \end{itemize}
  \item When executing branch:
  \begin{itemize}
      \item automatically fetch branch destination address as next instruction
\item   \textbf{Flush if branch not taken}
  \end{itemize}
 \end{itemize}
  \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
  colback=blue!5!white,colframe=blue!75!black,colbacktitle=blue!80!black,
  title=Think About It,fonttitle=\bfseries,
  boxed title style={size=small,colframe=red!50!black} ]
 Should hardware be {\tt branch taken} or {\tt branch not taken}?
 
  Do we expect to take the branch or not?
  
  {\color{red}Hard to answer for \texttt{if}-like statements, easier to answer for loops.}
\end{tcolorbox}

\BNotes\ifnum\Notes=1
\begin{itemize}
\item Go back a slide to code example, show that it loads lines 104, ``guessing'' right 5 times, and wrong once, so line 124 is only flushed once.

  This assumes table is constructed when code loaded into memory; if table not constructed until run time, then very first time through loop will guess lines 124
  \item This is better for loops, but if you have conditionals for special
  cases that rarely occur then poor performance
\end{itemize}
\fi\ENotes
\end{frame}


\begin{frame}[fragile]
  \Title{Hardware for Branch Prediction}
  \PHFigure{!}{5in}{3in}{ARMFigures/branchTabDP}{Figure 4.63, modified, }
\BNotes\ifnum\Notes=1
\begin{itemize}
\item The brown stuff in the lower left is the new stuff.
\item Lots of details missing, but here's a summary:
  \begin{itemize}
  \item Entries in Branch Dest Addr Table include

    address of branch instructions;
    destination address; any branch prediction bits
    (discussed on next few slides).
    
  \item The table takes the PC of the branch instruction, which is stored in the IF/ID pipeline registers, as input; if the PC corresponds to a branch,
    then based on prediction method, the branch destination stored in the
    table is used to update the PC.
  \item Missing from slide:

    How to fill in table entries

    If the branch isn't taken, then IF/ID.PC+4 is loaded into the PC.

    How to decide whether or not to use address in table as next PC value
    and choosing the input for the new MUX (ie, the select lines on the MUXes).
    \item The timing is a bit tricky: in CC1, the branch is loaded.
	    Then in CC2, we detect if the IF/ID instruction is a branch, and if
		  so, use the IF/ID.PC to read the address of the next
		  instruction from the Branch Dest Addr Table.

		  However, also in CC2, if we decide (towards the end of the
		  clock cycle) that the branch is NOT taken, then rather than
		  store the instruction at the branch destination into the
		  IF/ID registers, we'll store a NOP.  At the same time,
		  we need to load IF/ID.PC+4 into the PC.


  \end{itemize}
\end{itemize}
\fi\ENotes
\end{frame}

\ifnum\slides=1
\begin{frame}[fragile]
  \Title{Branch Taken Prediction: Just Passing the Buck?}
  \begin{itemize}
  \item Loading branch destination helps loops,

    but what about \texttt{if} statements?
\item Example: sum via linked list
    \begin{center}
      \includegraphics[height=0.8in]{05-pipelining/figures/llist0data.png}
      \end{center}
\begin{verbatim}
  100: ADDI X1,XZR,#0
  104: LDUR X2,[X3,#8] ; branch to here
  108:                 ; coming soon!
  112: LDUR X4,[X2,#0] ; load data
  116: ADD X1,X1,X4    ; add to sum
  120: LDUR X3,[X3,#0] ; next in list
  124: CBNZ X3,#-5
\end{verbatim}
\item X3 points to element in list

  Element has next ptr and ``subpointer'' (sum subpointer)
  \end{itemize}
\BNotes\ifnum\Notes=1
\begin{itemize}
\item X3 point to a linked list; the first element is the ``next'' pointer, the second element is a pointer to ``stuff''
\item We want to sum the ``stuff''
  \item We left a blank line to be filled in on the next slide
\end{itemize}
\fi\ENotes
\end{frame}
\fi

\begin{frame}[fragile]
  \STitle{\texttt{Branch Taken Prediction}: Just Passing the Buck?}
  \begin{itemize}
  \item Loading branch destination helps loops, but what about \texttt{if} statements? consider example: sum via linked list
\item X3 points to element in list, element has \texttt{nextptr} and {\tt data}
    \begin{center}
      \includegraphics[height=0.5in]{05-pipelining/figures/llist0data.png}
      \end{center}
      {\footnotesize
\begin{verbatim}
  100: ADDI X1,XZR,#0
  104: LDUR X2,[X3,#8] ; branch to here
  108: CBZ X2,#3       ; skip to 120 if null ptr
  112: LDUR X4,[X2,#0] ; load data
  116: ADD X1,X1,X4    ; add to sum
  120: LDUR X3,[X3,#0] ; next in list
  124: CBNZ X3,#-5
\end{verbatim}
}
  \end{itemize}
 \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
  colback=blue!5!white,colframe=blue!75!black,colbacktitle=blue!80!black,
  title=Think About It,fonttitle=\bfseries,
  boxed title style={size=small,colframe=red!50!black} ]
  CBNZ will benefit from \textbf{``branch taken''}

  Assuming null ptrs are rare, CBZ will benefit from ``branch not taken''

  \hl{Limitation: hard to decide if branch taken or branch not taken}
\end{tcolorbox}

  
\BNotes\ifnum\Notes=1
\begin{itemize}
\item The problem is some of ``stuff'' is ``null'',  thus line 108
  \item The real point is: some conditionals are usually taken, some are usually not taken, so either choice (branch taken, branch not taken) has many bad cases
\end{itemize}
\fi\ENotes
\end{frame}

\begin{frame}[fragile]
  \Title{Dynamic Branch Prediction: 1-Bit}
\begin{itemize}
  \item Cost of mispredicting branch is high
  \item Use hardware to predict if branch is taken

    1-bit prediction: just remember what happened last time branch encountered
  \item update branch destination address table with {\tt 1-bit branch taken}
    \begin{itemize}
    % \item Address of {\tt CBZ} instruction
    % \item Destination of {\tt CBZ} instruction if branch taken
    \item set to 1, if branch was taken last time this branch instruction was executed 
    \end{itemize}

    \begin{center}
    {\tiny
	\begin{tabular}{c|c|c}
Instruction address & Branch Target Address &  Branch Taken (one-bit) \\\hline
0x...              & 0x... & 1 \\
\vdots & \vdots \\
\end{tabular}}
\end{center}
% The ``Branch Taken" prediction bit kept in the Branch Destination Address Table is initialized to 0 or 1, and predicts the next branch. 
{\footnotesize {\tt Branch Taken} bit is inverted if the prediction is wrong.}
  \item If \textbf{branch NOT taken} last time the branch instruction was executed
$\rightarrow$    \texttt{load PC+4}
  \item If \textbf{branch taken} last time the branch instruction was executed
$\rightarrow$  \texttt{load branch target address}
% rather than PC+4
\item In both cases, flush instruction in IF stage if ``wrong''
  \end{itemize}
  \BNotes\ifnum\Notes=1
  \begin{itemize}
  \item ``Cost of branch misprediction high''--in our toy datapath, only one clock cycle, but in real computer, misprediction cost many clock cycles
  \item 1-bit branch prediction handles cases of ``usually'' taken and
    usually ``not taken''.  With a ``gotcha'' seen on the next slide.
\end{itemize}
\fi\ENotes
\end{frame}

\begin{frame}[fragile]
  \Title{Dynamic Branch Prediction: 2-Bit}
\begin{itemize}
\item 2-bit prediction only changes ``decision'' if wrong twice in a row
\end{itemize}
	{\includegraphics[width=0.9\textwidth]{05-pipelining/figures/2-bit-branch-pred-statename.png}}
 % {Figure 4.62}
\BNotes\ifnum\Notes=1
\begin{itemize}
\item 2-bit prediction avoids being wrong twice when encountering a loop.

  The next slide gives an example, but go over it now a bit

\item The book briefly mentions more elaborate global branch prediction
  schemes.
\item Note that most of your gains come from 1-bit prediction
\end{itemize}
\fi\ENotes
\end{frame}

\begin{frame}[fragile]
  \Title{Branch Prediction Example}
\begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
  colback=red!5!white,colframe=red!75!black,colbacktitle=red!80!black,
  title=Try this,fonttitle=\bfseries,
  boxed title style={size=small,colframe=red!50!black} ]  
\begin{verbatim}
  100 ADDI X4, X31, #6
  104 LDUR X1, [X2,#20]  ; Branch to here
  108 ADDI X1, X1, #4
  112 STUR X1, [X2,#20]
  116 ADDI X2, X2, #8
  120 SUBI X4, X4, #1
  124 CBNZ X4, #-5
  128 ADD X1,X2,X3       ; Instruction after the branch
\end{verbatim}
How many correct/incorrect branch destinations?
\begin{itemize}
\item Assume branch not taken
\item Assume branch taken
\item 1-bit branch prediction
  \item 2-bit branch prediction
\end{itemize}
\end{tcolorbox}
\BNotes\ifnum\Notes=1
Do the analysis in how long the code takes to run.
Note the load-use stall and the branch data hazard stall
\begin{itemize}
\item Assume not take: 1 correct, 5 incorrect

\item Assume branch taken: 5 correct, 1 incorrect
\item 1-bit branch prediction: Assume that predictor initially guessing "not taken"

	Then 4 correct, 2 incorrect.  Note that predictor ends up assuming "not taken" at the end

\item 2-bit branch prediction: 

  Go over the flow chart on this example, labeling states 00,01,10,11 clockwise from upper left

	Assume initially in state 01.  Then 5 correct, 1 incorrect.

		Redo from initial states 10 and 11.  You'll get more incorrect, but always
		end up in state 01.
\item The ``assume branch taken'' looks good in this case, but would perform less well on if-statements.
\end{itemize}
\fi\ENotes
\end{frame}

\ifnum\Ans=1{
\begin{frame}[fragile]\frametitle{Solution: Branch Prediction Example}
{\tiny
\begin{verbatim}
  100 ADDI X4, X31, #6
  104 LDUR X1, [X2,#20]  ; branch to here
  108 ADDI X1, X1, #4    ; load-use stall
  112 STUR X1, [X2,#20]
  116 ADDI X2, X2, #8
  120 SUBI X4, X4, #1    ; decrement counter
  124 CBNZ X4, #-5       ; branch data stall
  128 ADD X1,X2,X3       
\end{verbatim}
}
{\tiny
\begin{center}
	\begin{tabular}{c|cccccc}
Iteration &  1 (X4=5) & 2 (X4=4) & 3 (X4=3) & 4 (X4=2) & 5 (X4=1) & 6 (X4=0) \\\hline
\makecell{Actual\\Branching} & Yes & Yes & Yes & Yes & Yes & No\\ \hline
\noalign{\global\arrayrulewidth=0.5mm} \arrayrulecolor{orange}
\hline
\makecell{Prediction: \\ Branch \textbf{Not} \textbf{Taken} (PC+4)} & No & No & No & No & No & No \\ \hline
\makecell{Correct \\or Incorrect} & Incorrect & Incorrect & Incorrect & Incorrect & Incorrect & Correct \\ \hline
\noalign{\global\arrayrulewidth=0.5mm} \arrayrulecolor{green}
\hline
\makecell{Prediction: \\ Branch \textbf{Taken} (branch target addr)} & Yes & Yes & Yes & Yes & Yes & Yes \\ \hline
\makecell{Correct \\or Incorrect} & Correct & Correct & Correct & Correct & Correct & Incorrect \\ \hline
\noalign{\global\arrayrulewidth=0.5mm} \arrayrulecolor{blue}
\hline
\makecell{Prediction: \\ 1-bit Branch Predict=0} & No (0 $\rightarrow$ 1) & Yes (1) & Yes (1) & Yes (1) & Yes (1) & Yes ( 1 $\rightarrow$ 0) \\ \hline
\makecell{Correct \\or Incorrect} & Incorrect & Correct & Correct & Correct & Correct & Incorrect \\ \hline
\noalign{\global\arrayrulewidth=0.5mm} \arrayrulecolor{red}
\hline
\makecell{Prediction: \\ 1-bit Branch Predict=1} & Yes (1) & Yes (1)  & Yes (1) & Yes (1) & Yes (1) & Yes ( 1 $\rightarrow$ 0) \\ \hline
\makecell{Correct \\or Incorrect} & Correct & Correct & Correct & Correct & Correct & Incorrect \\ \hline

\end{tabular}
\end{center}
}
\end{frame}
\begin{frame}[fragile]\frametitle{Solution: Branch Prediction Example}
{\tiny
\begin{verbatim}
  100 ADDI X4, X31, #6
  104 LDUR X1, [X2,#20]  ; branch to here
  108 ADDI X1, X1, #4    ; load-use stall
  112 STUR X1, [X2,#20]
  116 ADDI X2, X2, #8
  120 SUBI X4, X4, #1    ; decrement counter
  124 CBNZ X4, #-5       ; branch data stall
  128 ADD X1,X2,X3       
\end{verbatim}
}
{\tiny
\begin{center}
	\begin{tabular}{c|cccccc}
Iteration &  1 (X4=5) & 2 (X4=4) & 3 (X4=3) & 4 (X4=2) & 5 (X4=1) & 6 (X4=0) \\\hline
\makecell{Actual\\Branching} & Yes & Yes & Yes & Yes & Yes & No\\ \hline
\noalign{\global\arrayrulewidth=0.5mm} \arrayrulecolor{orange}
\hline
% \makecell{Prediction: \\ Branch \textbf{Not} \textbf{Taken} (PC+4)} & No & No & No & No & No & No \\ \hline
% \makecell{Correct \\or Incorrect} & Incorrect & Incorrect & Incorrect & Incorrect & Incorrect & Correct \\ \hline
% \noalign{\global\arrayrulewidth=0.5mm} \arrayrulecolor{green}
% \hline
% \makecell{Prediction: \\ Branch \textbf{Taken} (branch target addr)} & Yes & Yes & Yes & Yes & Yes & Yes \\ \hline
% \makecell{Correct \\or Incorrect} & Correct & Correct & Correct & Correct & Correct & Incorrect \\ \hline
% \noalign{\global\arrayrulewidth=0.5mm} \arrayrulecolor{blue}
\hline
\makecell{Prediction: \\ 1-bit Branch Predict=0} & No (0 $\rightarrow$ 1) & Yes (1) & Yes (1) & Yes (1) & Yes (1) & Yes ( 1 $\rightarrow$ 0) \\ \hline
\makecell{Correct \\or Incorrect} & Incorrect & Correct & Correct & Correct & Correct & Incorrect \\ \hline
\noalign{\global\arrayrulewidth=0.5mm} \arrayrulecolor{red}
\hline
\makecell{Prediction: \\ 1-bit Branch Predict=1} & Yes (1) & Yes (1)  & Yes (1) & Yes (1) & Yes (1) & Yes ( 1 $\rightarrow$ 0) \\ \hline
\makecell{Correct \\or Incorrect} & Correct & Correct & Correct & Correct & Correct & Incorrect \\ \hline

\end{tabular}
\end{center}
}
\end{frame}
}\fi
%%%%%%%these two slides do not have the same code as the example: update for the future
% \begin{frame}[fragile]
%   \Title{1-Bit Branch Prediction ``Wrong Twice''}
%  In loops, 1-bit branch prediction can be wrong first time through, and wrong last time through
% {\footnotesize  
% \begin{multicols}{2}
% \begin{verbatim}
%   100: ADDI X1,XZR,#6
%   104: LDUR X2,[X3,#0]
%   108: ADD X10,X10,X2
%   112: ADDI X3,X3,#8
%   116: SUBI X1,X1,#1
%   120: CBNZ X1,#-4
%   124: ADD X5,X6,X7 
% \end{verbatim}

%     \columnbreak
%    {\footnotesize
% 	\begin{tabular}{c|c|c}
% Instruction & Destination &  Branch \\
% address & address & Taken (1-bit)\\\hline
% 120              & 104 & 1 \\
% \end{tabular}
% } 
% \end{multicols}
% }
% {\footnotesize
% \begin{tabular}{cc|ccc}
% Iteration & \makecell{Actual\\Branching} & \makecell{One Bit \\Prediction} & \makecell{Prediction\\Branching} &  \makecell{Correct or\\ Incorrect} \\\hline
% 1 (X1=5)  & Yes & 1 & Yes & Correct\\ \hline
% 2 (X1=4)  & Yes & 1 & Yes & Correct \\ \hline
% 3 (X1=3)  & Yes & 1 & Yes & Correct \\ \hline
% 4 (X1=2)  & Yes & 1 & Yes & Correct \\ \hline
% 5 (X1=1) & Yes & 1 & Yes & Correct\\ \hline
% 6 (X1=0) & No & 1 $\rightarrow$ 0 & Yes $\rightarrow$ No & Incorrect \\ \hline
% \end{tabular}}

% {\footnotesize Next time this code segment is repeated, the branch prediction will be wrong twice}

%   \BNotes\ifnum\Notes=1
%   \begin{itemize}
%   \item This is the original code that guessing ``branch taken'' was only
%     wrong once through loop (last time).

%     With 1-bit branch prediction, wrong first time and last time through loop

%     \item This is motivation for 2-bit branch prediction
%     \end{itemize}
%   \fi\ENotes
% \end{frame}


% \begin{frame}[fragile]
%   \Title{1-Bit Branch Prediction ``Wrong Twice''}
%  In loops, 1-bit branch prediction can be wrong first time through, and wrong last time through
% {\footnotesize  
% \begin{multicols}{2}
% \begin{verbatim}
%   100: ADDI X1,XZR,#6
%   104: LDUR X2,[X3,#0]
%   108: ADD X10,X10,X2
%   112: ADDI X3,X3,#8
%   116: SUBI X1,X1,#1
%   120: CBNZ X1,#-4
%   124: ADD X5,X6,X7 
% \end{verbatim}

%     \columnbreak
%    {\footnotesize
% 	\begin{tabular}{c|c|c}
% Instruction & Destination &  Branch \\
% address & address & Taken (1-bit)\\\hline
% 120              & 104 & 0 \\
% \end{tabular}
% } 
% \end{multicols}
% }
% {\footnotesize
% \begin{tabular}{cc|ccc}
% Iteration & \makecell{Actual\\Branching} & \makecell{One Bit \\Prediction} & \makecell{Prediction\\Branching} &  \makecell{Correct or\\ Incorrect} \\\hline
% 1 (X1=5)  & Yes & 0 & No & Incorrect\\ \hline
% 2 (X1=4)  & Yes & 1 & Yes & Correct \\ \hline
% 3 (X1=3)  & Yes & 1 & Yes & Correct \\ \hline
% 4 (X1=2)  & Yes & 1 & Yes & Correct \\ \hline
% 5 (X1=1) & Yes & 1 & Yes & Correct\\ \hline
% 6 (X1=0) & No & 1 $\rightarrow$ 0 & Yes $\rightarrow$ No & Incorrect \\ \hline
% \end{tabular}}

%   \BNotes\ifnum\Notes=1
%   \begin{itemize}
%   \item This is the original code that guessing ``branch taken'' was only
%     wrong once through loop (last time).

%     With 1-bit branch prediction, wrong first time and last time through loop

%     \item This is motivation for 2-bit branch prediction
%     \end{itemize}
%   \fi\ENotes
% \end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% end of comment to update these slides

% \begin{frame}[fragile]
%   \Title{1-Bit Branch Prediction ``Wrong Twice''}
%  In loops, 1-bit branch prediction can be wrong first time through, and wrong last time through
% {\footnotesize  
% \begin{multicols}{2}
% \begin{verbatim}
%   100: ADDI X1,XZR,#6
%   104: LDUR X2,[X3,#0]
%   108: ADD X10,X10,X2
%   112: ADDI X3,X3,#8
%   116: SUBI X1,X1,#1
%   120: CBNZ X1,#-4
%   124: ADD X5,X6,X7 
% \end{verbatim}

%     \columnbreak
%    {\footnotesize
% 	\begin{tabular}{c|c|c}
% Instruction & Destination &  Branch \\
% address & address & Taken (1-bit)\\\hline
% 120              & 104 & 1 \\
% \end{tabular}
% } 
% \end{multicols}
% }
% {\footnotesize
% \begin{tabular}{cc|ccc}
% Iteration & \makecell{Actual\\Branching} & \makecell{One Bit \\Prediction} & \makecell{Prediction\\Branching} &  \makecell{Correct or\\ Incorrect} \\\hline
% 1 (X1=5)  & Yes & 1 & Yes & Correct\\ \hline
% 2 (X1=4)  & Yes & 1 & Yes & Correct \\ \hline
% 3 (X1=3)  & Yes & 1 & Yes & Correct \\ \hline
% 4 (X1=2)  & Yes & 1 & Yes & Correct \\ \hline
% 5 (X1=1) & Yes & 1 & Yes & Correct\\ \hline
% 6 (X1=0) & No & 1 $\rightarrow$ 0 & Yes $\rightarrow$ No & Incorrect \\ \hline
% \end{tabular}}

% {\footnotesize Next time this code segment is repeated, the branch prediction will be wrong twice}

%   \BNotes\ifnum\Notes=1
%   \begin{itemize}
%   \item This is the original code that guessing ``branch taken'' was only
%     wrong once through loop (last time).

%     With 1-bit branch prediction, wrong first time and last time through loop

%     \item This is motivation for 2-bit branch prediction
%     \end{itemize}
%   \fi\ENotes
% \end{frame}


% \begin{frame}[fragile]
%   \STitle{Resolving Control Hazards: Branch Prediction}
%   \begin{itemize}
  
%   \item \textbf{Branch prediction}:  guess whether or not you'll take the branch,    load that address,
%   \item abort/flush instruction if wrong
%   \end{itemize}

%     % {\tiny
% % \begin{verbatim}
% % ADD X4, X5, X6
% % CBZ X1, 40
% % ORR X7, X8, X9 //stall
% % \end{verbatim}
% % \begin{verbatim}
% % CBZ X1, 40
% % ADD X4, X5, X6 // move ADD to after CBZ
% % ORR X7, X8, X9
% % \end{verbatim} 
% % }
%   \BNotes\ifnum\Notes=1
% \begin{itemize}
% 	\item We'll see more of the first two later
% 	\item The comment about MIPS is just a side note
% \end{itemize}
% \fi\ENotes
% \end{frame}

\begin{frame}[fragile]\frametitle{Branch Prediction Comparison: Two-Bit Prediction}
Assuming branch predictor is initially in state 01.
\begin{multicols}{2}
{\tiny
\begin{verbatim}
  100 ADDI X4, X31, #6
  104 LDUR X1, [X2,#20]  ; branch to here
  108 ADDI X1, X1, #4    ; load-use stall
  112 STUR X1, [X2,#20]
  116 ADDI X2, X2, #8
  120 SUBI X4, X4, #1    ; decrement counter
  124 CBNZ X4, #-5       ; branch data stall
  128 ADD X1,X2,X3       
\end{verbatim}
}
\columnbreak
\begin{figure}[H]
\centering
	{\includegraphics[width=0.35\textwidth]{05-pipelining/figures/2-bit-branch-pred-statename.png}}
%\caption{}\label{}
\end{figure}    
\end{multicols}

{\footnotesize
\begin{center}
	\begin{tabular}{c|cccccc}
Iteration &  1 (X4=5) & 2 (X4=4) & 3 (X4=3) & 4 (X4=2) & 5 (X4=1) & 6 (X4=0) \\\hline
\makecell{Actual\\Branching} & Yes & Yes & Yes & Yes & Yes & No\\ \hline
State      & 01 & 00 & 00 & 00 & 00 & 00 {$\rightarrow$ 01}\\ \hline
Prediction & Yes & Yes & Yes & Yes & Yes & Yes \\ \hline
\makecell{Correct \\or Incorrect} & Correct & Correct & Correct & Correct & Correct & Incorrect \\ \hline
\end{tabular}
\end{center}
}
\end{frame}

%-----------------------------------------------------
\begin{frame}[fragile]\frametitle{Branch Prediction Comparison: Two-Bit Prediction}
Assuming predictor two-bit state is initially 10.
\begin{multicols}{2}
{\tiny
\begin{verbatim}
  100 ADDI X4, X31, #6
  104 LDUR X1, [X2,#20]  ; branch to here
  108 ADDI X1, X1, #4    ; load-use stall
  112 STUR X1, [X2,#20]
  116 ADDI X2, X2, #8
  120 SUBI X4, X4, #1    ; decrement counter
  124 CBNZ X4, #-5       ; branch data stall
  128 ADD X1,X2,X3       
\end{verbatim}
}
\columnbreak
\begin{figure}[H]
\centering
	{\includegraphics[width=0.35\textwidth]{05-pipelining/figures/2-bit-branch-pred-statename.png}}
%\caption{}\label{}
\end{figure}    
\end{multicols}
{\footnotesize
\begin{center}
	\begin{tabular}{c|cccccc}
Iteration &  1 (X4=5) & 2 (X4=4) & 3 (X4=3) & 4 (X4=2) & 5 (X4=1) & 6 (X4=0) \\\hline
\makecell{Actual\\Branching} & Yes & Yes & Yes & Yes & Yes & No\\ \hline
State & 10 & 01 & 00 & 00 & 00 & 00 {$\rightarrow$ 01}\\ \hline
Prediction & No & Yes & Yes & Yes & Yes & Yes \\ \hline
\makecell{Correct \\or Incorrect} & Incorrect & Correct & Correct & Correct & Correct & Incorrect \\ \hline
\end{tabular}
\end{center}
}
\end{frame}

%-----------------------------------------------------
\begin{frame}[fragile]\frametitle{Branch Prediction Comparison: Two-Bit Prediction}
Assuming predictor two-bit state is initially 11.
\begin{multicols}{2}
{\tiny
\begin{verbatim}
  100 ADDI X4, X31, #6
  104 LDUR X1, [X2,#20]  ; branch to here
  108 ADDI X1, X1, #4    ; load-use stall
  112 STUR X1, [X2,#20]
  116 ADDI X2, X2, #8
  120 SUBI X4, X4, #1    ; decrement counter
  124 CBNZ X4, #-5       ; branch data stall
  128 ADD X1,X2,X3       
\end{verbatim}
}
\columnbreak
\begin{figure}[H]
\centering
	{\includegraphics[width=0.35\textwidth]{05-pipelining/figures/2-bit-branch-pred-statename}}
%\caption{}\label{}
\end{figure}    
\end{multicols}
{\footnotesize
\begin{center}
	\begin{tabular}{c|cccccc}
Iteration &  1 (X4=5) & 2 (X4=4) & 3 (X4=3) & 4 (X4=2) & 5 (X4=1) & 6 (X4=0) \\\hline
\makecell{Actual\\Branching} & Yes & Yes & Yes & Yes & Yes & No \\ \hline
State & 11 & 10 & 01 & 00 & 00 & 00 {$\rightarrow$ 01}\\ \hline
Prediction & No & No & Yes & Yes & Yes & Yes \\ \hline
\makecell{Correct \\or Incorrect} & Incorrect & Incorrect & Correct & Correct & Correct & Incorrect \\ \hline
\end{tabular}
\end{center}
}
\end{frame}

% \ifnum\Ans=1{
% \begin{frame}[fragile]\frametitle{Solution: Summary of Branch Prediction Example}
% {\tiny
% \begin{verbatim}
%   100 ADDI X4, X31, #6
%   104 LDUR X1, [X2,#20]  ; branch to here
%   108 ADDI X1, X1, #4    ; load-use stall
%   112 STUR X1, [X2,#20]
%   116 ADDI X2, X2, #8
%   120 SUBI X4, X4, #1    ; decrement counter
%   124 CBNZ X4, #-5       ; branch data stall
%   128 ADD X1,X2,X3       
% \end{verbatim}
% }
% {\tiny
% \begin{center}
% 	\begin{tabular}{c|cccccc}
% Iteration &  1 (X4=5) & 2 (X4=4) & 3 (X4=3) & 4 (X4=2) & 5 (X4=1) & 6 (X4=0) \\\hline
% \makecell{Actual\\Branching} & Yes & Yes & Yes & Yes & Yes & No\\ \hline
% \noalign{\global\arrayrulewidth=0.5mm} \arrayrulecolor{orange}
% \hline
% \makecell{Prediction: \\ Branch \textbf{Not} \textbf{Taken} (PC+4)} & No & No & No & No & No & No \\ \hline
% \makecell{Correct \\or Incorrect} & Incorrect & Incorrect & Incorrect & Incorrect & Incorrect & Correct \\ \hline
% \noalign{\global\arrayrulewidth=0.5mm} \arrayrulecolor{green}
% \hline
% \makecell{Prediction: \\ Branch \textbf{Taken} (branch target addr)} & Yes & Yes & Yes & Yes & Yes & Yes \\ \hline
% \makecell{Correct \\or Incorrect} & Correct & Correct & Correct & Correct & Correct & Incorrect \\ \hline
% \noalign{\global\arrayrulewidth=0.5mm} \arrayrulecolor{blue}
% \hline
% \makecell{Prediction: \\ 1-bit Branch Predict=0} & No & Yes (0 $\rightarrow$ 1) & Yes & Yes & Yes & Yes ( 1 $\rightarrow$ 0) \\ \hline
% \makecell{Correct \\or Incorrect} & Incorrect & Correct & Correct & Correct & Correct & Incorrect \\ \hline
% \noalign{\global\arrayrulewidth=0.5mm} \arrayrulecolor{red}
% \hline
% \makecell{Prediction: \\ 1-bit Branch Predict=1} & Yes & Yes  & Yes & Yes & Yes & Yes ( 1 $\rightarrow$ 0) \\ \hline
% \makecell{Correct \\or Incorrect} & Correct & Correct & Correct & Correct & Correct & Incorrect \\ \hline

% \end{tabular}
% \end{center}
% }
% \end{frame}
% }\fi
%-----------------------------------------------------

\begin{frame}[fragile]
\STitle{Branch Prediction Analysis}
{\footnotesize
    \begin{tabular}{l|c|c}
 & \multicolumn{2}{c}{Branch Prediction}\\
Next instruction & Number Correct & Number Incorrect\\
\hline\hline
Branch Not Taken (PC+4) & 1 & 5 \\\hline
Branch taken (Branch destination addr) & 5& 1\\\hline\hline
1-bit Branch Prediction (with bit=0) & 4 &2 \\\hline

1-bit Branch Prediction (with bit=1) & 5 & 1\\\hline
\hline
2-bit start at state 01 & 5  &1 \\\hline
2-bit start at state 10 & 4 & 2\\\hline
2-bit start at state 11 & 3 & 3 \\\hline
\end{tabular}
}
\bigskip
\bigskip

Limitations: unnecessary flushes
\end{frame}

\begin{frame}[fragile]
  \STitle{Resolving Control Hazards: Delayed Decision}
  \begin{itemize}
  
  \item \textbf{Delayed Decision}: Always execute the instruction after the branch
   
      \item Assume pipelined datapath implements \texttt{branch not taken} and there is \textbf{no flushing}
       \item Use code re-arrangement to move instructions before branch to immediately after the branch, this is the \textbf{branch
      delay slot}
      \item  The rearrangement is done by the assembler, hidden from the programmer
    \item Used by MIPS architecture
        \end{itemize}
\begin{multicols}{2}
ORIGINAL CODE    
{\footnotesize
\begin{verbatim}
ADD X4, X5, X6
CBZ X1, 40
ORR X7, X8, X9 //stall
\end{verbatim}
}

\columnbreak

REARRANGED CODE

use branch delay slot:

move {\tt ADD} to after {\tt CBZ}
{\footnotesize
\begin{verbatim}
CBZ X1, 40
ADD X4, X5, X6 
ORR X7, X8, X9
\end{verbatim} 
}
\end{multicols}
    

    % {\tiny
% \begin{verbatim}
% ADD X4, X5, X6
% CBZ X1, 40
% ORR X7, X8, X9 //stall
% \end{verbatim}
% \begin{verbatim}
% CBZ X1, 40
% ADD X4, X5, X6 // move ADD to after CBZ
% ORR X7, X8, X9
% \end{verbatim} 
% }
  \BNotes\ifnum\Notes=1
\begin{itemize}
	\item We'll see more of the first two later
	\item The comment about MIPS is just a side note
\end{itemize}
\fi\ENotes
\end{frame}


% \begin{frame}[fragile]\frametitle{Example: Execution Time}

% \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
%   colback=red!5!white,colframe=red!75!black,colbacktitle=red!80!black,
%   title=Try this,fonttitle=\bfseries,
%   boxed title style={size=small,colframe=red!50!black} ]  
%   What is the execution time of the code segment below on a pipelined datapath that is already running. 
% \begin{verbatim}
% ADDI X4, X31, #6   
% LDUR X1, [X2,#20]  
% ADDI X1, X1, #4   
% STUR X1, [X2,#20]  
% ADDI X2, X2, #8    
% SUBI X4, X4, #1    
% CBNZ X4, #-5      
% ADD X1,X2,X3       
% \end{verbatim}

% \textbf{Assume branch not taken}
% % 4cc (startup) + 
% % 1 + 6* (1 (load-use) + 1 (branch data stall) + 6 (instructions) + 1 (flush or execute instruction after last loop) )
% \end{tcolorbox}
% \end{frame}
% \ifnum\Ans=1{
% \begin{frame}[fragile]\frametitle{Solution: Execution Time}

% You \textbf{do not} need to add pipeline start-up time.
% \begin{verbatim}
% ADDI X4, X31, #6   // Initialize counter to 6
%                    // Instructions in the loop
% LDUR X1, [X2,#20]  // 1. Branch to here
% ADDI X1, X1, #4    // 2. Load-use stall
% STUR X1, [X2,#20]  // 3.
% ADDI X2, X2, #8    // 4.
% SUBI X4, X4, #1    // 5. Decrement counter
% CBNZ X4, #-5       // 6. Branch data stall, wait for X4
% ADD X1,X2,X3       
% \end{verbatim}
% Assume branch not taken:

% % 4cc (startup) + 
% 1 + 6* (1 (load-use) + 1 (branch data stall) + 6 (instructions) + 1 (flush or execute instruction after last loop) )

% Hint: If pipeline was not already running, add startup time of 4 cc. 
% \end{frame}
% }\fi

% \begin{frame}\frametitle{Average Performance of Pipelined Design}
% Assume the following mix of instructions:
% \begin{itemize}
% \item 22\% loads
% \item 11\% stores
% \item 49\% R-format
% \item 16\% conditional branches
% \item 2\% branch (unconditional branch)
% \end{itemize}
% \emph{Without} the pipeline start-up time of 4cc, the above instructions each take \textbf{1cc to finish}. However, some instructions have hazards:
% \begin{itemize}
% \item Load-use hazards: 2cc for half of all loads.
% \item Branch mispredicted: 2cc for a quarter of all conditional branches.
% \item Unconditional branches can store their destination address so they are always correctly predicted.
% \item Assume branching in the ID stage.
% \end{itemize}



% \end{frame}

% %-----------------------------------------------------
% \begin{frame}\frametitle{Clock Cycle per Instruction: Pipelined Desgin}
% The following table shows the instructions and their execution times, without the pipeline start-up time.

% \begin{center}
% 	\begin{tabular}{c|c|c}
% Instuction & Execution Time (clock cycles)  & Mix \\ \hline\hline
% loads      & 1(0.5)+2(0.5)=1.5 & 0.22 \\ \hline
% stores     & 1 & 0.11 \\ \hline
% R-format   & 1 & 0.49 \\ \hline
% CB-format   & 1(0.75) + 2(0.25)=1.25 & 0.16 \\ \hline
% B-format      & 1 & 0.02 \\ \hline
%  \end{tabular}
% \end{center}
% Weighted average CPI:
% $$(1.5)(0.22) + (1)(0.11) + (1)(0.49) + (1.25)(0.16)+(1)(0.02)=1.15$$
% This means with all the forwarding, stalling, flushing, hazard detection etc. implemented, instructions on average take \textbf{close to 1cc to finish}.

% \end{frame}

%%%%%%%%%%%%%%%%%%%% rearranged - end


% \begin{frame}[fragile]
% \Title{Branching Earlier in Pipeline}
% \begin{itemize}
% \item Branch success decided in MEM stage
% \item At this point instructions in IF, ID, EX stages must be flushed 
% \item Can move branch execution earlier, to ID stage
% \item Easy to move branch address calculation to ID stage
% \item Need to move equality test to ID stage, avoid ALU
% \end{itemize}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item Recall that the stages are IF, ID, EX, MEM, WB. Moving the branch
% 	execution from MEM to ID means moving branch address calculation from
% 	EX to ID. This is just a matter of moving the branch adder back, since
% 	its inputs are available earlier. If we want to do the equality test
% 	in the ID stage, we need to put the equality test (XOR all bits, AND
% 	the result) on the B output of the register file.
% \item Note that we should also perform jump in the ID stage.
% \item Also note that moving these two instructions up is very hard, and 
% 	shows why we prefer to have all instructions execute in 5 clock
% 	cycles.  Jump isn't so bad, but branch requires more forwarding
% 	hardware and stalling hardware.
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \iffalse
% % This was in the MIPS slides, since MIPS did this, but since we're
% % doing ARM, it didn't seem reasonable to include it
% \begin{frame}[fragile]
% \Title{Hardware to Execute Branch in ID Stage}
% 	\Figure{!}{6in}{4in}{PHALL/F0651a}

% 	Note: this figure is not in the text.
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item This is similar to Fig. 4.65, the final datapath for the chapter, but the
% 	IF.Flush signal of that datapath is missing.  Thus, this one branches earlier,
% 	but an errant instruction will complete its execution.

% 	This is what MIPS processor does
% \item Give gates for = unit

% \end{itemize}
% \fi\ENotes
% \end{frame}
% \fi

% % for comprehensive
% \newpage
% \begin{frame}[fragile]
% \STitle{Branch Hazards}
% 	\PHFigure{!}{2.5in}{1.5in}{ARMFigures/Fig0460m-crop.pdf}{Figure 4.60 modified{\footnote{this figure is not in the text. Figure 4.60 has been modified to illustrate effect of branching in ID stage.}}}

%  \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
%   colback=blue!5!white,colframe=blue!75!black,colbacktitle=blue!80!black,
%   title=Think About It,fonttitle=\bfseries,
%   boxed title style={size=small,colframe=red!50!black} ]

% If branch taken, should instruction at byte address 44 be executed? \ifnum\Ans=1{\color{red}No.}\fi
% \end{tcolorbox}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item Optional:
% A multicycle example, with branch hazards, is given Fig. 4.61.
% It shows only two CC's though.
% \item The answer to the question is ``no''
% \end{itemize}
% ~
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
% \Title{Branch Flushing}
% \begin{itemize}
% \item After moving Branch up to ID stage, instruction after branch 
% 	will still always execute.

% 	How to handle this (possibly) errant instruction?

% \item MIPS forces compiler to handle errant instruction

%   Code rearrangement, NOP

%   Bad choice because single cycle code won't work
  
% \item Better choice: use Branch Flushing

% 	% Zeroing control bits of instruction in IF/ID register will flush ID 
% 	Zeroing all 32 bits of instruction in IF/ID register will flush ID 
%  stage
% \end{itemize}

% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item As we saw
% 	earlier, zeroing the control bits in any pipeline register transforms
% 	the instruction being worked on into a {\tt nop}.
% \item To flush the instruction we don't want loaded, we will need
% 	the control unit for force a NOP instruction into the IF/ID registers.
% \item While MIPS forces the compiler to handle the instruction after the branch,
% 	ARM flushes it.  But with branch predition, the flushing
% 	shouldn't occur very often.
% \end{itemize}
% \fi\ENotes

% \end{frame}

% % for comprehensive
% \newpage
% \begin{frame}[fragile]
% \Title{Hardware for Branch Flushing}
% 	\PHFigure{!}{4.2in}{2.8in}{ARMFigures/Fig0463mod-crop}{Figure 4.63, corrected}

% \BNotes\ifnum\Notes=1
% \begin{itemize}
% 	\item The signal from Hazard Detection Unit to IF/ID is NOT a 
% 		load control.  Instead, it forces the load of a NOP.
% 	\item Thus, the branch is handled by loading a NOP instead of
% 		the actual instruction into the IF/ID and simultaneously
% 		loading the PC with the branch address.
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
%   \Title{Branch in ID issues}
% Branch in ID stage with flushing correctly handles instruction after \texttt{CBZ}, but
%   \begin{itemize}
% 	  \item Need forwarding hardware to ``=0'' unit, labeled ``='' in pipeline diagrams.
%   \item Need stalls in some cases
% \begin{verbatim}
% SUBI X1,X1,#1
% CBZ X1,#100
% \end{verbatim}
%   \end{itemize}

% %     \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
% %   colback=blue!5!white,colframe=blue!75!black,colbacktitle=blue!80!black,
% %   title=Think About It,fonttitle=\bfseries,
% %   boxed title style={size=small,colframe=red!50!black} ]
% %   Do we expect to take the branch or not?
  
% %   {\color{red}Hard to answer for \texttt{if}-like statements, easier to answer for loops.}
% % \end{tcolorbox}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% 	\item Also note that the = hardware is used to control the
% 		branch, and that the inputs to the = hardware really
% 		need data forwarding MUXes to avoid data hazards.
% 	\item This hardware has hazards that require stalls.
% 		The book briefly talks about this.

% 		A worse example is
% \begin{verbatim}
% LDUR X1, [X1,#200]
% CBZ X1,#100
% \end{verbatim}
% The former requires a stall of one clock cycle before you can forward
% from the pipeline registers, while the latter requires a stall for
% two clock cycles.

% The next two slides illustrate the problems.
% \item The ``do we expect to take the branch or not'' seems hard to
%   answer for \texttt{if} statements in C code, but if you have a loop
%   it's clear that you're going to stall most of the time.  This leads
%   us later to branch prediction.
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
% \Title{Branch in ID: Stalls, Forwards}
% 	\Figure{!}{1in}{0.8in}{Figs/IDstallARM}
% 	\bigskip
% 	\bigskip
% 	\Figure{!}{2in}{1.3in}{Figs/IDforwardARM}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item The first case requires a stall, since data isn't ready in time
% \item The second case requires new forwarding hardware
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
% \Title{Branch in ID: LDUR Stalls}
% 	\Figure{!}{1in}{0.8in}{Figs/IDstall2ARM}
% 	\bigskip
% 	\bigskip
% 	\Figure{!}{2in}{1.3in}{Figs/IDstall2aARM}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item The first case requires a stall for 2 clock cycles
% \item The second case requires a stall for 1 clock cycle
% \end{itemize}
% \fi\ENotes
% \end{frame}

% % for comprehensive
% \newpage
% \begin{frame}[fragile]\frametitle{Example: Forwarding and Stalling}

% \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
%   colback=red!5!white,colframe=red!75!black,colbacktitle=red!80!black,
%   title=Try this,fonttitle=\bfseries,
%   boxed title style={size=small,colframe=red!50!black} ]

%   \begin{multicols}{2}
%       \begin{verbatim}
% 100 ADDI X1,XZR,#12
% 104 LDUR X2,[X1,#12]
% 108 ADD X1,X1,X1
% 112 CBNZ X1,#12
% 116 ADD X1,X2,X3
% \end{verbatim}
% \columnbreak
%  \Figure{!}{2.2in}{1.5in}{Figs/pipeex6}
%   \end{multicols}

% Assume the pipeline can do the following:
% \begin{itemize}
% \item forwarding to EX stage, 
% \item forwarding to ``=" unit, 
% \item load-use stalls, branch in ID, branch flushing, branch data stalls.
% \end{itemize}

% \end{tcolorbox}


% \end{frame}
% %-----------------------------------------------------
% \ifnum\Ans=1{
% \begin{frame}[fragile]\frametitle{Solution: Forwarding and Stalling}

% \begin{figure}[H]
% \centering
% 	{\includegraphics[width=0.75\textwidth]{05-pipelining/figures/forwarding-branching-ex-instruction-lines.png}}
% %\caption{}\label{}
% \end{figure}
% \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
%   colback=blue!5!white,colframe=blue!75!black,colbacktitle=blue!80!black,
%   title=Think About It,fonttitle=\bfseries,
%   boxed title style={size=small,colframe=red!50!black} ]
% Are there any load-use hazards? \\
% {\color{red}No, load-use stalls in this sample code.}
% \end{tcolorbox}
% \end{frame}
% }\fi

% \begin{frame}[fragile]
% \STitle{Example}
%     \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
%   colback=red!5!white,colframe=red!75!black,colbacktitle=red!80!black,
%   title=Try this,fonttitle=\bfseries,
%   boxed title style={size=small,colframe=red!50!black} ]
% Assume pipelined datapath with forwarding to EX stage, forwarding to = unit in ID stage, load-use stalls, branch in ID,  branch flushing, branch data stalls.

% \begin{verbatim}
% 	100 ADDI X1,XZR,#12
% 	104 LDUR X2,[X1,#12]
% 	108 ADD  X1,X1,X1
% 	112 CBNZ X1,#12
% 	116 ADD  X1,X2,X3
% \end{verbatim}
%   \end{tcolorbox}
% \end{frame}

% \begin{frame}[fragile]
% 	\Title{Example}
% 	Assume forwarding to EX stage, forwarding to = unit, load-use stalls, branch in ID,  branch flushing, branch data stalls

% 	\Figure{!}{4in}{2.8in}{Figs/pipeex6}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item Do the following example, writing code on board or to the RIGHT of the
% 	pipelines on slide

% \begin{verbatim}
% 	100 ADDI X1,XZR,#12
% 	104 LDUR X2,[X1,#12]
% 	108 ADD  X1,X1,X1
% 	112 CBNZ X1,#12
% 	116 ADD  X1,X2,X3
% \end{verbatim}
% \item Draw instructions to left of pipeline they travel through
% 	\begin{itemize}
% \item 100 ADDI will be first row
% \item 104 LDUR will be second row, with forward from ADDI EX/MEM to ALU input
% \item 108 ADD will be in third row, with forward from ADDI MEM/WB to both ALU inputs
% \item 112 CBNZ will be in fourth row, but get stalled (write stall beneath it)
% \item 112 CBNZ will be in fifth row, with forward from EX/MEM of 108 ADD to = unit
% \item 116 ADD will be in sixth row, but get flushed (right flushed under it)
% \end{itemize}
% Be sure to note that there was NOT an example of a load-use stall here
% \end{itemize}
% \fi\ENotes
% \end{frame}

% %%%%%%%%%%%%%%%%% leav for lecture 4 on pipelines


% \begin{frame}[fragile]
%   \Title{Hardware Assumes Branch {\bf Not} Taken}
%   \begin{itemize}
%   \item As designed, hardware assumes branch is {\bf not} taken

%     Loads instruction after branch
%   \item Maybe okay for \texttt{if} statements, but what about loops?

% \begin{verbatim}
%   100: ADDI X1,XZR,#6
%   104: LDUR X2,[X3,#0] ; branch to here
%   108: ADD X10,X10,X2  ; our sum is stored in X10
%   112: ADDI X3,X3,#8
%   116: SUBI X1,X1,#1
%   120: CBNZ X1,#-4
%   124: ADD X5,X6,X7    ; instruction after branch
% \end{verbatim}
% Line 124 gets loaded (``guessed'') \\when executing line 120 in ID stage
% \item How many times is ``guess'' correct?
%   \end{itemize}
%   \BNotes\ifnum\Notes=1
%   \begin{itemize}
%     \item The answer to the question is that the first 5 times through the loop, we ``guess'' wrong (i.e., lines 124 gets flushed five times); the last time we guess ``right'' (i.e., line 124 gets executed).
%   \end{itemize}
%   \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
%   \Title{Assume Branch Taken}
%   \begin{itemize}
%   \item Hardware shown flushes instruction after branch

%   \item Could instead load instruction where the branch goes

%     Flush if branch NOT taken
    
%   \item Hardware needs to store
%     \begin{itemize}
%     \item Address of {\tt CBZ} instruction
%     \item Destination of {\tt CBZ} instruction if branch taken
%     \end{itemize}
%   \item When executing branch, automatically load destination
%     address as next instruction

%     Flush if branch not taken
%   \end{itemize}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item Go back a slide to code example, show that it loads lines 104, ``guessing'' right 5 times, and wrong once, so line 124 is only flushed once.

%   This assumes table is constructed when code loaded into memory; if table not constructed until run time, then very first time through loop will guess lines 124
%   \item This is better for loops, but if you have conditionals for special
%   cases that rarely occur then poor performance
% \end{itemize}
% \fi\ENotes
% \end{frame}


% \begin{frame}[fragile]
%   \Title{Hardware for Branch Prediction}
%   \PHFigure{!}{5in}{3in}{ARMFigures/branchTabDP}{Figure 4.63, modified, }
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item The brown stuff in the lower left is the new stuff.
% \item Lots of details missing, but here's a summary:
%   \begin{itemize}
%   \item Entries in Branch Dest Addr Table include

%     address of branch instructions;
%     destination address; any branch prediction bits
%     (discussed on next few slides).
    
%   \item The table takes the PC of the branch instruction, which is stored in the IF/ID pipeline registers, as input; if the PC corresponds to a branch,
%     then based on prediction method, the branch destination stored in the
%     table is used to update the PC.
%   \item Missing from slide:

%     How to fill in table entries

%     If the branch isn't taken, then IF/ID.PC+4 is loaded into the PC.

%     How to decide whether or not to use address in table as next PC value
%     and choosing the input for the new MUX (ie, the select lines on the MUXes).
%     \item The timing is a bit tricky: in CC1, the branch is loaded.
% 	    Then in CC2, we detect if the IF/ID instruction is a branch, and if
% 		  so, use the IF/ID.PC to read the address of the next
% 		  instruction from the Branch Dest Addr Table.

% 		  However, also in CC2, if we decide (towards the end of the
% 		  clock cycle) that the branch is NOT taken, then rather than
% 		  store the instruction at the branch destination into the
% 		  IF/ID registers, we'll store a NOP.  At the same time,
% 		  we need to load IF/ID.PC+4 into the PC.


%   \end{itemize}
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \ifnum\slides=1
% \begin{frame}[fragile]
%   \Title{Branch Taken Prediction: Just Passing the Buck?}
%   \begin{itemize}
%   \item Loading branch destination helps loops,

%     but what about \texttt{if} statements?
% \item Example: sum via linked list
%     \begin{center}
%       \includegraphics[height=0.8in]{Figs/llist0}
%       \end{center}
% \begin{verbatim}
%   100: ADDI X1,XZR,#0
%   104: LDUR X2,[X3,#8] ; branch to here
%   108:                 ; coming soon!
%   112: LDUR X4,[X2,#0] ; load data
%   116: ADD X1,X1,X4    ; add to sum
%   120: LDUR X3,[X3,#0] ; next in list
%   124: CBNZ X3,#-5
% \end{verbatim}
% \item X3 points to element in list

%   Element has next ptr and ``subpointer'' (sum subpointer)
%   \end{itemize}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item X3 point to a linked list; the first element is the ``next'' pointer, the second element is a pointer to ``stuff''
% \item We want to sum the ``stuff''
%   \item We left a blank line to be filled in on the next slide
% \end{itemize}
% \fi\ENotes
% \end{frame}
% \fi

% \begin{frame}[fragile]
%   \Title{Branch Taken Prediction: Just Passing the Buck?}
%   \begin{itemize}
%   \item Loading branch destination helps loops,

%     but what about \texttt{if} statements?
% \item Example: sum via linked list

%     \begin{center}
%       \includegraphics[height=1in]{Figs/llist}
%       \end{center}
% \begin{verbatim}
%   100: ADDI X1,XZR,#0
%   104: LDUR X2,[X3,#8] ; branch to here
%   108: CBZ X2,#3       ; skip to 120 if null ptr
%   112: LDUR X4,[X2,#0] ; load data
%   116: ADD X1,X1,X4    ; add to sum
%   120: LDUR X3,[X3,#0] ; next in list
%   124: CBNZ X3,#-5
% \end{verbatim}
% \item CBNZ wants ``branch taken''

%   CBZ wants ``branch not taken'' (assuming null ptr rare)
%   \end{itemize}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item The problem is some of ``stuff'' is ``null'',  thus line 108
%   \item The real point is: some conditionals are usually taken, some are usually not taken, so either choice (branch taken, branch not taken) has many bad cases
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
%   \Title{Dynamic Branch Prediction}
% \begin{itemize}
%   \item Cost of mispredicting branch is high
%   \item Use hardware to predict if branch is taken

%     1-bit prediction: just remember what happened last time branch encountered
%   \item Hardware needs to store
%     \begin{itemize}
%     \item Address of {\tt CBZ} instruction
%     \item Destination of {\tt CBZ} instruction if branch taken
%     \item Whether branch was taken last time executed
%     \end{itemize}
%   \item If branch NOT taken last time executed
%     load PC+4
%   \item If branch taken last time executed,
    
%     load destination address rather than PC+4
% \item In both cases, flush instruction if ``wrong''
%   \end{itemize}
%   \BNotes\ifnum\Notes=1
%   \begin{itemize}
%   \item ``Cost of branch misprediction high''--in our toy datapath, only one clock cycle, but in real computer, misprediction cost many clock cycles
%   \item 1-bit branch prediction handles cases of ``usually'' taken and
%     usually ``not taken''.  With a ``gotcha'' seen on the next slide.
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
%   \Title{1-Bit Branch Prediction ``Wrong Twice''}
%   \begin{itemize}
%   \item In loops, 1-bit branch prediction wrong first time through,

%     and wrong last time through
%   \begin{verbatim}
%   100: ADDI X1,XZR,#6
%   104: LDUR X2,[X3,#0] ; branch to here
%   108: ADD X10,X10,X2
%   112: ADDI X3,X3,#8
%   116: SUBI X1,X1,#1
%   120: CBNZ X1,#-4
%   124: ADD X5,X6,X7    ; instruction after branch
% \end{verbatim}
%   \end{itemize}
%   \BNotes\ifnum\Notes=1
%   \begin{itemize}
%   \item This is the original code that guessing ``branch taken'' was only
%     wrong once through loop (last time).

%     With 1-bit branch prediction, wrong first time and last time through loop

%     \item This is motivation for 2-bit branch prediction
%     \end{itemize}
%   \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
%   \Title{2-Bit Branch Prediction}
% \begin{itemize}
% \item 2-bit prediction only changes ``decision'' if wrong twice in a row
% \end{itemize}
% 	\PHFigure{!}{5in}{2.8in}{ARMFigures/Fig0462-crop}{Figure 4.62}
  
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item 2-bit prediction avoids being wrong twice when encountering a loop.

%   The next slide gives an example, but go over it now a bit

% \item The book briefly mentions more elaborate global branch prediction
%   schemes.
% \item Note that most of your gains come from 1-bit prediction
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
%   \Title{Branch Prediction Example}
% \begin{verbatim}
%   ADDI X4, X31, #6
%   LDUR X1, [X2,#20]  ; Branch to here
%   ADDI X1, X1, #4
%   STUR X1, [X2,#20]
%   ADDI X2, X2, #8
%   SUBI X4, X4, #1
%   CBNZ X4, #-5
%   ADD X1,X2,X3       ; Instruction after the branch
% \end{verbatim}
% How many correct/incorrect branch destinations?
% \begin{itemize}
% \item Assume branch not take:
% \item Assume branch taken:
% \item 1-bit branch prediction:
%   \item 2-bit branch prediction:
% \end{itemize}
% \BNotes\ifnum\Notes=1
% Do the analysis in how long the code takes to run.
% Note the load-use stall and the branch data hazard stall
% \begin{itemize}
% \item Assume not take: 1 correct, 5 incorrect

% \item Assume branch taken: 5 correct, 1 incorrect
% \item 1-bit branch prediction: Assume that predictor initially guessing "not taken"

% 	Then 4 correct, 2 incorrect.  Note that predictor ends up assuming "not taken" at the end

% \item 2-bit branch prediction: 

%   Go over the flow chart on this example, labeling states 00,01,10,11 clockwise from upper left

% 	Assume initially in state 01.  Then 5 correct, 1 incorrect.

% 		Redo from initial states 10 and 11.  You'll get more incorrect, but always
% 		end up in state 01.
% \item The ``assume branch taken'' looks good in this case, but would perform less well on if-statements.
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
% \STitle{Performance of Pipelined Design}
% \begin{itemize}
% \item Assume {\tt gcc} mix of instructions

% 	22\% loads, 11\% stores, 49\% R-format, 16\% branches, 2\% jumps

% \item Assume half of all loads followed by use
% \item Assume quarter of all conditional branches mispredicted
% \item Assume all unconditional branches are correctly predicted
% \item Average number of cycles per instruction (CPI) is:
% \[0.22 \times 1.5 + 0.11 \times 1 + 0.49 \times 1 + 0.16 \times 1.25 + 0.02
% \times 1 = 1.15\]

% \end{itemize}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item The 1.5 comes from half the loads taking 1 cycle and half taking 2;
% \item the 1.25 comes from a quarter of the branches taking 2 cycles as the
% 	result of a stall.
% \item Note that  unconditional branches only take one clock cycle since
%         we're assuming branch prediction
% \item Compare this figure of 1.17 to the 4 from the single-cycle
% 	implementation and 4.04 for the multi-cycle implementation, and it is
% 	clear why pipelining is such a win. Of course, we have to justify the
% 	assumptions made in this analysis. 
% \end{itemize}
% \fi\ENotes
% \end{frame}


% \begin{frame}[fragile]
% \STitle{Compiler Issues}
% ARM architecture with forwarding, stalls guarantees correct execution
% of ARM assembly.  But...
% \begin{itemize}
% \item Consider the C code:
% \begin{verbatim}
% c = 2*a+b;
% \end{verbatim}
% \item Straightforward pseudo-ARM code:
% \begin{verbatim}
% LDUR a
% ADD t,a,a
% LDUR b
% ADD t,t,b
% STUR c,t
% \end{verbatim}
% \item How long does this take to execute?

% Can we do better?
% \end{itemize}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item Pseudo-ARM: \texttt{LDUR a} would really be something like
% 	\texttt{LDUR X1, [X2,\#200]}
% \item Code has two load-use hazards takes 7 clock cycles 
% 	(ignoring cycles to fill the pipeline).
% \item Improve to 5 clock cycles by rearranging to
% \begin{verbatim}
% LDUR a
% LDUR b
% ADD t,a,a
% ADD t,t,b
% STUR c,t
% \end{verbatim}
% \item Timing formula from previous slide: if code rearrangement
% 	gets rid of ALL load-use hazards, then performance is
% 	1.06 cc = 112ps per instruction---a 10\% improvement.

% 	Even reducing load-use hazards to 25\% improves performance by 5\%
% \item Rewriting the C as
% 	\texttt{c = b+2*a;}  should change assembler to
% \begin{verbatim}
% LDUR b
% LDUR a
% ADD t,a,a
% ADD t,t,b
% STUR c,t
% \end{verbatim}
% which gets rid of 1 load-use hazard.
% \item Bottom line: software writers need to know what hardware is doing
% 	to get top performance.
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
% \Title{Loop unrolling}
% \begin{itemize}
% \item C code:
% \begin{verbatim}
% sum = 0;
% for (i=0; i<100; i++) {
%   sum += a[i];
% }
% \end{verbatim}
% \item Pseudo-ARM code (on CPU that stalls on branch taken):
% \begin{verbatim}
%     ADD sum,XZR,XZR
%     ADD i,XZR,XZR
%     LDUR t,a[i]
%     ADD sum,sum,t
%     ADDI i,i,#1
%     SUBI t,i,#100
%     CBNZ t,#-4
%     nexti
% \end{verbatim}
% \end{itemize}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item This code takes 7cc per loop or 700 cc total (there is a load-use stall).

% 	Swapping the \texttt{add sum,sum,t} and \texttt{addi i,i,1}
% 	reduces this to 6cc per loop or 600 cc total.
% \item But if we unroll the loop 100 times,
% \begin{verbatim}
%     ADD sum,XZR,XZR
%     ADD i,XZR,XZR

%     LDUR t,a[i]
%     ADD sum,sum,t
%     ADDI i,i,#1
%     LDUR t,a[i]
%     ADD sum,sum,t
%     ADDI i,i,#1
%     ...
% \end{verbatim}
% cost reduces to 300cc total.  Actual savings will be less because \texttt{lw}
% costs more than 1cc.
% \item For cache reasons, we may not want to unroll 100 times, but even
% 	unrolling 10 times (and looping 10 times), total cost reduced from
% 	600 to 330cc (10 SUBI + 10 CBNZ + 10 stalls).
% \item For real code, further complications (because loop control likely a
% 	variable rather than a constant; because if we unroll 10 times and
% 	number of times in loop not a multiple of 10, we need to handle
% 	the last few cases; etc), but still a huge gain.
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \iffalse
% \begin{frame}[fragile]
% \Title{Moving Instructions After a Branch}
% Forwarding, branch in ID stage, no branch flushing
% \begin{itemize}
% \item Need to adjust branch offset

% \begin{verbatim}
%     ADD i,XZR,XZR
%     ADD sum,XZR,XZR
%     ADD s2,XZR,XZR
%     LDUR t,a[i]
%     ADD sum,sum,t
%     ADDI i,i,#1
%     ADD s2,s2,i
%     SUBI t,i,#100
%     CBNZ t,#-5
%     nexti
% \end{verbatim}
% \end{itemize}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item Code has a load-use hazard.  nexti will also need to be NOP unless
% 	we can move an instuction from in the loop to after the branch
% \item The following works
% \begin{verbatim}
%     ADD i,XZR,XZR
%     ADD sum,XZR,XZR
%     ADD s2,XZR,XZR
%     LDUR t,a[i]
%     ADDI i,i,#1
%     ADD sum,sum,t
%     SUBI t,i,#100
%     CBNZ i,#100,#-4
%     ADD s2,s2,i
%     nexti
% \end{verbatim}
% but note that the CBNZ now goes to -4 instead of -5
% \item Also note that the example on the previous slide you are stuck either with a load-use stall or with putting NOP after the branch.
% \end{itemize}
% \fi\ENotes
% \end{frame}
% \fi

% \begin{frame}[fragile]{Code Rearrangement Guidelines}
% \vspace*{-.1in}
% \begin{itemize}
% 	\item Rearranged code should not affect ``behaviour''

% 		Assembly instruction level

% 		High level construct level

% 	\item Guidelines:
% 	\begin{itemize}
% 		\item Don't swap lines of code with dependencies:
			
% 			\texttt{100: LDUR X1,[X2,\#200]}\\
% 			\texttt{104: ADD X4,X1,X3}
% 		\item Don't swap in or out of loops
% \begin{verbatim}
%     ADD i,X31,X31
%     ADD sum,X31,X31
%     LDUR t,a[i]
%     ADD sum,sum,t
%     ADDI i,i,#1
%     SUBI t2,i,#100
%     CBNZ t2,#-4
%     nexti
% \end{verbatim}
% 	\end{itemize}
% \end{itemize}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item The question is, what component of behaviour are we not allowed to
% 	affect?  Ie, just swapping two lines of assembly code DOES affect
% 	behaviour (line 2 gets executed before line 1).  But we're more
% 	concerned about different behavioural issues.  
% \item First and foremost,
% 	we should not affect the "final results" that the high level language
% 	computes.  But even that can be vague: a busy wait loop such as
% 	\texttt{for (i=0; i<1000; i++);} could be optimized out and replaced
% 	with \texttt{i=1000;}.  However, supposed the programmer wanted a
% 	delay?  Generally, though, we're not considering either issue here
% 	(eg, deletion of useless code or timing behaviour intentions of the
% 	programmer).

% 	Note that you can NOT swap \texttt{LDUR} with \texttt{STUR}, since the first
% 	might read/write to the memory location that the second writes/reads.
% 	And we even though the two instructions might use different registers,
% 	we can't tell if the register+offset of the one instruction gives the
% 	same memory address as the register+offset of the other instruction.

% \item Roughly speaking, our real interest is that the result of \texttt{STUR}
% 	(or anything else that causes a
% 	side effect relative to the CPU) is unchanged by code rearrangment.
% \item In the code block, there is a load/use hazard.  We can't swap the
% 	\texttt{LDUR} with the \texttt{ADD} above it since the \texttt{LDUR} is
% 	at the start of a loop.  We could swap the two statements after the
% 	\texttt{LDUR} since there's no dependency.
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
% \Title{Code Rearrangement Steps}
% \begin{itemize}
% \item Spot the loops

% 	Can't move code inside/outside loop
% \item Spot dependencies

% 	Forward and backward
%       \item Spot stalls

%         Load/use, branch data hazard
% \item Rearrange to get rid of stalls

% \end{itemize}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% 	\item "Can't move code inside/outside loop" -- except for branch delay slot
% 	\item Backward dependencies: If instruction 104 reads register X and instruction 108 writes to
% 		register X1, then you can't swap them
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
% \Title{Code Rearrangement Example}
% Branch in ID, Branch flushing, Branch data hazard stall
% \begin{verbatim}
% ADDI X4, XZR, #7
% LDUR X1, [X2,#20]
% STUR X1, [X3,#20]
% SUBI X4, X4, #-1
% CBNZ X4, #-3
% ADD X6, X7, X8
% \end{verbatim}

% Rearrange for best performance
% \BNotes\ifnum\Notes=1
% Possibly write code on board and do three steps shown on previous slide.

% The example illustrates some details you need to get correct
% \begin{itemize}
% \item We want the same behavior (in terms
% 		of contents of registers) at the end of execution as we
% 		would get on the single cycle computer.
% \item The ``Branch data hazard stall" refers to having to stall when the
% 	branch is in the ID stage if the instruction before it writes to a
% 	register used by the branch.
% \item Solution:
% \begin{verbatim}
% ADDI X4,XZR,#7
% LDUR X1,[X2,#20]
% SUBI X4,X4,#-1
% STUR X1,[X3,#20]
% CBNZ X4,#-3
% ADD X6,X7,X8
% \end{verbatim}
% \item Note the following
% \begin{itemize}
% \item The lw/sw have a load-use hazard, 

% 		We can't move the ADDI X4,XZR,\#7 to get rid of the lw/sw stall
% 		because it is outside the loop.
% \item The ADDI X4,X4,\#-1 has a branch data hazard stall with the CBNZ
% \end{itemize}
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
% \STitle{Exceptions}
% \begin{itemize}
% \item Interrupt: external event unexpectedly changing control flow 

% 	I/O

% \item Exception: internal event unexpectedly changing control flow

% 	Arithmetic overflow

% \item Some books use {\it interrupt} for both concepts;

% 	this book used {\it exception} for both concepts

% \item OS will process exception

% To handle exception,
% \begin{itemize}
% 	\item Save PC for interrupted instruction
% 	\item Remember what caused exception
% \end{itemize}
% \end{itemize}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item This material is in Section 4.9.
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
% \Title{What caused the exception}
% \begin{itemize}
% 	\item Two general ways to note what caused the exception:
% 	\begin{itemize}
% 		\item {\it Cause register}: status register that holds
% 			field noting cause of exception

% 			OS checks cause register to process exception

% 		\item {\it Vectored interrupts}: table of addresses,
% 			one for each type of exception

% 			When interrupt A occurs, branch to routine that
% 			processes interrupt A

% 			OS can determine exception type by looking up
% 			address in table
% 	\end{itemize}
% 	\item Book uses cause registers, but notes it's really no different (hardware-wise) to use vectored interrupts
% \end{itemize}
% \BNotes\ifnum\Notes=1
% ~
% \fi\ENotes
% \end{frame}


% \begin{frame}[fragile]
% \Title{Hardware for Exception Handling}
% 	\PHFigure{!}{5in}{3in}{ARMFigures/Fig0464-crop}{Figure 4.64}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% 	\item Note: upper arrow to =0 unit shouldn't be there.
% 	\item New hardware:
% 	\begin{itemize}
% 		\item ELR --- address of affected instruction

% 		\item ESR: A register used to record the cause of the
% 			exception
% 		\item New input to PC: address of exception handler
% 		\item Not shown in figure: Overflow bit of ALU
% 			is new input to Control unit
% 	\end{itemize}
% 	\item This handles exceptions as another form of control hazard.

% 		Thus, must flush instructions following interrupted
% 		instruction, 

% 		and begin fetching instructions from
% 		exception handler
% 	\item New control signal, EX.Flush

% 		Get rid of instruction ADD instruction
% 		stage.
% 	\item New control signal, ID.Flush, ORed with stall signal

% 		Get rid of instruction after one in EX stage.
% 	\item Existing IF.Flush signal gets rid of instruction two after one in EX stage
% 	\item One gotcha: should exception instruction finish its
% 		execution?  Ie, should it write its result back to
% 		register file?  In this implementation, the result
% 		is NOT written back; note the EX.flush signal clearing
% 		the WB signal.
		
% \end{itemize}
% \fi\ENotes
% \end{frame}


% \begin{frame}[fragile]
% \Title{Exception Example}
% Assume this code executes (addresses in hex)
% \begin{verbatim}
% 40 SUB X11, X2, X4
% 44 AND X12, X2, X5
% 48 ORR X13, X2, X6
% 4C ADD X1, X2, X1 // This is going to cause the exception
% 50 SUB X15, X6, X7
% 54 LDUR X16, [X7,#100]
% \end{verbatim}
% and exception handler code is (addresses in hex)
% \begin{verbatim}
% 1C090000 STUR X25, [XZR,#1000]
% 1C090004 STUR X26, [XZR,#1004]
% \end{verbatim}
% \BNotes\ifnum\Notes=1
% ~
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
% 	\RFigureCR{!}{5in}{3in}{Figure 4.65}{ARMFigures/Fig0465-crop}{90}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item In the top half, go over all the things discussed three slides ago, pointing
% 	out where the various lines go high, etc.  Then show where
% 	the bubbles appear in the bottom half, and the new instruction
% 	(for exception) appears in the bottom half.
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
% \STitle{Conclusion}
%  \underline{\textbf{Lecture Summary}}
%  \begin{itemize}
% \item Design solutions to overcome control hazards:
% \begin{itemize}
% \item Branch decision in ID stage
%     \item Forwarding unit to ID stage

% \item Flushing instruction
%     \item Branch Prediction
    
%     \end{itemize}


% \end{itemize}
%  % \end{itemize}
%  \underline{\textbf{Assigned Readings}}
% \begin{itemize}
%      \item \textbf{Read} Section 4.8, 4.9 
%      \end{itemize}
%     \underline{\textbf{Next Steps}}
%     \begin{itemize}
%      \item \textbf{Review} Pipelined datapath and forwarding unit. 
% \begin{itemize}
%     \item Start the exercises in A5
% \end{itemize}
% \item Next week, we will introduce cache to speedup the pipelined datapath even further
% \item \textbf{Attempt} questions in this week's tutorial. 
%     \item \textbf{Ask} questions in office hours or the next tutorial.
%  \end{itemize}

% \end{frame}

%  \begin{frame}{Additional Slides}
%      Remaining slides are additional notes for your information.
%  \end{frame}
% \end{Lecture}

\begin{frame}[fragile]
\STitle{Conclusion}
 \underline{\textbf{Lecture Summary}}
 \begin{itemize}
\item Design solutions to overcome control hazards:
\item Branch decision-making moved to ID stage
    \item Forwarding unit extends to forward to ID stage

\item Flushing instruction 
\item Branch prediction, assuming hardware for: 
\begin{itemize}
    \item branch \textbf{not} taken 
\item branch \textbf{taken}
\item one and two bit dynamic branch prediction
\end{itemize}
% \item Performance analysis of pipelined datapath
    \end{itemize}

 % \end{itemize}
 \underline{\textbf{Assigned Textbook Readings}}
\begin{itemize}
     \item \textbf{Read} Section 4.8 %4.9 for exception handling
     \end{itemize}
    \underline{\textbf{Next Steps}}
    \begin{itemize}
     \item \textbf{Review} Pipelined datapath and data and control hazards 
% \begin{itemize}
%     \item Start the exercises in A5
% \end{itemize}
\item \textbf{Next week}, we will introduce exception handling to pipelined datapath
\item \textbf{Attempt} questions in this week's tutorial. 
    \item \textbf{Ask} questions in office hours or the next tutorial.
 \end{itemize}

\end{frame}
