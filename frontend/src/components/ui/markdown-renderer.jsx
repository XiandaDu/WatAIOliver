import React, { Suspense } from "react";
import Markdown from "react-markdown";
import remarkGfm from "remark-gfm";
import remarkMath from "remark-math";
import rehypeKatex from "rehype-katex";
import rehypeRaw from "rehype-raw";
// We previously sanitized output using rehype-sanitize, but the default schema
// stripped the CSS classes generated by KaTeX which prevented formulas from
// rendering correctly. Until a more permissive schema is implemented, the
// plugin is removed so that KaTeX markup renders as expected.
import "katex/dist/katex.min.css";

import { cn } from "@/lib/utils";
import { CopyButton } from "@/components/ui/copy-button";

export function MarkdownRenderer({ children }) {
  // DEBUG: Log what MarkdownRenderer receives
  // console.log("=== MARKDOWN RENDERER INPUT ===");
  // console.log("Children content:", typeof children === 'string' ? children.substring(0, 500) : children);
  // console.log("===============================");

  return (
    <div className="space-y-3">
      <Markdown
        remarkPlugins={[remarkGfm, remarkMath]}
        rehypePlugins={[rehypeRaw, rehypeKatex]}
        components={COMPONENTS}
      >
        {children}
      </Markdown>
    </div>
  );
}

// Use React.lazy to load shiki asynchronously
const HighlightedPre = React.lazy(async () => {
  const { codeToTokens, bundledLanguages } = await import("shiki");
  
  // Return a component that uses the imported functions
  return {
    default: React.memo(({ children, language, ...props }) => {
      const [highlighted, setHighlighted] = React.useState(null);
      
      React.useEffect(() => {
        if (!language || !(language in bundledLanguages)) {
          return;
        }
        
        codeToTokens(children, {
          lang: language,
          defaultColor: false,
          themes: {
            light: "github-light",
            dark: "github-dark",
          },
        }).then(({ tokens }) => {
          setHighlighted(tokens);
        }).catch(console.error);
      }, [children, language]);
      
      if (!highlighted) {
        return <pre {...props}>{children}</pre>;
      }
      
      return (
        <pre {...props}>
          <code>
            {highlighted.map((line, lineIndex) => (
              <React.Fragment key={lineIndex}>
                <span>
                  {line.map((token, tokenIndex) => {
                    const style =
                      typeof token.htmlStyle === "string"
                        ? undefined
                        : token.htmlStyle;

                    return (
                      <span
                        key={tokenIndex}
                        className="text-shiki-light bg-shiki-light-bg dark:text-shiki-dark dark:bg-shiki-dark-bg"
                        style={style}
                      >
                        {token.content}
                      </span>
                    );
                  })}
                </span>
                {lineIndex !== highlighted.length - 1 && "\n"}
              </React.Fragment>
            ))}
          </code>
        </pre>
      );
    })
  };
});
HighlightedPre.displayName = "HighlightedCode";

const CodeBlock = ({ children, className, language, ...restProps }) => {
  const code =
    typeof children === "string"
      ? children
      : childrenTakeAllStringContents(children);

  const preClass = cn(
    "overflow-x-scroll rounded-md border bg-background/50 p-4 font-mono text-sm [scrollbar-width:none]",
    className
  );

  return (
    <div className="group/code relative mb-4">
      <Suspense
        fallback={
          <pre className={preClass} {...restProps}>
            {children}
          </pre>
        }
      >
        <HighlightedPre language={language} className={preClass}>
          {code}
        </HighlightedPre>
      </Suspense>
      <div className="invisible absolute right-2 top-2 flex space-x-1 rounded-lg p-1 opacity-0 transition-all duration-200 group-hover/code:visible group-hover/code:opacity-100">
        <CopyButton content={code} copyMessage="Copied code to clipboard" />
      </div>
    </div>
  );
};

function childrenTakeAllStringContents(element) {
  if (typeof element === "string") {
    return element;
  }

  if (element?.props?.children) {
    let children = element.props.children;

    if (Array.isArray(children)) {
      return children
        .map((child) => childrenTakeAllStringContents(child))
        .join("");
    } else {
      return childrenTakeAllStringContents(children);
    }
  }

  return "";
}

const COMPONENTS = {
  h1: withClass("h1", "text-2xl font-semibold"),
  h2: withClass("h2", "font-semibold text-xl"),
  h3: withClass("h3", "font-semibold text-lg"),
  h4: withClass("h4", "font-semibold text-base"),
  h5: withClass("h5", "font-medium"),
  strong: withClass("strong", "font-semibold"),
  a: withClass("a", "text-primary underline underline-offset-2"),
  blockquote: withClass("blockquote", "border-l-2 border-primary pl-4"),
  code: ({ children, className, node, ...rest }) => {
    const match = /language-(\w+)/.exec(className || "");
    
    // Check if this is a code block (has language class) but NOT math
    // Math blocks should be handled by the default markdown renderer for KaTeX
    if (match && match[1] !== 'math') {
      return (
        <CodeBlock className={className} language={match[1]} {...rest}>
          {children}
        </CodeBlock>
      );
    }
    
    // This is inline code or math - render as normal code element
    return (
      <code
        className={cn(
          match ? "" : "font-mono rounded-md bg-background/50 px-1 py-0.5",
          className
        )}
        {...rest}
      >
        {children}
      </code>
    );
  },
  pre: ({ children, ...rest }) => {
    // For pre blocks, just pass through the children
    // This allows the code component above to handle the rendering
    return children;
  },
  ol: withClass("ol", "list-decimal space-y-2 pl-6"),
  ul: withClass("ul", "list-disc space-y-2 pl-6"),
  li: withClass("li", "my-1.5"),
  table: withClass(
    "table",
    "w-full border-collapse overflow-y-auto rounded-md border border-foreground/20"
  ),
  th: withClass(
    "th",
    "border border-foreground/20 px-4 py-2 text-left font-bold [&[align=center]]:text-center [&[align=right]]:text-right"
  ),
  td: withClass(
    "td",
    "border border-foreground/20 px-4 py-2 text-left [&[align=center]]:text-center [&[align=right]]:text-right"
  ),
  tr: withClass("tr", "m-0 border-t p-0 even:bg-muted"),
  p: ({ children, ...props }) => {
    // Check if children contain block-level elements (like div or pre)
    // If so, render children directly without the p wrapper
    const hasBlockContent = React.Children.toArray(children).some(child => {
      if (React.isValidElement(child)) {
        const type = child.type;
        // Check if it's a block element or our custom CodeBlock
        // But exclude math blocks which should stay inline
        const isCodeBlock = child.props && 
                           child.props.className && 
                           child.props.className.includes('language-') &&
                           !child.props.className.includes('language-math');
        return type === 'div' || type === 'pre' || type === CodeBlock || isCodeBlock;
      }
      return false;
    });
    
    if (hasBlockContent) {
      return <>{children}</>;
    }
    
    return <p className="whitespace-pre-wrap" {...props}>{children}</p>;
  },
  hr: withClass("hr", "border-foreground/20"),
};

function withClass(Tag, classes) {
  const Component = ({ node, ...props }) => (
    <Tag className={classes} {...props} />
  );
  Component.displayName = Tag;
  return Component;
}

export default MarkdownRenderer;
