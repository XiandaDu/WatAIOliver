% \begin{Lecture}{}

%%%%%%%%%%%%%%%%% leav for lecture 4 on pipelines
% \begin{frame}[fragile]
% \Title{Branch Prediction}
% \begin{itemize}
% \item Readings: Chapter 4, section 4.9  
% % --4.8
% %\item Idea: increase parallelism by overlapping execution of multiple
% %instructions 
% %\item Analogy: laundry (wash/dry/fold/put-away)
% %\item Analogy: industrial assembly line
% \end{itemize}
% \end{frame}

% \begin{frame}[fragile]
%   \Title{Hardware Assumes Branch {\bf Not} Taken}
%   \begin{itemize}
%   \item As designed, hardware assumes branch is {\bf not} taken

%     Loads instruction after branch
%   \item Maybe okay for \texttt{if} statements, but what about loops?

% \begin{verbatim}
%   100: ADDI X1,XZR,#6
%   104: LDUR X2,[X3,#0] ; branch to here
%   108: ADD X10,X10,X2  ; our sum is stored in X10
%   112: ADDI X3,X3,#8
%   116: SUBI X1,X1,#1
%   120: CBNZ X1,#-4
%   124: ADD X5,X6,X7    ; instruction after branch
% \end{verbatim}
% Line 124 gets loaded (``guessed'') \\when executing line 120 in ID stage
% \item How many times is ``guess'' correct?
%   \end{itemize}
%   \BNotes\ifnum\Notes=1
%   \begin{itemize}
%     \item The answer to the question is that the first 5 times through the loop, we ``guess'' wrong (i.e., lines 124 gets flushed five times); the last time we guess ``right'' (i.e., line 124 gets executed).
%   \end{itemize}
%   \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
%   \Title{Hardware Assume Branch \textbf{Taken}}
%   \begin{itemize}
%   \item Hardware shown flushes instruction after branch

%   \item Could instead load instruction where the branch goes

%     Flush if branch NOT taken
    
%   \item Hardware needs to store
%     \begin{itemize}
%     \item Address of {\tt CBZ} instruction
%     \item Destination of {\tt CBZ} instruction if branch taken
%     \end{itemize}
%   \item When executing branch, automatically load destination
%     address as next instruction

%     Flush if branch not taken
%   \end{itemize}
%   \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
%   colback=blue!5!white,colframe=blue!75!black,colbacktitle=blue!80!black,
%   title=Think About It,fonttitle=\bfseries,
%   boxed title style={size=small,colframe=red!50!black} ]
%   Do we expect to take the branch or not?
  
%   {\color{red}Hard to answer for \texttt{if}-like statements, easier to answer for loops.}
% \end{tcolorbox}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item Go back a slide to code example, show that it loads lines 104, ``guessing'' right 5 times, and wrong once, so line 124 is only flushed once.

%   This assumes table is constructed when code loaded into memory; if table not constructed until run time, then very first time through loop will guess lines 124
%   \item This is better for loops, but if you have conditionals for special
%   cases that rarely occur then poor performance
% \end{itemize}
% \fi\ENotes
% \end{frame}


% \begin{frame}[fragile]
%   \Title{Hardware for Branch Prediction}
%   \PHFigure{!}{5in}{3in}{ARMFigures/branchTabDP}{Figure 4.63, modified, }
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item The brown stuff in the lower left is the new stuff.
% \item Lots of details missing, but here's a summary:
%   \begin{itemize}
%   \item Entries in Branch Dest Addr Table include

%     address of branch instructions;
%     destination address; any branch prediction bits
%     (discussed on next few slides).
    
%   \item The table takes the PC of the branch instruction, which is stored in the IF/ID pipeline registers, as input; if the PC corresponds to a branch,
%     then based on prediction method, the branch destination stored in the
%     table is used to update the PC.
%   \item Missing from slide:

%     How to fill in table entries

%     If the branch isn't taken, then IF/ID.PC+4 is loaded into the PC.

%     How to decide whether or not to use address in table as next PC value
%     and choosing the input for the new MUX (ie, the select lines on the MUXes).
%     \item The timing is a bit tricky: in CC1, the branch is loaded.
% 	    Then in CC2, we detect if the IF/ID instruction is a branch, and if
% 		  so, use the IF/ID.PC to read the address of the next
% 		  instruction from the Branch Dest Addr Table.

% 		  However, also in CC2, if we decide (towards the end of the
% 		  clock cycle) that the branch is NOT taken, then rather than
% 		  store the instruction at the branch destination into the
% 		  IF/ID registers, we'll store a NOP.  At the same time,
% 		  we need to load IF/ID.PC+4 into the PC.


%   \end{itemize}
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \ifnum\slides=1
% \begin{frame}[fragile]
%   \Title{Branch Taken Prediction: Just Passing the Buck?}
%   \begin{itemize}
%   \item Loading branch destination helps loops,

%     but what about \texttt{if} statements?
% \item Example: sum via linked list
%     \begin{center}
%       \includegraphics[height=0.8in]{05-pipelining/figures/llist0data.png}
%       \end{center}
% \begin{verbatim}
%   100: ADDI X1,XZR,#0
%   104: LDUR X2,[X3,#8] ; branch to here
%   108:                 ; coming soon!
%   112: LDUR X4,[X2,#0] ; load data
%   116: ADD X1,X1,X4    ; add to sum
%   120: LDUR X3,[X3,#0] ; next in list
%   124: CBNZ X3,#-5
% \end{verbatim}
% \item X3 points to element in list

%   Element has next ptr and ``subpointer'' (sum subpointer)
%   \end{itemize}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item X3 point to a linked list; the first element is the ``next'' pointer, the second element is a pointer to ``stuff''
% \item We want to sum the ``stuff''
%   \item We left a blank line to be filled in on the next slide
% \end{itemize}
% \fi\ENotes
% \end{frame}
% \fi

% \begin{frame}[fragile]
%   \STitle{\texttt{Branch Taken Prediction}: Just Passing the Buck?}
%   \begin{itemize}
%   \item Loading branch destination helps loops, but what about \texttt{if} statements?
% \item Example: sum via linked list
% \item X3 points to element in list, element has \texttt{nextptr} and {\tt data}
%     \begin{center}
%       \includegraphics[height=0.5in]{05-pipelining/figures/llist0data.png}
%       \end{center}
%       {\footnotesize
% \begin{verbatim}
%   100: ADDI X1,XZR,#0
%   104: LDUR X2,[X3,#8] ; branch to here
%   108: CBZ X2,#3       ; skip to 120 if null ptr
%   112: LDUR X4,[X2,#0] ; load data
%   116: ADD X1,X1,X4    ; add to sum
%   120: LDUR X3,[X3,#0] ; next in list
%   124: CBNZ X3,#-5
% \end{verbatim}
% }
%   \end{itemize}
%  \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
%   colback=blue!5!white,colframe=blue!75!black,colbacktitle=blue!80!black,
%   title=Think About It,fonttitle=\bfseries,
%   boxed title style={size=small,colframe=red!50!black} ]
%   CBNZ will benefit from \textbf{``branch taken''}

%   Assuming null ptrs are rare, CBZ will benefit from ``branch not taken''
% \end{tcolorbox}

  
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item The problem is some of ``stuff'' is ``null'',  thus line 108
%   \item The real point is: some conditionals are usually taken, some are usually not taken, so either choice (branch taken, branch not taken) has many bad cases
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
%   \Title{Dynamic Branch Prediction: 1-Bit}
% \begin{itemize}
%   \item Cost of mispredicting branch is high
%   \item Use hardware to predict if branch is taken

%     1-bit prediction: just remember what happened last time branch encountered
%   \item Hardware needs to store
%     \begin{itemize}
%     \item Address of {\tt CBZ} instruction
%     \item Destination of {\tt CBZ} instruction if branch taken
%     \item Whether branch was taken last time this branch instruction was executed
%     \end{itemize}

%     \begin{center}
%     {\tiny
% 	\begin{tabular}{c|c|c}
% Instruction address & Branch Target Address &  Branch Taken (one-bit) \\\hline
% 0x...              & 0x... & 1 \\
% \vdots & \vdots \\
% \end{tabular}}
% \end{center}
% % The ``Branch Taken" prediction bit kept in the Branch Destination Address Table is initialized to 0 or 1, and predicts the next branch. 
% {\footnotesize {\tt Branch Taken} bit is inverted if the prediction is wrong.}
%   \item If \textbf{branch NOT taken} last time the branch instruction was executed
% $\rightarrow$    \texttt{load PC+4}
%   \item If \textbf{branch taken} last time the branch instruction was executed
% $\rightarrow$  \texttt{load branch target address}
% % rather than PC+4
% \item In both cases, flush instruction in IF stage if ``wrong''
%   \end{itemize}
%   \BNotes\ifnum\Notes=1
%   \begin{itemize}
%   \item ``Cost of branch misprediction high''--in our toy datapath, only one clock cycle, but in real computer, misprediction cost many clock cycles
%   \item 1-bit branch prediction handles cases of ``usually'' taken and
%     usually ``not taken''.  With a ``gotcha'' seen on the next slide.
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
%   \Title{Dynamic Branch Prediction: 2-Bit}
% \begin{itemize}
% \item 2-bit prediction only changes ``decision'' if wrong twice in a row
% \end{itemize}
% 	{\includegraphics[width=0.9\textwidth]{05-pipelining/figures/2-bit-branch-pred-statename.png}}
%  % {Figure 4.62}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item 2-bit prediction avoids being wrong twice when encountering a loop.

%   The next slide gives an example, but go over it now a bit

% \item The book briefly mentions more elaborate global branch prediction
%   schemes.
% \item Note that most of your gains come from 1-bit prediction
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
%   \Title{Branch Prediction Example}
% \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
%   colback=red!5!white,colframe=red!75!black,colbacktitle=red!80!black,
%   title=Try this,fonttitle=\bfseries,
%   boxed title style={size=small,colframe=red!50!black} ]  
% \begin{verbatim}
%   100 ADDI X4, X31, #6
%   104 LDUR X1, [X2,#20]  ; Branch to here
%   108 ADDI X1, X1, #4
%   112 STUR X1, [X2,#20]
%   116 ADDI X2, X2, #8
%   120 SUBI X4, X4, #1
%   124 CBNZ X4, #-5
%   128 ADD X1,X2,X3       ; Instruction after the branch
% \end{verbatim}
% How many correct/incorrect branch destinations?
% \begin{itemize}
% \item Assume branch not take:
% \item Assume branch taken:
% \item 1-bit branch prediction:
%   \item 2-bit branch prediction:
% \end{itemize}
% \end{tcolorbox}
% \BNotes\ifnum\Notes=1
% Do the analysis in how long the code takes to run.
% Note the load-use stall and the branch data hazard stall
% \begin{itemize}
% \item Assume not take: 1 correct, 5 incorrect

% \item Assume branch taken: 5 correct, 1 incorrect
% \item 1-bit branch prediction: Assume that predictor initially guessing "not taken"

% 	Then 4 correct, 2 incorrect.  Note that predictor ends up assuming "not taken" at the end

% \item 2-bit branch prediction: 

%   Go over the flow chart on this example, labeling states 00,01,10,11 clockwise from upper left

% 	Assume initially in state 01.  Then 5 correct, 1 incorrect.

% 		Redo from initial states 10 and 11.  You'll get more incorrect, but always
% 		end up in state 01.
% \item The ``assume branch taken'' looks good in this case, but would perform less well on if-statements.
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
%   \Title{1-Bit Branch Prediction ``Wrong Twice''}
%  In loops, 1-bit branch prediction can be wrong first time through, and wrong last time through
% {\footnotesize  
% \begin{multicols}{2}
% \begin{verbatim}
%   100: ADDI X1,XZR,#6
%   104: LDUR X2,[X3,#0]
%   108: ADD X10,X10,X2
%   112: ADDI X3,X3,#8
%   116: SUBI X1,X1,#1
%   120: CBNZ X1,#-4
%   124: ADD X5,X6,X7 
% \end{verbatim}

%     \columnbreak
%    {\footnotesize
% 	\begin{tabular}{c|c|c}
% Instruction & Destination &  Branch \\
% address & address & Taken (1-bit)\\\hline
% 120              & 104 & 0 \\
% \end{tabular}
% } 
% \end{multicols}
% }
% {\footnotesize
% \begin{tabular}{cc|ccc}
% Iteration & \makecell{Actual\\Branching} & \makecell{One Bit \\Prediction} & \makecell{Prediction\\Branching} &  \makecell{Correct or\\ Incorrect} \\\hline
% 1 (X1=5)  & Yes & 0 & No & Incorrect\\ \hline
% 2 (X1=4)  & Yes & 1 & Yes & Correct \\ \hline
% 3 (X1=3)  & Yes & 1 & Yes & Correct \\ \hline
% 4 (X1=2)  & Yes & 1 & Yes & Correct \\ \hline
% 5 (X1=1) & Yes & 1 & Yes & Correct\\ \hline
% 6 (X1=0) & No & 1 $\rightarrow$ 0 & Yes $\rightarrow$ No & Incorrect \\ \hline
% \end{tabular}}

%   \BNotes\ifnum\Notes=1
%   \begin{itemize}
%   \item This is the original code that guessing ``branch taken'' was only
%     wrong once through loop (last time).

%     With 1-bit branch prediction, wrong first time and last time through loop

%     \item This is motivation for 2-bit branch prediction
%     \end{itemize}
%   \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
%   \Title{1-Bit Branch Prediction ``Wrong Twice''}
%  In loops, 1-bit branch prediction can be wrong first time through, and wrong last time through
% {\footnotesize  
% \begin{multicols}{2}
% \begin{verbatim}
%   100: ADDI X1,XZR,#6
%   104: LDUR X2,[X3,#0]
%   108: ADD X10,X10,X2
%   112: ADDI X3,X3,#8
%   116: SUBI X1,X1,#1
%   120: CBNZ X1,#-4
%   124: ADD X5,X6,X7 
% \end{verbatim}

%     \columnbreak
%    {\footnotesize
% 	\begin{tabular}{c|c|c}
% Instruction & Destination &  Branch \\
% address & address & Taken (1-bit)\\\hline
% 120              & 104 & 1 \\
% \end{tabular}
% } 
% \end{multicols}
% }
% {\footnotesize
% \begin{tabular}{cc|ccc}
% Iteration & \makecell{Actual\\Branching} & \makecell{One Bit \\Prediction} & \makecell{Prediction\\Branching} &  \makecell{Correct or\\ Incorrect} \\\hline
% 1 (X1=5)  & Yes & 1 & Yes & Correct\\ \hline
% 2 (X1=4)  & Yes & 1 & Yes & Correct \\ \hline
% 3 (X1=3)  & Yes & 1 & Yes & Correct \\ \hline
% 4 (X1=2)  & Yes & 1 & Yes & Correct \\ \hline
% 5 (X1=1) & Yes & 1 & Yes & Correct\\ \hline
% 6 (X1=0) & No & 1 $\rightarrow$ 0 & Yes $\rightarrow$ No & Incorrect \\ \hline
% \end{tabular}}

%   \BNotes\ifnum\Notes=1
%   \begin{itemize}
%   \item This is the original code that guessing ``branch taken'' was only
%     wrong once through loop (last time).

%     With 1-bit branch prediction, wrong first time and last time through loop

%     \item This is motivation for 2-bit branch prediction
%     \end{itemize}
%   \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
%   \Title{2-Bit Branch Prediction}
% \begin{itemize}
% \item 2-bit prediction only changes ``decision'' if wrong twice in a row
% \end{itemize}
% 	{\includegraphics[width=0.9\textwidth]{05-pipelining/figures/2-bit-branch-pred-statename.png}}
%  % {Figure 4.62}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item 2-bit prediction avoids being wrong twice when encountering a loop.

%   The next slide gives an example, but go over it now a bit

% \item The book briefly mentions more elaborate global branch prediction
%   schemes.
% \item Note that most of your gains come from 1-bit prediction
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
%   \Title{Branch Prediction Example}
% \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
%   colback=red!5!white,colframe=red!75!black,colbacktitle=red!80!black,
%   title=Try this,fonttitle=\bfseries,
%   boxed title style={size=small,colframe=red!50!black} ]  
% \begin{verbatim}
%   100 ADDI X4, X31, #6
%   104 LDUR X1, [X2,#20]  ; Branch to here
%   108 ADDI X1, X1, #4
%   112 STUR X1, [X2,#20]
%   116 ADDI X2, X2, #8
%   120 SUBI X4, X4, #1
%   124 CBNZ X4, #-5
%   128 ADD X1,X2,X3       ; Instruction after the branch
% \end{verbatim}
% How many correct/incorrect branch destinations?
% \begin{itemize}
% \item Assume branch not take:
% \item Assume branch taken:
% \item 1-bit branch prediction:
%   \item 2-bit branch prediction:
% \end{itemize}
% \end{tcolorbox}
% \BNotes\ifnum\Notes=1
% Do the analysis in how long the code takes to run.
% Note the load-use stall and the branch data hazard stall
% \begin{itemize}
% \item Assume not take: 1 correct, 5 incorrect

% \item Assume branch taken: 5 correct, 1 incorrect
% \item 1-bit branch prediction: Assume that predictor initially guessing "not taken"

% 	Then 4 correct, 2 incorrect.  Note that predictor ends up assuming "not taken" at the end

% \item 2-bit branch prediction: 

%   Go over the flow chart on this example, labeling states 00,01,10,11 clockwise from upper left

% 	Assume initially in state 01.  Then 5 correct, 1 incorrect.

% 		Redo from initial states 10 and 11.  You'll get more incorrect, but always
% 		end up in state 01.
% \item The ``assume branch taken'' looks good in this case, but would perform less well on if-statements.
% \end{itemize}
% \fi\ENotes
% \end{frame}

% %-----------------------------------------------------

% \ifnum\Ans=1{
% \begin{frame}[fragile]\frametitle{Solution: Branch Prediction Example}
% {\tiny
% \begin{verbatim}
%   100 ADDI X4, X31, #6
%   104 LDUR X1, [X2,#20]  ; branch to here
%   108 ADDI X1, X1, #4    ; load-use stall
%   112 STUR X1, [X2,#20]
%   116 ADDI X2, X2, #8
%   120 SUBI X4, X4, #1    ; decrement counter
%   124 CBNZ X4, #-5       ; branch data stall
%   128 ADD X1,X2,X3       
% \end{verbatim}
% }
% {\tiny
% \begin{center}
% 	\begin{tabular}{c|cccccc}
% Iteration &  1 (X4=5) & 2 (X4=4) & 3 (X4=3) & 4 (X4=2) & 5 (X4=1) & 6 (X4=0) \\\hline
% \makecell{Actual\\Branching} & Yes & Yes & Yes & Yes & Yes & No\\ \hline
% \noalign{\global\arrayrulewidth=0.5mm} \arrayrulecolor{orange}
% \hline
% \makecell{Prediction: \\ Branch \textbf{Not} \textbf{Taken} (PC+4)} & No & No & No & No & No & No \\ \hline
% \makecell{Correct \\or Incorrect} & Incorrect & Incorrect & Incorrect & Incorrect & Incorrect & Correct \\ \hline
% \noalign{\global\arrayrulewidth=0.5mm} \arrayrulecolor{green}
% \hline
% \makecell{Prediction: \\ Branch \textbf{Taken} (branch target addr)} & Yes & Yes & Yes & Yes & Yes & Yes \\ \hline
% \makecell{Correct \\or Incorrect} & Correct & Correct & Correct & Correct & Correct & Incorrect \\ \hline
% \noalign{\global\arrayrulewidth=0.5mm} \arrayrulecolor{blue}
% \hline
% \makecell{Prediction: \\ 1-bit Branch Predict=0} & No & Yes (0 $\rightarrow$ 1) & Yes & Yes & Yes & Yes ( 1 $\rightarrow$ 0) \\ \hline
% \makecell{Correct \\or Incorrect} & Incorrect & Correct & Correct & Correct & Correct & Incorrect \\ \hline
% \noalign{\global\arrayrulewidth=0.5mm} \arrayrulecolor{red}
% \hline
% \makecell{Prediction: \\ 1-bit Branch Predict=1} & Yes & Yes  & Yes & Yes & Yes & Yes ( 1 $\rightarrow$ 0) \\ \hline
% \makecell{Correct \\or Incorrect} & Correct & Correct & Correct & Correct & Correct & Incorrect \\ \hline

% \end{tabular}
% \end{center}
% }
% \end{frame}
% }\fi
% %-----------------------------------------------------
% \begin{frame}[fragile]\frametitle{Branch Prediction Comparison: Branch Taken}

% \begin{verbatim}
% ADDI X4, X31, #6   // Initialize counter to 6
% LDUR X1, [X2,#20]
% ADDI X1, X1, #4    // Load-use stall
% STUR X1, [X2,#20]
% ADDI X2, X2, #8
% SUBI X4, X4, #1    // Decrement counter
% CBNZ X4, #-5       // Branch data stall, wait for X4
% ADD X1,X2,X3       
% \end{verbatim}
% \begin{center}
% 	\begin{tabular}{c|cccccc}
% Iteration &  1 & 2 & 3 & 4 & 5 & 6 \\\hline
% \makecell{Actual\\Branching} & Yes & Yes & Yes & Yes & Yes & No\\ \hline
% Prediction & Yes & Yes & Yes & Yes & Yes & Yes \\ \hline
% \makecell{Correct \\or Wrong} & Correct & Correct & Correct & Correct & Correct & Wrong \\ \hline
% \end{tabular}
% \end{center}
% \end{frame}

%-----------------------------------------------------
% \begin{frame}[fragile]\frametitle{Branch Prediction Comparison: One-Bit Prediction}
% Assuming predictor bit state is initially 0 for ``not taken".
% \begin{verbatim}
% ADDI X4, X31, #6   // Initialize counter to 6
% LDUR X1, [X2,#20]
% ADDI X1, X1, #4    // Load-use stall
% STUR X1, [X2,#20]
% ADDI X2, X2, #8
% SUBI X4, X4, #1    // Decrement counter
% CBNZ X4, #-5       // Branch data stall, wait for X4
% ADD X1,X2,X3       
% \end{verbatim}
% \begin{center}
% 	\begin{tabular}{c|cccccc}
% Iteration &  1 & 2 & 3 & 4 & 5 & 6 \\\hline
% \makecell{Actual\\Branching} & Yes & Yes & Yes & Yes & Yes & No\\ \hline
% State & 0 & 1 & 1 & 1 & 1 &1 \\ \hline
% Prediction & No & Yes & Yes & Yes & Yes & Yes \\ \hline
% \makecell{Correct \\or Wrong} & Wrong & Correct & Correct & Correct & Correct & Wrong \\ \hline
% \end{tabular}
% \end{center}
% \end{frame}

%-----------------------------------------------------
\begin{frame}[fragile]\frametitle{Branch Prediction Comparison: Two-Bit Prediction}
Assuming branch predictor is initially in state 01.
\begin{multicols}{2}
{\tiny
\begin{verbatim}
  100 ADDI X4, X31, #6
  104 LDUR X1, [X2,#20]  ; branch to here
  108 ADDI X1, X1, #4    ; load-use stall
  112 STUR X1, [X2,#20]
  116 ADDI X2, X2, #8
  120 SUBI X4, X4, #1    ; decrement counter
  124 CBNZ X4, #-5       ; branch data stall
  128 ADD X1,X2,X3       
\end{verbatim}
}
\columnbreak
\begin{figure}[H]
\centering
	{\includegraphics[width=0.35\textwidth]{05-pipelining/figures/2-bit-branch-pred-statename.png}}
%\caption{}\label{}
\end{figure}    
\end{multicols}

{\footnotesize
\begin{center}
	\begin{tabular}{c|cccccc}
Iteration &  1 (X4=5) & 2 (X4=4) & 3 (X4=3) & 4 (X4=2) & 5 (X4=1) & 6 (X4=0) \\\hline
\makecell{Actual\\Branching} & Yes & Yes & Yes & Yes & Yes & No\\ \hline
State      & 01 & 00 & 00 & 00 & 00 & 00 {$\rightarrow$ 01}\\ \hline
Prediction & Yes & Yes & Yes & Yes & Yes & Yes \\ \hline
\makecell{Correct \\or Incorrect} & Correct & Correct & Correct & Correct & Correct & Incorrect \\ \hline
\end{tabular}
\end{center}
}
\end{frame}

%-----------------------------------------------------
\begin{frame}[fragile]\frametitle{Branch Prediction Comparison: Two-Bit Prediction}
Assuming predictor two-bit state is initially 10.
\begin{multicols}{2}
{\tiny
\begin{verbatim}
  100 ADDI X4, X31, #6
  104 LDUR X1, [X2,#20]  ; branch to here
  108 ADDI X1, X1, #4    ; load-use stall
  112 STUR X1, [X2,#20]
  116 ADDI X2, X2, #8
  120 SUBI X4, X4, #1    ; decrement counter
  124 CBNZ X4, #-5       ; branch data stall
  128 ADD X1,X2,X3       
\end{verbatim}
}
\columnbreak
\begin{figure}[H]
\centering
	{\includegraphics[width=0.35\textwidth]{05-pipelining/figures/2-bit-branch-pred-statename.png}}
%\caption{}\label{}
\end{figure}    
\end{multicols}
{\footnotesize
\begin{center}
	\begin{tabular}{c|cccccc}
Iteration &  1 (X4=5) & 2 (X4=4) & 3 (X4=3) & 4 (X4=2) & 5 (X4=1) & 6 (X4=0) \\\hline
\makecell{Actual\\Branching} & Yes & Yes & Yes & Yes & Yes & No\\ \hline
State & 10 & 01 & 00 & 00 & 00 & 00 {$\rightarrow$ 01}\\ \hline
Prediction & No & Yes & Yes & Yes & Yes & Yes \\ \hline
\makecell{Correct \\or Incorrect} & Incorrect & Correct & Correct & Correct & Correct & Incorrect \\ \hline
\end{tabular}
\end{center}
}
\end{frame}

%-----------------------------------------------------
\begin{frame}[fragile]\frametitle{Branch Prediction Comparison: Two-Bit Prediction}
Assuming predictor two-bit state is initially 11.
\begin{multicols}{2}
{\tiny
\begin{verbatim}
  100 ADDI X4, X31, #6
  104 LDUR X1, [X2,#20]  ; branch to here
  108 ADDI X1, X1, #4    ; load-use stall
  112 STUR X1, [X2,#20]
  116 ADDI X2, X2, #8
  120 SUBI X4, X4, #1    ; decrement counter
  124 CBNZ X4, #-5       ; branch data stall
  128 ADD X1,X2,X3       
\end{verbatim}
}
\columnbreak
\begin{figure}[H]
\centering
	{\includegraphics[width=0.35\textwidth]{05-pipelining/figures/2-bit-branch-pred-statename}}
%\caption{}\label{}
\end{figure}    
\end{multicols}
{\footnotesize
\begin{center}
	\begin{tabular}{c|cccccc}
Iteration &  1 (X4=5) & 2 (X4=4) & 3 (X4=3) & 4 (X4=2) & 5 (X4=1) & 6 (X4=0) \\\hline
\makecell{Actual\\Branching} & Yes & Yes & Yes & Yes & Yes & No \\ \hline
State & 11 & 10 & 01 & 00 & 00 & 00 {$\rightarrow$ 01}\\ \hline
Prediction & No & No & Yes & Yes & Yes & Yes \\ \hline
\makecell{Correct \\or Incorrect} & Incorrect & Incorrect & Correct & Correct & Correct & Incorrect \\ \hline
\end{tabular}
\end{center}
}
\end{frame}

%-----------------------------------------------------

% \begin{frame}[fragile]
%   \Title{Branch Prediction Example}
% \begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
%   colback=red!5!white,colframe=red!75!black,colbacktitle=red!80!black,
%   title=Try this,fonttitle=\bfseries,
%   boxed title style={size=small,colframe=red!50!black} ]  
% \begin{verbatim}
%   100 ADDI X4, X31, #6
%   104 LDUR X1, [X2,#20]  ; Branch to here
%   108 ADDI X1, X1, #4
%   112 STUR X1, [X2,#20]
%   116 ADDI X2, X2, #8
%   120 SUBI X4, X4, #1
%   124 CBNZ X4, #-5
%   128 ADD X1,X2,X3       ; Instruction after the branch
% \end{verbatim}
% How many correct/incorrect branch destinations?
% \begin{itemize}
% \item Assume branch not take:
% \item Assume branch taken:
% \item 1-bit branch prediction:
%   \item 2-bit branch prediction:
% \end{itemize}
% \end{tcolorbox}
% \BNotes\ifnum\Notes=1
% Do the analysis in how long the code takes to run.
% Note the load-use stall and the branch data hazard stall
% \begin{itemize}
% \item Assume not take: 1 correct, 5 incorrect

% \item Assume branch taken: 5 correct, 1 incorrect
% \item 1-bit branch prediction: Assume that predictor initially guessing "not taken"

% 	Then 4 correct, 2 incorrect.  Note that predictor ends up assuming "not taken" at the end

% \item 2-bit branch prediction: 

%   Go over the flow chart on this example, labeling states 00,01,10,11 clockwise from upper left

% 	Assume initially in state 01.  Then 5 correct, 1 incorrect.

% 		Redo from initial states 10 and 11.  You'll get more incorrect, but always
% 		end up in state 01.
% \item The ``assume branch taken'' looks good in this case, but would perform less well on if-statements.
% \end{itemize}
% \fi\ENotes
% \end{frame}

%-----------------------------------------------------

% \ifnum\Ans=1{
% \begin{frame}[fragile]\frametitle{Solution: Summary of Branch Prediction Example}
% {\tiny
% \begin{verbatim}
%   100 ADDI X4, X31, #6
%   104 LDUR X1, [X2,#20]  ; branch to here
%   108 ADDI X1, X1, #4    ; load-use stall
%   112 STUR X1, [X2,#20]
%   116 ADDI X2, X2, #8
%   120 SUBI X4, X4, #1    ; decrement counter
%   124 CBNZ X4, #-5       ; branch data stall
%   128 ADD X1,X2,X3       
% \end{verbatim}
% }
% {\tiny
% \begin{center}
% 	\begin{tabular}{c|cccccc}
% Iteration &  1 (X4=5) & 2 (X4=4) & 3 (X4=3) & 4 (X4=2) & 5 (X4=1) & 6 (X4=0) \\\hline
% \makecell{Actual\\Branching} & Yes & Yes & Yes & Yes & Yes & No\\ \hline
% \noalign{\global\arrayrulewidth=0.5mm} \arrayrulecolor{orange}
% \hline
% \makecell{Prediction: \\ Branch \textbf{Not} \textbf{Taken} (PC+4)} & No & No & No & No & No & No \\ \hline
% \makecell{Correct \\or Incorrect} & Incorrect & Incorrect & Incorrect & Incorrect & Incorrect & Correct \\ \hline
% \noalign{\global\arrayrulewidth=0.5mm} \arrayrulecolor{green}
% \hline
% \makecell{Prediction: \\ Branch \textbf{Taken} (branch target addr)} & Yes & Yes & Yes & Yes & Yes & Yes \\ \hline
% \makecell{Correct \\or Incorrect} & Correct & Correct & Correct & Correct & Correct & Incorrect \\ \hline
% \noalign{\global\arrayrulewidth=0.5mm} \arrayrulecolor{blue}
% \hline
% \makecell{Prediction: \\ 1-bit Branch Predict=0} & No & Yes (0 $\rightarrow$ 1) & Yes & Yes & Yes & Yes ( 1 $\rightarrow$ 0) \\ \hline
% \makecell{Correct \\or Incorrect} & Incorrect & Correct & Correct & Correct & Correct & Incorrect \\ \hline
% \noalign{\global\arrayrulewidth=0.5mm} \arrayrulecolor{red}
% \hline
% \makecell{Prediction: \\ 1-bit Branch Predict=1} & Yes & Yes  & Yes & Yes & Yes & Yes ( 1 $\rightarrow$ 0) \\ \hline
% \makecell{Correct \\or Incorrect} & Correct & Correct & Correct & Correct & Correct & Incorrect \\ \hline

% \end{tabular}
% \end{center}
% }
% \end{frame}
% }\fi
% %-----------------------------------------------------

% \begin{frame}[fragile]
% \STitle{Branch Prediction Analysis}
% {\footnotesize
%     \begin{tabular}{l|c|c}
%  & \multicolumn{2}{c}{Branch Prediction}\\
% Next instruction & Number Correct & Number Incorrect\\
% \hline\hline
% Branch Not Taken (PC+4) & 1 & 5 \\\hline
% Branch taken (Branch destination addr) & 5& 1\\\hline\hline
% 1-bit Branch Prediction (with bit=0) & 4 &2 \\\hline

% 1-bit Branch Prediction (with bit=1) & 5 & 1\\\hline
% \hline
% 2-bit start at state 01 & 5  &1 \\\hline
% 2-bit start at state 10 & 4 & 2\\\hline
% 2-bit start at state 11 & 3 & 3 \\\hline
% \end{tabular}
% }
% \end{frame}


\begin{frame}[fragile]\frametitle{Example: Execution Time}

\begin{tcolorbox}[enhanced,attach boxed title to top center={yshift=-3mm,yshifttext=-1mm},
  colback=red!5!white,colframe=red!75!black,colbacktitle=red!80!black,
  title=Try this,fonttitle=\bfseries,
  boxed title style={size=small,colframe=red!50!black} ]  
  What is the execution time of the code segment below on a pipelined datapath that is already running. 
\begin{verbatim}
ADDI X4, X31, #6   
LDUR X1, [X2,#20]  
ADDI X1, X1, #4   
STUR X1, [X2,#20]  
ADDI X2, X2, #8    
SUBI X4, X4, #1    
CBNZ X4, #-5      
ADD X1,X2,X3       
\end{verbatim}

\textbf{Assume branch not taken}
% 4cc (startup) + 
1 + 6* (1 (load-use) + 1 (branch data stall) + 6 (instructions) + 1 (flush or execute instruction after last loop) )
\end{tcolorbox}
\end{frame}
\ifnum\Ans=1{
\begin{frame}[fragile]\frametitle{Solution: Execution Time}

You \textbf{do not} need to add pipeline start-up time.
\begin{verbatim}
ADDI X4, X31, #6   // Initialize counter to 6
                   // Instructions in the loop
LDUR X1, [X2,#20]  // 1. Branch to here
ADDI X1, X1, #4    // 2. Load-use stall
STUR X1, [X2,#20]  // 3.
ADDI X2, X2, #8    // 4.
SUBI X4, X4, #1    // 5. Decrement counter
CBNZ X4, #-5       // 6. Branch data stall, wait for X4
ADD X1,X2,X3       
\end{verbatim}
Assume branch not taken:

% 4cc (startup) + 
1 + 6* (1 (load-use) + 1 (branch data stall) + 6 (instructions) + 1 (flush or execute instruction after last loop) )

Hint: If pipelines was not running, add startup time of 4 cc. 
\end{frame}
}\fi

% \begin{frame}[fragile]
% \STitle{Performance of Pipelined Design}
% \begin{itemize}
% \item Assume {\tt gcc} mix of instructions

% 	22\% loads, 11\% stores, 49\% R-format, 
 
%  16\% branches, 2\% unconditional branches

% \item Assume half of all loads followed by use
% \item Assume quarter of all conditional branches mispredicted
% \item Assume all unconditional branches are correctly predicted
% \item Average number of cycles per instruction (CPI) is:
% \[0.22 \times 1.5 + 0.11 \times 1 + 0.49 \times 1 + 0.16 \times 1.25 + 0.02
% \times 1 = 1.15\]

% \end{itemize}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item The 1.5 comes from half the loads taking 1 cycle and half taking 2;
% \item the 1.25 comes from a quarter of the branches taking 2 cycles as the
% 	result of a stall.
% \item Note that  unconditional branches only take one clock cycle since
%         we're assuming branch prediction
% \item Compare this figure of 1.17 to the 4 from the single-cycle
% 	implementation and 4.04 for the multi-cycle implementation, and it is
% 	clear why pipelining is such a win. Of course, we have to justify the
% 	assumptions made in this analysis. 
% \end{itemize}
% \fi\ENotes
% \end{frame}
%-----------------------------------------------------
\begin{frame}\frametitle{Average Performance of Pipelined Design}
Assume the following mix of instructions:
\begin{itemize}
\item 22\% loads
\item 11\% stores
\item 49\% R-format
\item 16\% conditional branches
\item 2\% branch (unconditional branch)
\end{itemize}
\emph{Without} the pipeline start-up time of 4cc, the above instructions each take \textbf{1cc to finish}. However, some instructions have hazards:
\begin{itemize}
\item Load-use hazards: 2cc for half of all loads.
\item Branch mispredicted: 2cc for a quarter of all conditional branches.
\item Unconditional branches can store their destination address so they are always correctly predicted.
\item Assume branching in the ID stage.
\end{itemize}



\end{frame}

%-----------------------------------------------------
\begin{frame}\frametitle{Clock Cycle per Instruction: Pipelined Desgin}
The following table shows the instructions and their execution times, without the pipeline start-up time.

\begin{center}
	\begin{tabular}{c|c|c}
Instuction & Execution Time (clock cycles)  & Mix \\ \hline\hline
loads      & 1(0.5)+2(0.5)=1.5 & 0.22 \\ \hline
stores     & 1 & 0.11 \\ \hline
R-format   & 1 & 0.49 \\ \hline
CB-format   & 1(0.75) + 2(0.25)=1.25 & 0.16 \\ \hline
B-format      & 1 & 0.02 \\ \hline
 \end{tabular}
\end{center}
Weighted average CPI:
$$(1.5)(0.22) + (1)(0.11) + (1)(0.49) + (1.25)(0.16)+(1)(0.02)=1.15$$
This means with all the forwarding, stalling, flushing, hazard detection etc. implemented, instructions on average take \textbf{close to 1cc to finish}.

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%% next steps of the lecture


% \begin{frame}[fragile]
% \STitle{Compiler Issues}
% ARM architecture with forwarding, stalls guarantees correct execution
% of ARM assembly.  But...
% \begin{itemize}
% \item Consider the C code:
% \begin{verbatim}
% c = 2*a+b;
% \end{verbatim}
% \item Straightforward pseudo-ARM code:
% \begin{verbatim}
% LDUR a
% ADD t,a,a
% LDUR b
% ADD t,t,b
% STUR c,t
% \end{verbatim}
% \item How long does this take to execute?

% Can we do better?
% \end{itemize}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item Pseudo-ARM: \texttt{LDUR a} would really be something like
% 	\texttt{LDUR X1, [X2,\#200]}
% \item Code has two load-use hazards takes 7 clock cycles 
% 	(ignoring cycles to fill the pipeline).
% \item Improve to 5 clock cycles by rearranging to
% \begin{verbatim}
% LDUR a
% LDUR b
% ADD t,a,a
% ADD t,t,b
% STUR c,t
% \end{verbatim}
% \item Timing formula from previous slide: if code rearrangement
% 	gets rid of ALL load-use hazards, then performance is
% 	1.06 cc = 112ps per instruction---a 10\% improvement.

% 	Even reducing load-use hazards to 25\% improves performance by 5\%
% \item Rewriting the C as
% 	\texttt{c = b+2*a;}  should change assembler to
% \begin{verbatim}
% LDUR b
% LDUR a
% ADD t,a,a
% ADD t,t,b
% STUR c,t
% \end{verbatim}
% which gets rid of 1 load-use hazard.
% \item Bottom line: software writers need to know what hardware is doing
% 	to get top performance.
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
% \Title{Loop unrolling}
% \begin{itemize}
% \item C code:
% \begin{verbatim}
% sum = 0;
% for (i=0; i<100; i++) {
%   sum += a[i];
% }
% \end{verbatim}
% \item Pseudo-ARM code (on CPU that stalls on branch taken):
% \begin{verbatim}
%     ADD sum,XZR,XZR
%     ADD i,XZR,XZR
%     LDUR t,a[i]
%     ADD sum,sum,t
%     ADDI i,i,#1
%     SUBI t,i,#100
%     CBNZ t,#-4
%     nexti
% \end{verbatim}
% \end{itemize}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item This code takes 7cc per loop or 700 cc total (there is a load-use stall).

% 	Swapping the \texttt{add sum,sum,t} and \texttt{addi i,i,1}
% 	reduces this to 6cc per loop or 600 cc total.
% \item But if we unroll the loop 100 times,
% \begin{verbatim}
%     ADD sum,XZR,XZR
%     ADD i,XZR,XZR

%     LDUR t,a[i]
%     ADD sum,sum,t
%     ADDI i,i,#1
%     LDUR t,a[i]
%     ADD sum,sum,t
%     ADDI i,i,#1
%     ...
% \end{verbatim}
% cost reduces to 300cc total.  Actual savings will be less because \texttt{lw}
% costs more than 1cc.
% \item For cache reasons, we may not want to unroll 100 times, but even
% 	unrolling 10 times (and looping 10 times), total cost reduced from
% 	600 to 330cc (10 SUBI + 10 CBNZ + 10 stalls).
% \item For real code, further complications (because loop control likely a
% 	variable rather than a constant; because if we unroll 10 times and
% 	number of times in loop not a multiple of 10, we need to handle
% 	the last few cases; etc), but still a huge gain.
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \iffalse
% \begin{frame}[fragile]
% \Title{Moving Instructions After a Branch}
% Forwarding, branch in ID stage, no branch flushing
% \begin{itemize}
% \item Need to adjust branch offset

% \begin{verbatim}
%     ADD i,XZR,XZR
%     ADD sum,XZR,XZR
%     ADD s2,XZR,XZR
%     LDUR t,a[i]
%     ADD sum,sum,t
%     ADDI i,i,#1
%     ADD s2,s2,i
%     SUBI t,i,#100
%     CBNZ t,#-5
%     nexti
% \end{verbatim}
% \end{itemize}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item Code has a load-use hazard.  nexti will also need to be NOP unless
% 	we can move an instuction from in the loop to after the branch
% \item The following works
% \begin{verbatim}
%     ADD i,XZR,XZR
%     ADD sum,XZR,XZR
%     ADD s2,XZR,XZR
%     LDUR t,a[i]
%     ADDI i,i,#1
%     ADD sum,sum,t
%     SUBI t,i,#100
%     CBNZ i,#100,#-4
%     ADD s2,s2,i
%     nexti
% \end{verbatim}
% but note that the CBNZ now goes to -4 instead of -5
% \item Also note that the example on the previous slide you are stuck either with a load-use stall or with putting NOP after the branch.
% \end{itemize}
% \fi\ENotes
% \end{frame}
% \fi

% \begin{frame}[fragile]{Code Rearrangement Guidelines}
% \vspace*{-.1in}
% \begin{itemize}
% 	\item Rearranged code should not affect ``behaviour''

% 		Assembly instruction level

% 		High level construct level

% 	\item Guidelines:
% 	\begin{itemize}
% 		\item Don't swap lines of code with dependencies:
			
% 			\texttt{100: LDUR X1,[X2,\#200]}\\
% 			\texttt{104: ADD X4,X1,X3}
% 		\item Don't swap in or out of loops
% \begin{verbatim}
%     ADD i,X31,X31
%     ADD sum,X31,X31
%     LDUR t,a[i]
%     ADD sum,sum,t
%     ADDI i,i,#1
%     SUBI t2,i,#100
%     CBNZ t2,#-4
%     nexti
% \end{verbatim}
% 	\end{itemize}
% \end{itemize}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item The question is, what component of behaviour are we not allowed to
% 	affect?  Ie, just swapping two lines of assembly code DOES affect
% 	behaviour (line 2 gets executed before line 1).  But we're more
% 	concerned about different behavioural issues.  
% \item First and foremost,
% 	we should not affect the "final results" that the high level language
% 	computes.  But even that can be vague: a busy wait loop such as
% 	\texttt{for (i=0; i<1000; i++);} could be optimized out and replaced
% 	with \texttt{i=1000;}.  However, supposed the programmer wanted a
% 	delay?  Generally, though, we're not considering either issue here
% 	(eg, deletion of useless code or timing behaviour intentions of the
% 	programmer).

% 	Note that you can NOT swap \texttt{LDUR} with \texttt{STUR}, since the first
% 	might read/write to the memory location that the second writes/reads.
% 	And we even though the two instructions might use different registers,
% 	we can't tell if the register+offset of the one instruction gives the
% 	same memory address as the register+offset of the other instruction.

% \item Roughly speaking, our real interest is that the result of \texttt{STUR}
% 	(or anything else that causes a
% 	side effect relative to the CPU) is unchanged by code rearrangment.
% \item In the code block, there is a load/use hazard.  We can't swap the
% 	\texttt{LDUR} with the \texttt{ADD} above it since the \texttt{LDUR} is
% 	at the start of a loop.  We could swap the two statements after the
% 	\texttt{LDUR} since there's no dependency.
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
% \Title{Code Rearrangement Steps}
% \begin{itemize}
% \item Spot the loops

% 	Can't move code inside/outside loop
% \item Spot dependencies

% 	Forward and backward
%       \item Spot stalls

%         Load/use, branch data hazard
% \item Rearrange to get rid of stalls

% \end{itemize}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% 	\item "Can't move code inside/outside loop" -- except for branch delay slot
% 	\item Backward dependencies: If instruction 104 reads register X and instruction 108 writes to
% 		register X1, then you can't swap them
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
% \Title{Code Rearrangement Example}
% Branch in ID, Branch flushing, Branch data hazard stall
% \begin{verbatim}
% ADDI X4, XZR, #7
% LDUR X1, [X2,#20]
% STUR X1, [X3,#20]
% SUBI X4, X4, #-1
% CBNZ X4, #-3
% ADD X6, X7, X8
% \end{verbatim}

% Rearrange for best performance
% \BNotes\ifnum\Notes=1
% Possibly write code on board and do three steps shown on previous slide.

% The example illustrates some details you need to get correct
% \begin{itemize}
% \item We want the same behavior (in terms
% 		of contents of registers) at the end of execution as we
% 		would get on the single cycle computer.
% \item The ``Branch data hazard stall" refers to having to stall when the
% 	branch is in the ID stage if the instruction before it writes to a
% 	register used by the branch.
% \item Solution:
% \begin{verbatim}
% ADDI X4,XZR,#7
% LDUR X1,[X2,#20]
% SUBI X4,X4,#-1
% STUR X1,[X3,#20]
% CBNZ X4,#-3
% ADD X6,X7,X8
% \end{verbatim}
% \item Note the following
% \begin{itemize}
% \item The lw/sw have a load-use hazard, 

% 		We can't move the ADDI X4,XZR,\#7 to get rid of the lw/sw stall
% 		because it is outside the loop.
% \item The ADDI X4,X4,\#-1 has a branch data hazard stall with the CBNZ
% \end{itemize}
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
% \STitle{Exceptions}
% \begin{itemize}
% \item Interrupt: external event unexpectedly changing control flow 

% 	I/O

% \item Exception: internal event unexpectedly changing control flow

% 	Arithmetic overflow

% \item Some books use {\it interrupt} for both concepts;

% 	this book used {\it exception} for both concepts

% \item OS will process exception

% To handle exception,
% \begin{itemize}
% 	\item Save PC for interrupted instruction
% 	\item Remember what caused exception
% \end{itemize}
% \end{itemize}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item This material is in Section 4.9.
% \end{itemize}
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
% \Title{What caused the exception}
% \begin{itemize}
% 	\item Two general ways to note what caused the exception:
% 	\begin{itemize}
% 		\item {\it Cause register}: status register that holds
% 			field noting cause of exception

% 			OS checks cause register to process exception

% 		\item {\it Vectored interrupts}: table of addresses,
% 			one for each type of exception

% 			When interrupt A occurs, branch to routine that
% 			processes interrupt A

% 			OS can determine exception type by looking up
% 			address in table
% 	\end{itemize}
% 	\item Book uses cause registers, but notes it's really no different (hardware-wise) to use vectored interrupts
% \end{itemize}
% \BNotes\ifnum\Notes=1
% ~
% \fi\ENotes
% \end{frame}


% \begin{frame}[fragile]
% \Title{Hardware for Exception Handling}
% 	\PHFigure{!}{5in}{3in}{ARMFigures/Fig0464-crop}{Figure 4.64}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% 	\item Note: upper arrow to =0 unit shouldn't be there.
% 	\item New hardware:
% 	\begin{itemize}
% 		\item ELR --- address of affected instruction

% 		\item ESR: A register used to record the cause of the
% 			exception
% 		\item New input to PC: address of exception handler
% 		\item Not shown in figure: Overflow bit of ALU
% 			is new input to Control unit
% 	\end{itemize}
% 	\item This handles exceptions as another form of control hazard.

% 		Thus, must flush instructions following interrupted
% 		instruction, 

% 		and begin fetching instructions from
% 		exception handler
% 	\item New control signal, EX.Flush

% 		Get rid of instruction ADD instruction
% 		stage.
% 	\item New control signal, ID.Flush, ORed with stall signal

% 		Get rid of instruction after one in EX stage.
% 	\item Existing IF.Flush signal gets rid of instruction two after one in EX stage
% 	\item One gotcha: should exception instruction finish its
% 		execution?  Ie, should it write its result back to
% 		register file?  In this implementation, the result
% 		is NOT written back; note the EX.flush signal clearing
% 		the WB signal.
		
% \end{itemize}
% \fi\ENotes
% \end{frame}


% \begin{frame}[fragile]
% \Title{Exception Example}
% Assume this code executes (addresses in hex)
% \begin{verbatim}
% 40 SUB X11, X2, X4
% 44 AND X12, X2, X5
% 48 ORR X13, X2, X6
% 4C ADD X1, X2, X1 // This is going to cause the exception
% 50 SUB X15, X6, X7
% 54 LDUR X16, [X7,#100]
% \end{verbatim}
% and exception handler code is (addresses in hex)
% \begin{verbatim}
% 1C090000 STUR X25, [XZR,#1000]
% 1C090004 STUR X26, [XZR,#1004]
% \end{verbatim}
% \BNotes\ifnum\Notes=1
% ~
% \fi\ENotes
% \end{frame}

% \begin{frame}[fragile]
% 	\RFigureCR{!}{5in}{3in}{Figure 4.65}{ARMFigures/Fig0465-crop}{90}
% \BNotes\ifnum\Notes=1
% \begin{itemize}
% \item In the top half, go over all the things discussed three slides ago, pointing
% 	out where the various lines go high, etc.  Then show where
% 	the bubbles appear in the bottom half, and the new instruction
% 	(for exception) appears in the bottom half.
% \end{itemize}
% \fi\ENotes
% \end{frame}

\begin{frame}[fragile]
\STitle{Conclusion}
 \underline{\textbf{Lecture Summary}}
 \begin{itemize}
\item Design solutions to overcome control hazards:

\begin{itemize}
\item Branch decision-making moved to ID stage
    \item Forwarding unit extends to forward to ID stage

\item Flushing instruction 
\item Branch prediction, assuming hardware for: 
\begin{itemize}
    \item branch \textbf{not} taken 
\item branch \textbf{taken}
\item one and two bit dynamic branch prediction
\end{itemize}
    \end{itemize}
\item Performance analysis of pipelined datapath
\end{itemize}
 % \end{itemize}
 \underline{\textbf{Assigned Textbook Readings}}
\begin{itemize}
     \item \textbf{Read} Section 4.8 %4.9 for exception handling
     \end{itemize}
    \underline{\textbf{Next Steps}}
    \begin{itemize}
     \item \textbf{Review} Pipelined datapath and data and control hazards 
% \begin{itemize}
%     \item Start the exercises in A5
% \end{itemize}
\item \textbf{Next week}, we will introduce exception handling to pipelined datapath
\item \textbf{Attempt} questions in this week's tutorial. 
    \item \textbf{Ask} questions in office hours or the next tutorial.
 \end{itemize}

\end{frame}

 % \begin{frame}{Additional Slides}
 %     Remaining slides are additional notes for your information.
 % \end{frame}

% \end{Lecture}